<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fi" lang="fi">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
          <title>Web-sovellusohjelmointi, kevät 2012</title>
		<link rel="stylesheet" href="stylesheets/common.css" type="text/css" media="screen, print" />
		<script type="text/javascript" src="javascripts/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="javascripts/exercises.js"></script>		
		<script type="text/javascript" src="javascripts/common.js"></script>
		
		<script type="text/javascript" src="javascripts/shjs/sh_main.min.js"></script>
		<script type="text/javascript" src="javascripts/shjs/sh_java.min.js"></script>
		<script type="text/javascript" src="javascripts/shjs/sh_xml.min.js"></script>
		<link rel="stylesheet" href="stylesheets/shjs/sh_style.css" type="text/css" media="screen, print" />
		<link rel="stylesheet" href="stylesheets/exercises.css" type="text/css" media="screen, print" />
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28192637-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
	</head>

	<body>
		<h1>Web-sovellusohjelmointi</h1>

		<p>Arto Vihavainen, kurssiassistenttina Matti Luukkainen</p>
		
		<div id="toc" class="menu">
		  <p><strong>Materiaali</strong></p>
		  <div id="materiaali_toc"></div>
		  <p><strong>Tehtävät</strong></p>
		  <div id="tehtavat_toc"></div>
		</div>

		<h2>Lukijalle</h2>

		<p>Tämä materiaali on tarkoitettu kevään 2012 kurssille web-sovellusohjelmointi. Materiaali päivittyy kurssin edetessä ja sisältää myös kurssiin liittyvät tehtävät.</p>
		
		<p>Lue materiaalia siten, että teet samalla itse kaikki lukemasi esimerkit. Esimerkkeihin kannattaa tehdä pieniä muutoksia ja tarkkailla, miten muutokset vaikuttavat ohjelman toimintaan. Äkkiseltään voisi luulla, että esimerkkien tekeminen ja muokkaaminen hidastaa opiskelua. Tämä ei kuitenkaan pidä ollenkaan paikkansa. Oppiminen perustuu oleellisesti aktiiviseen tekemiseen ja rutiinin kasvattamiseen. Esimerkkien ja erityisesti omien kokeilujen tekeminen on parhaita tapoja sisäistää luettua tekstiä.</p>

		<p>Pyri tekemään tai ainakin yrittämään tehtäviä sitä mukaa kuin luet tekstiä. Jos et osaa heti tehdä jotain tehtävää, älä masennu, sillä saat ohjausaikoina neuvoja tehtävien tekemiseen.</p>

		<p>Tekstiä ei ole tarkoitettu vain kertaalleen luettavaksi. Joudut varmasti myöhemmin palaamaan aiemmin lukemiisi kohtiin tai aiemmin tekemiisi tehtäviin. Tämä teksti ei sisällä kaikkea oleellista web-sovellusohjelmointiin liittyvää. Itse asiassa ei ole olemassa mitään kirjaa josta löytyisi kaikki oleellinen. Eli joudut joka tapauksessa ohjelmoijan urallasi etsimään tietoa myös omatoimisesti. Kurssin harjoitukset sisältävät jo jonkun verran ohjeita, mistä suunnista ja miten hyödyllistä tietoa on mahdollista löytää.</p>

		<p></p>	

		<h3>Ohjelmointiympäristö</h3>

		<p>Ohjelmointiympäristöt tarjoavat kokoelman hyödyllisiä apuvälineitä usein toistuviin tapahtumiin, kuten ohjelmointiprojektien luomiseen, projektin paketointiin ym. Käytämme kurssin esimerkeissä <a href="http://www.netbeans.org" target="_blank">NetBeans</a>-ohjelmointiympäristöä. Ohjelmointiympäristön tai tuottavuutta yhtä paljon helpottavan työkalun käyttäminen on suositeltavaa. Älä siis ohjelmoi &lt;<em>aseta tähän joku perustekstieditori kuten nano, gedit, notepad tai notepad++</em>&gt;:lla. Vaikka ohjelmointiympäristön käyttö voi aluksi tuntua vaikealta tutustumiseen menevän ajan takia, pääset myöhemmin nostamaan käyttämäsi ajan korkoina.</p>
		
		<p>Esimerkeissä ja tehtävissä oletetaan että käytössäsi on NetBeansin versio 7.1 (tai uudempi)</p>	


                <h3 id="web_sovelluksista">Web-sovelluksista</h3>

		<p>Web-sovellukset koostuvat hieman yksinkertaistaen datasta jolle on määritelty ilmaisumuoto. Selainohjelmointiin ja käyttöliittymäsuunniteluun keskityttäessä painotetaan ulkoasun ja sisällön erotusta toisistaan <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>:n avulla, sekä luodaan interaktiivista toiminnallisuutta Javascriptiin ja nykyaikaisiin web-teknologioihin tukeutuen. <a href="http://en.wikipedia.org/wiki/HTML5" target="_blank">HTML5</a> tukee videoiden näyttämistä, musiikin soittamista ja piirtämistä. <a href="http://en.wikipedia.org/wiki/WebGL" target="_blank">WebGL</a> laajentaa Canvas-toiminnallisuutta tuoden 3D-tuen ja -kiihdytyksen selaimiin.</p>

		<p>Web-sovellukset eivät sisällä sivuja samalla tavalla kuin perinteiset web-sivut sisältävät. Vaikka web-sovelluksessa voi ulkopuolisen silmin olla esimerkiksi 5 sivua, uuden sisällön lisääminen tietokantaan tai vastaavaan tietoa tallentavaan järjestelmään mahdollistaa sivumäärän kasvattamisen ilman muutoksia lähdekoodissa. Käyttäjälle tarjotut hakutoiminnallisuudet mahdollistavat lähes rajattoman määrän sivuja; kukaan ei kirjoittaisi näitä käsin.</p>

		<p>Pieni määrä sivupohjia (ns. templateja) ja sovelluslogiikkaa mahdollistaa sivujen luomisen lennosta suoraan web-osoitetta tai lomakkeella lähettyä dataa käyttäen.</p>

		<p>Keskivertokäyttäjälle web-sovellukset näyttävät samalta kuin perinteiset web-sivut. Yksinkertaisen web-sovelluksen lähdekoodia katsottaessa voi olla mahdotonta päätellä ovatko sivut luotu dynaamisesti vai kirjoitettu jotain editoria käyttäen (tai käsin). Web-osoitteesta voi yrittää päätellä jotain (.html, ...), mutta oikeasti web-osoitteiden päätteet ovat vain osa osoitetta -- .html -päätteisellä sivulla voi hyvin olla web-sovellus taustalla. Web-sovellus näyttää usein sovellukselta vain niille jotka muokkaavat sovellukseen liittyvää dataa. Sekä sovelluksen käyttö että datan muokkaus tapahtuu yleensä HTML-käyttöliittymää käyttäen. Web-sovellusta voi hallita myös työpöytäsovelluksella, joka muokkaa web-sovelluksen käyttämää dataa.</p>

		<p>Javascript (käytännössä AJAX, <em>Asynchronous JavaScript and XML</em>) mahdollistaa sivujen sisällön uudelleen lataamisen ja päivittämisen ilman että käyttäjän tarvitsee tehdä erillisiä pyyntöjä tai kirjoittaa uutta osoitetta selaimen osoitepalkkiin.  AJAX mahdollistaa muutosten tekemisen taustalla -- ilman että käyttäjän tarvitsee siirtyä sivulta toiselle -- joka pienentää web-sovellusten ja työpöytäsovellusten välistä eroa.</p>

		<p>Työpöytäsovellukset tarjoavat enemmän interaktiivisuutta ja nopeutta web-sovelluksiin verraten. Web-sovellukset mahdollistavat saumattomat ohjelmistojen päivitykset, todellisen tiedot ja dokumenttien jakamisen ja kevyet käyttöliittymät.</p>

		<p>Elämme jatkuvaa muutosta. Muutoksesta riippumatta web-sovellukset ovat järjestelmiä, jotka sisältävät dataa. Dataa voi käsitellä web-sivujen kautta ja muita rajapintoja käyttäen. Google tarjoaa Google Documents -palvelua ilmaiseksi kaikkien käyttöön, mahdollistaen käyttäjälle pääsyn dokumentteihin mistä tahansa. Microsoft tarjoaa kaikille ilmaista sähköpostipalvelua, verkko on täynnä ilmaisia webissä toimivia pelejä...</p>

		<p>Tälläkin hetkellä ohjelmistoyhtiöt ympäri maailmaa kehittävät uusia innovaatioita, jotka tulevat tulevaisuudessa syrjäyttämään perinteiset työpöytäsovellukset.</p>


		<h3 id="web_sovellusten_kehittäminen">Web-sovellusten kehittäminen</h3>

		<p>Sovellusten arkkitehtuurista perinteisesti puhuttaessa puhutaan talojen tai rakennusten rakentamisesta. Taloa suunnitellessa arkkitehdillä on selkeä tehtävä ja tavoitteet: kerää vaatimukset, tutki vaihtoehtoja ja luo pohjapiirrustus. Pohjapiirrustusta seuraten erillinen joukko työntekijöitä -- rakennusmiehet -- rakentaa konkreettisen rakennuksen.</p>

		<p>Ohjelmistoja suunniteltaessa arkkitehti osallistuu sekä ohjelmiston suunnitteluun että kehitykseen -- eli konkreettiseen rakentamiseen.  Suunnittelussa hän aloittaa perustarpeista ja muutamasta huoneesta, jonka jälkeen jo muutama ihminen alkaa käyttämään rakennusta. Kun alkuperäinen suunnitelma on lähes valmis, rakennukseen muuttaa lisää ihmisiä. Nämä tarvitsevat lisää rakennukselta -- huoneita, pesulan, diskon ja luonnollisesti oleskelutilan, jossa on tilaa biljardipöydälle. Arkkitehti soveltaa alkuperäistä suunnitelmaansa mukauttamaan uudet ihmiset ja kehitystyö jatkuu.</p>

		<p>Toimintoja kehitettäessä alkuperäiset asukkaat eivät muuta pois, vaan valittavat jatkuvasta rakennusmelusta. Yhä enemmän ihmisiä muuttaa rakennukseen ja rakennukselta vaaditaan taas lisää (mm. cartingrata ja curlinghalli).</p>

		<p>Hyvän arkkitehtuurisuunnittelun perusta on mahdollisuuksien huomiointi. Huomioinnilla ei tarkoiteta sitä, että lähdettäisiin heti rakentamaan isoa järjestelmää -- käytännössä järjestelmän valmistuessa sille ei olisi käyttäjiä sillä kaikki olisivat siirtyneet toiseen aiemmin ominaisuuksia tarjonneeseen järjestelmään. Jos alkuperäinen suunnitelma tekee järjestelmän laajentamisesta vaikeaa, käyttäjät saattavat vaihtaa palvelua hitauden takia.</p>

		<p>Ohjelmistokehityksessä saadaan käytännössä hyvin harvoin ensimmäisellä yrityksellä rakennettua toimiva ja tyydyttävä ratkaisu. Jokaista ohjelmistoa joudutaan laajentamaan, rajaamaan ja refaktoroimaan. Asiakkaalla tai asiakkailla on käytännössä aina uusia toivomuksia ohjelmiston elinkaaren varrella.</p>

		<p>Arkkitehtuurin tulee mahdollistaa sopivan kokoisesta palasta aloittaminen sekä rakennettavan sovelluksen laajentaminen -- myös toisten kehittäjien toimesta -- mahdollisimman kevyesti. Hyvin harvat ohjelmistot ovat vain yhden ihmisen käsialaa, avoimeen lähdekoodiin ja online-versionhallintatyökaluihin (esim github) perustuvat projektit saavat ihmiset eri puolilta maailmaa tekemään työtä yhteisen mielenkiinnon parissa. Ryhmätyössä sovittujen käytänteiden (esim. nimeämiskäytänteet, versionhallinta, testaus, dokumentointi ym.) olemassaolo on oleellista. Kommunikointi niin koodin kautta kuin muita väyliä käyttäen on oleellista -- muuttujanimet <code>a, b, c, foo</code> ja <code>bar</code> aiheuttavat lukijalle lähinnä kylmiä väreitä.</p>

		<p>Web-sovelluskehityksessä nopeasta kehityssyklistä on paljon hyötyä. Työkaluja valittaessa tarkoituksena on välttää nurkkaan ajautumista -- työkaluista pitää pystyä myös pääsemään eroon. On paljon hyödyllisempää miettiä asiaa päivä ja käyttää muutama päivä prototyypin tekemiseen -- jota voidaan parantaa kuukausia -- kuin miettiä kuukausi ja sitouttaa itsensä kuukauden aikana luotuun suunnitelmaan. Mitä nopeammin toiminnallisuutta on olemassa, sitä nopeammin siitä saa palautetta.  Mitä vähemmän käytämme aikaa yksittäisen toiminnallisuuden toteuttamiseen -- <a href="http://en.wikipedia.org/wiki/KISS_principle" target="_blank">KISS</a> -- sitä helpommin siitä voi tarpeen vaatiessa hankkiutua eroon.</p>

		<h2 id="ensimmäinen_ohjelma">Ensimmäinen web-sovellus</h2>

		<p>Ensimmäisen web-sovelluksen tekeminen tapahtuu ohjattuna tehtäväsarjana.</p>


<div class="tehtavat">
		<h3>Ohjelmointiympäristöön tutustuminen ja ensimmäinen Servlet</h3>

		<h4>NetBeans</h4>

		<p>Käynnistä NetBeans. Jos käytössäsi ei ole NetBeansia, lataa se ensin osoitteesta <a href="http://www.netbeans.org" target="_blank">http://www.netbeans.org</a>. Käytämme kurssilla versiota 7.1, mutta uudemmatkin versiot kelpaavat. Kun lataat NetBeansin, valitse versio jossa on käytössä <em>kaikki mausteet</em> (eli <em>all</em>).</p>

		<div><img src="opas/eka-servlet/img/nb-7.1.png" /></div>
		
		<p>NetBeans koostuu useammasta alueesta. Vasemmalla laidalla on projektivalikko (<em>Projects</em>), sekä välilehdet tiedostoille (<em>Files</em>, projektiin liittyvät ei-projektinäkymässä näkyvät tiedostot, esimerkiksi testidata ym) ja palveluille (<em>Services</em>, esim. tietokantayhteydet ja palvelimet).  Tällä hetkellä ei meillä ei ole yhtään käytössä olevaa projektia. Hiiren kursorin osoittamassa kohdassa näkyy aktiiviset lähdekooditiedostot. Alalaidassa on tulostusalue. Alalaitaan tulee myös erilaisten palvelujen (esim. kehitysvaiheessa käytettävän integroidun web-palvelimen tulostus -- <em>älä huoli jos tätä ei näy sinulla!</em>). </p>

		<p>Ylälaidassa on erilaisia valikoita sekä pikakuvakkeita.</p>

		<h4>Ensimmäisen web-sovellusprojektin luominen</h4>

		<p>Valitse File-valikko ja klikkaa New Project-vaihtoehtoa.</p>

		<div><img src="opas/eka-servlet/img/nb-file-newproject.png" /></div>

		<p>Kun valitset "New Project", eli uuden projektin luominen, NetBeans avaa eteesi projektityyppivalikon. Valitse Java Web ja Web Application. Paina Next. </p>

		<div><img src="opas/eka-servlet/img/nb-new-project-web-app.png" /></div>

		<p>Tämän jälkeen sinulta kysytään projektin nimeä ja sijaintia. Aseta projektin nimeksi <em>eka-servlet</em>, jätä muut asetukset sellaisiksi kuin ne ovat. Varmista että vaihtoehto "Use Dedicated Folder for Storing Libraries" on ruksaamatta ja valitse Next.</p>

		<div><img src="opas/eka-servlet/img/new-web-application.png" /></div>
		
		<p>Eteesi aukeaa kehityspalvelimen ja projektin asetukset (<em>Server and Settings</em>). Valitse joku palvelin, esimerkiksi Apache Tomcat. Voit valita käyttöösi myös jonkun muun palvelimen kuin Apache Tomcatin. <strong>Huom!</strong> Valitse Java EE-versioksi "Java EE 5". Aseta kontekstipoluksi (Context Path), eli poluksi missä web-sovelluksesi kuuntelee pyyntöjä, <code>/eka-servlet</code>.</p>

		<div><img src="opas/eka-servlet/img/eka-servlet-settings.png" /></div>
		
		<p>Paina seuraavaksi Finish. Jos painoit Next, älä valitse sovelluskehyksiä (Frameworks) käyttöön -- ne eivät ole oleellisia tässä tehtävässä).</p>

		<p>NetBeansin vasemmassa laidassa on nyt aktiivisena projekti <em>eka-servlet</em> -- aktiivisen projektin näkee tummennetusta nimestä. Keskellä näkyy projektiin liittyvä <code>index.jsp</code>-niminen lähdekooditiedosto, joka näytetään oletuksena kun web-sovellus avataan selaimessa.</p>
		
		<p>Vasempaan alalaitaan on ilmestynyt navigaatioalue, joka näyttää aktiivisena (eli keskellä olevassa editointialueessa olevan) tiedoston rakenteen. Tämä on hyödyllinen kun halutaan nopea yleiskuva tiedostosta.</p> 

		<div><img src="opas/eka-servlet/img/eka-servlet-projekti.png" /></div>

		<h4>Testaa NetBeansiin integroitua palvelinta</h4>

		<p>Kun web-projekti on aktiivisena, voit tarkastella sen toimintaa palvelimella. NetBeansiin integroitu web-palvelin käynnistyy kun painat yläpalkissa olevaa vihreää play-nappia tai näppäintä <em>F5</em>.</p>

		<p>Projektin käynnistäminen avaa myös uuden selainikkunan, jossa näytetään projektiin liittyvä pääsivu (tässä index.jsp). Uuden selainikkunan automaattisen avautumisen voi asettaa pois päältä projektiin liittyvissä asetuksissa (valitse projekti oikealla hiirennapilla, valitse Properties -> Run -> "Display Browser on Run".</p>

		<p>Alla näemme kuvan siitä miltä sovelluksemme näyttää tällä hetkellä. Huomaa että sovelluksen polkuna on <code>eka-servlet</code> eli aiemmin valitsemamme kontekstipolku.</p>

		<div><img src="opas/eka-servlet/img/hello-world-img.png" /></div>

		<h4>Uuden Servletin luominen</h4>

		<p>Servlet "servletti" on Java-ohjelma, joka suoritetaan palvelimella käyttäjän selatessa servlettiin liittyvään osoitteeseen.</p>

		<p>Luodaan ensimmäinen oma servlet. Alla olevassa kuvassa on näytetty miten lähdekoodikansioon voi luoda servletin. Avaa projekti projektivalikossa painamalla sitä vasemmalla hiirennapilla. Näet neljä erillistä kansiota: <em>Web Pages</em>, joka sisältää web-sivut sekä konfiguraatiotiedostoja, <em>Source Packages</em>, joka sisältää lähdekooditiedostoja, <em>Libraries</em>, joka sisältää käytössä olevia apukirjastoja, ja <em>Configuration Files</em>, joka sisältää oleelliset konfiguraatiotiedostot yhdessä paikassa.</p>

		<p>Vasemmassa laidassa näkyvä hakemistorakenne ei ole projektin oikea "fyysinen" hakemistorakenne. Näkymä on tehty helpottamaan käytössä olevien asioiden muistamista.</p>

		<p>Valitse "Source Packages" oikealla hiirennapilla, valitse New ja Servlet...</p>

		<div><img src="opas/eka-servlet/img/luo-uusi-servlet.png" /></div>

		<p>Eteesi aukeaa uuden Servlet-luokan tekoa helpottava työkalu. Valitse Luokan nimeksi (Class Name) <code>AwesomeServlet</code> ja aseta pakkaukseksi (Package) wad. Paina lopuksi Finish.</p>

		<div><img src="opas/eka-servlet/img/awesomeservlet.png" /></div>

		<p>NetBeansin keskellä olevassa ikkunassa on juuri luodun Servlet-luokan lähdekoodi, vasemmassa alalaidassa on nopea yhteenveto luokassa olevista metodeista. NetBeans luo käyttöösi nipun valmiita metodeja, joita voit laajentaa. Oleellisimpia metodeja ovat <code>doGet</code> ja <code>doPost</code>, jotka käsittelevät pyyntöjä. GET- ja POST-sanan merkitykseen palataan myöhemmin.</p>

		<div><img src="opas/eka-servlet/img/awesomeservlet-src.png" /></div>

		<p>NetBeans on luonut käyttöösi erillisen <code>processRequest</code>-metodin, jota <code>doGet</code> ja <code>doPost</code> kutsuvat. Metodi <code>processRequest</code> käyttää <code>HttpServletResponse</code>-olioon liittyvää <code>PrintWriter</code>-olion tarjoamaa <code>println</code>-metodia viestin tulostamiseksi käyttäjän tekemän pyynnön vastaukseksi.</p> 

		<div><img src="opas/eka-servlet/img/awesomeservlet_src.png" /></div>
		
		<h4>Tutustu web.xml:ään</h4>

		<p>Web-sovellukset koostuvat useammasta osasta. Servlettimme <code>AwesomeServlet</code> on vain yksi osa kokonaisuutta.</p>

		<p>Jotta palvelin tietäisi minne mikäkin pyyntö tulisi ohjata, kuuluu isoon osaan Java-maailman web-sovellusprojekteista konfiguraatiotiedosto <em>web.xml</em>. NetBeansin web-sovellusprojekteissa se löytyy kansiosta "Configuration Files". Etsi <code>web.xml</code> ja avaa se.</p>
		
		<div><img src="opas/eka-servlet/img/servlet-conf-web_xml.png" /></div>

		<p>Tiedosto <em>web.xml</em> sisältää yksittäiseen projektiin liittyvän servlet-ohjauksen (<em>servlet mapping</em>), joka määrittelee palvelimelle missä osoitteessa mitäkin Servlet-luokkaa tulee kutsua.</p>

		<div><img src="opas/eka-servlet/img/web_xml_konffi.png" /></div>

		<p>Oleellisia AwesomeServlet-servletin kannalta ovat seuraavat rivit:</p>

<pre class="sh_xml">
    &lt;servlet&gt;
        &lt;servlet-name&gt;AwesomeServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;wad.AwesomeServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;AwesomeServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/AwesomeServlet&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</pre>

		<p>Määre &lt;servlet&gt; sisältää Servlet-luokan nimen (servlet-name) "AwesomeServlet" ja käännetyn lähdekooditiedoston sijainnin (servlet-class) "wad.AwesomeServlet". Määre &lt;servlet-mapping&gt; sisältää osoitteen (url-pattern) "/AwesomeServlet" mitä aiemmin määritellyn niminen (servlet-name) servlet "AwesomeServlet" kuuntelee. Normaalisti Servleteistä koostuvissa web-sovelluksissa on useampia servlettejä ja niihin liittyviä konfiguraatioita, jokainen Servlet kuuntelee yhtä tai useampaa osoitetta.</p>

		<h4>Selaa AwesomeServlet-luokan osoitetta kuuntelevaan osoitteeseen</h4>

		<p>Sovelluksemme kontekstipolku on <code>eka-servlet</code>. Juuri luotu servlettimme kuuntelee osoitteessa <code>/AwesomeServlet</code>. Mene selaimella osoitteeseen <code>&lt;palvelimen osoite&gt;/eka-servlet/AwesomeServlet</code>. Selaimen palvelimelle tekemä pyyntö ohjautuu servletille AwesomeServlet.</p>

		<div><img src="opas/eka-servlet/img/browser-awesomeservlet.png" /></div>

		<p>Jos et näe yllä olevaa vastausta, varmista että palvelimesi on päällä. Näet myös Servlettiin ohjautuneen pyynnön lisätietoja NetBeansin alalaidassa.</p>

		<div><img src="opas/eka-servlet/img/awesomeservlet-debug-info.png" /></div>

		<h4>AwesomeServlet-luokan muuttaminen</h4>

		<p>Muuta servlet-luokassa tapahtuvaa tulostusta siten, että näet viestin <em>Awesomer!</em>.</p>

		<div><img src="opas/eka-servlet/img/awesomer.png" /></div>

</div>


                <h2 id="client_server_malli">Asiakas-palvelin -malli</h2>

		<p>Asiakas-palvelin -mallissa <em>(Client-Server model)</em> asiakkaat käyttävät palvelimen tarjoamia palveluja. Kommunikointi asiakkaan ja palvelimen välillä tapahtuu usein verkon yli siten, että asiakasohjelmisto ja palvelinohjelmisto sijaitsevat erillisissä fyysisissä sijainneissa (eri tietokoneilla). Palvelinohjelmisto tarjoaa yhden tai useamman palvelun, joita asiakasohjelmisto käyttää.</p>

		<p>Käytännössä asiakasohjelmisto tarjoaa käyttöliittymän ohjelmiston loppukäyttäjälle. Asiakasohjelmiston käyttäjän ei tarvitse tietää, että kaikki käytetty tieto ei ole hänen koneella. Käyttäjän tehdessä toiminnon asiakasohjelmisto pyytää tarpeen vaatiessa palvelimelta käyttäjän tarpeeseen liittyvää lisätietoa. Tyypillistä mallille on se, että palvelin tarjoaa vain asiakkaan pyytämät tiedot. Tällöin verkossa liikkuvan tiedon määrä pysyy vähäisenä.</p>

		<p>Asiakas-palvelin -malli mahdollistaa hajautetut ohjelmistot: asiakasohjelmistoa käyttävät loppukäyttäjät voivat sijaita eri puolilla maapalloa palvelinohjelmiston sijaitessa tietyssä paikassa.</p> 

		<h3 id="client_server_mallin_haasteita">Asiakas-palvelin -mallin haasteita</h3>

		<p>Keskitetyillä palveluilla on mahdollisuus ylikuormittua asiakasmäärän kasvaessa. Kapasiteettia rajoittavat muunmuassa palvelimen fyysinen kapasiteetti (rauta), palvelimeen yhteydessä olevan verkon laatu ja nopeus, sekä tarjotun palvelun tyyppi (esim. tietokantatransaktiota vaativat pyynnöt vievät huomattavasti enemmän aikaa kuin yksinkertaiset lukuoperaatiot). Asiakas-palvelin mallissa tuottaa haasteita myös vikasietoisuus, miten toimia jos palvelinkoneesta hajoaa esimerkiksi kovalevy?</p>


<div class="tehtavat">

  <h3>Asiakas-palvelin -malli -- Chuck Norris</h3>

  <p>Valitse sopiva web-selain ja mene osoitteeseen <a href="http://www.imdb.com" target="_blank">http://www.imdb.com</a>. Kirjoita sivuston ylälaidassa olevaan kenttään "Chuck Norris" ja paina Enter. Mitkä seuraavista askeleista tapahtuivat asiakasohjelmistossa, mitkä palvelinohjelmistossa, mitkä muualla? Jos vastauksesi on muualla, kerro missä. Voit olettaa että asiakasohjelmistolla tarkoitetaan valitsemaasi web-selainta.</p>
  <ol>
    <li>Osoitteen http://www.imdb.com kirjoittaminen.</li>
    <li>Osoitetta http://www.imdb.com vastaavan palvelimen etsiminen.</li>
    <li>Sivun http://www.imdb.com näyttäminen web-selaimen käyttäjälle.</li>
    <li>Chuck Norrikseen liittyvien tietojen ja elokuvien haku elokuvadatasta.</li>
  </ol>

  <h3>Asiakas-palvelin -mallin haasteita</h3>

  <p>Lue Helsingin sanomien artikkelit <a href="http://www.hs.fi/tulosta/1135243066804" target="_blank">Lippupisteen järjestelmässä yhä häiriöitä</a>, <a href="http://www.hs.fi/a1305548874366" target="_blank">Poliisin ja sisäministeriön verkkosivut kaatuivat</a> ja Wikipedian artikkeli <a href="http://fi.wikipedia.org/wiki/Palvelunestohy%C3%B6kk%C3%A4ys" target="_blank">Palvelunestohyökkäys</a>. Mitä tekemistä uutisissa kuvatuilla artikkeleilla on palvelunestohyökkäyksen kanssa? Miten lippupiste pystyy parantamaan palvelunsa saatavuutta? Entä miten poliisi ja sisäministeriö? Perustele.</p>  

  <h3>Knock-knock -viestiprotokolla</h3>

  <p>Eräs suosittu viestiprotokolla (eli säännöstö, joka kertoo kuinka kommunikoinnin tulee kulkea) alkaa sanoilla <code>Knock knock!</code>. Toinen osapuoli vastaa tähän <code>Who's there?</code>. Ensimmäinen osapuoli vastaa jotain, esim. <code>Art</code>, jonka jälkeen toisen osapuolen tulee vastata <code>Art who?</code>. Tähän ensimmäinen osapuoli vastaa viestillä joka päättyy <code>"Bye."</code>.</p>

<pre>
Palvelin: Knock knock!
Asiakas: Who's there?
Palvelin: Robin
Asiakas: Robin who?
Palvelin: Robin your house! Bye.
</pre>

  <h4>Palvelimen lataaminen ja käynnistäminen</h4>

  <p>Lataa palvelinohjelmisto: <a href="koodit/ViestiprotokollaPalvelin.jar" target="_blank">ViestiprotokollaPalvelin.jar</a>.</p>
  
  <p>Kun olet saanut ladattua palvelinohjelmiston sinulle sopivaan kansioon, mene kansioon komentotulkkia käyttäen ja käynnistä palvelin sanomalla
<pre>
java -jar ViestiprotokollaPalvelin.jar
</pre></p>

  <p>Palvelin käynnistyy oletuksena <a href="http://fi.wikipedia.org/wiki/Portti_(tietoliikenne)" target="_blank">porttiin</a> 12345. Jos haluat että se käynnistyy johonkin toiseen porttiin, voit antaa portin komentoriviparametrina. Palvelimen käynnistäminen esimerkiksi portissa 55555 tapahtuu kutsulla
<pre>
java -jar ViestiprotokollaPalvelin.jar 55555
</pre></p>

  <p>Kun olet saanut palvelimen päälle, siirry seuraavaan askeleeseen.</p>

  <h4>Asiakas</h4>

  <p>Täydennä allaoleva asiakasohjelmisto askelten mukaan siten, että sitä voi käyttää kommunikointiin viestiprotokollapalvelimen kanssa. Tehtävää varten kannattaa luoda erillinen ohjelmointiprojekti NetBeansissa.</p>

<pre class="sh_java">
        Socket yhteys = new Socket("localhost", <em>tähän viestiprotokollapalvelimen portti</em>);
        Scanner viestitPalvelimelta = new Scanner(yhteys.getInputStream());
        PrintWriter viestitPalvelimelle = new PrintWriter(yhteys.getOutputStream(), true);

        Scanner viestitKayttajalta = new Scanner(System.in);

        while (viestitPalvelimelta.hasNextLine()) {
            // 1. lue viesti palvelimelta
            // 2. tulosta palvelimen viesti standarditulostusvirtaan näkyville

            // 3. jos palvelimen viesti loppuu merkkijonon "Bye.", poistu toistolausekkeesta
            
            // 4. pyydä käyttäjältä palvelimelle lähetettävää viestiä
            // 5. kirjoita lähetettävä viesti palvelimelle. Huom! Käytä println-metodia.
        }
</pre>

  <p>Voit asettaa asiakasohjelmiston lähdekoodin main-metodin sisältävään luokkaan. Kun olet saanut ohjelmiston valmiiksi, suorita se. Tulostuksen pitäisi olla esimerkiksi seuraavanlainen (käyttäjän syöttämät tekstit punaisella):</p>

<pre>
Palvelin: Knock knock!
Kirjoita palvelimelle lähetettävä viesti: <font color="red">viesti</font>
Palvelin: Sinun tulee kysyä "Who's there?"
Kirjoita palvelimelle lähetettävä viesti: <font color="red">Who's there?</font>
Palvelin: Lettuce
Kirjoita palvelimelle lähetettävä viesti: <font color="red">Lettuce who?</font>
Palvelin: Lettuce in! it's cold out here! Bye.
</pre>

  <p><em>Oraclen oppaasta pistokkeisiin (Socket) on huomattavasti hyötyä tässä tehtävässä: <a href="http://docs.oracle.com/javase/tutorial/networking/sockets/index.html" target="_blank">http://docs.oracle.com/javase/tutorial/networking/sockets/index.html</a></em></p>

  <p>Kun olet saanut tehtävän tehtyä, saat suljettua viestiprotokollapalvelimen esimerkiksi valitsemalla <code>ctrl + c</code>.</p>
</div>		

                <h2 id="web_ja_http">Web ja HTTP</h2>
		
		<p><em>"I just had to take the hypertext idea and connect it to the TCP and DNS ideas and – ta-da! – the World Wide Web."</em> -- <a href="http://en.wikipedia.org/wiki/Tim_Berners-Lee" target="_blank">Tim Berners-Lee</a></p>

		<p>Kolme internetin oleellisinta osaa ovat tapa yksilöidä palvelut verkosta (DNS, <em>Domain Name Services</em> ja URI, <em>Uniform Resource Identifier</em>), protokolla viestien lähetykseen verkon yli (HTTP, <em>HyperText Transfer Protocol</em>) ja yhteinen dokumenttien esityskieli (HTML, <em>HyperText Markup Language</em>).</p>


		<h3>URI</h3>
		
		<p><em>"The most important thing that was new was the idea of URI-or URL, that any piece of information anywhere should have an identifier, which will allow you to get hold of it."</em> -- Tim Berners-Lee</p>

		<p>Verkossa sijaitseva sivusto tunnistetaan sille annetun yksilöivän osoitteen perusteella. Osoite (URI -- tai terminä käyttöön jäänyt URL, <em>Uniform Resource Locator</em>) koostuu useammasta osasta, joiden perusteella haluttuun sivustoon voidaan muodostaa oikeanlainen yhteys.</p>

<pre>
protokolla://isäntäkone[:portti]/polku/../[kohdedokumentti][?kyselyparametrit][#ankkuri]
</pre>

		<p>
		  <ul>
		    <li>protokolla: kyselyssä käytettävä protokolla, esimerkiksi http tai ftp.</li>
		    <li>isäntäkone: kone johon luodaan yhteys. Voi olla joko IP-osoite tai tekstuaalinen kuvaus.</li>
		    <li>portti: portti isäntäkoneella johon yhteys luodaan. HTTP-palvelimien oletusportti on 80. Jos palvelin käyttää eri porttinumeroa kuin 80, tulee se merkitä osoitteeseen.</li>
		    <li>polku: periaatteessa polku fyysiseen tiedostoon palvelimella. Käytännössä (nykyään) palvelun osoite, johon palvelin osaa osoittaa. Usein palvelut toimivat erillisessä koneessa sisäverkossa, ja ulkoverkkoon näkyvä kone vain toimii ohjaajana eli proxynä oikeaan palveluun.</li>
		    <li>kohdedokumentti: haettava resurssi, jos kohdedokumenttia ei ole määritelty palvelin päättelee oletusdokumentin. Usein index.html</li>
		    <li>kyselyparametrit: koostuu avain-arvo -pareista, joiden avulla palvelimelle pystyy toteuttamaan lisätoiminnallisuutta. Kuhunkin avaimeen liittyvä arvo esitetään = -merkillä, avain-arvo -parit erotetaan toisistaan &-merkillä.</li>
		    <li>ankkuri: kertoo mihin kohtaan dokumentissa tulee mennä.</li>
		  </ul>
		</p>
		
<div class="tehtavat">
  <h3>Osoitteen osat</h3>
  
  <p>Mitkä ovat osoitteen <a href="http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman" target="_blank">http://www.googlefight.com/index.php?lang=en_GB&word1=Batman&word2=Superman</a> protokolla, isäntäkone, portti, polku, kohdedokumentti, kyselyparametrit ja ankkuri? Jos joku osista puuttuu, anna esimerkki osoitteesta jossa se on.</p>
</div>
                
                <h4>DNS</h4>

		<p><a href="http://fi.wikipedia.org/wiki/DNS" target="_blank">DNS</a>, <em>Domain Name System</em>, on hajautettu nimipalvelujärjestelmä tietokoneiden ja palveluiden löytämiseksi. Sen tehtävänä on muuntaa tekstuaaliset nimet (esim <code>www.cs.helsinki.fi</code>) IP-osoitteiksi (esim. <code>http://www.cs.helsinki.fi -> 128.214.166.78</code>). Ilman DNS-palvelimia ihmisten tulisi muistaa IP-osoitteet ulkoa, joka käytännössä tarkoittaisi ettei nykyinen internet toimisi.</p>

		<p>IP-osoitteita tarvitaan oikean tietokoneen löytämiseksi.</p>

		<p>Nimipalvelimet toimivat hierarkkisesti, korkeimmalla tasolla on 13 juuripalvelinklusteria jotka osaavat ohjata pyynnöt eteenpäin sopiville nimipalvelimille.</p>

                <h3>HTTP</h3>

		<p>HTTP (<em>HyperText Transfer Protocol</em>) on TCP/IP -protokollapinon sovellustason protokolla. Web-palvelimet ja selaimet keskustelevat HTTP-protokollaa käyttäen. HTTP-protokolla perustuu asiakas-palvelin malliin, jossa jokaista pyyntöä kohden on yksi vastaus (<em>request-response paradigm</em>). Käytännössä HTTP-asiakasohjelma (jatkossa selain) lähettää HTTP-viestin HTTP-palvelimelle (jatkossa palvelin), joka palauttaa HTTP-vastauksen.</p>

		<p>Käytännössä palvelimet ja selaimet kommunikoivat hyvin harvoin suoraan keskenään (poikkeuksia: omalla koneella toimivan palvelimen käyttö), vaan välissä on yksi tai useampi välityspalvelin, jonka tehtävänä on ohjata pyyntö eteenpäin. Yhteys selaimen ja palvelimen välillä muodostuu siis ketjusta koneita. Lähetettävä viesti ja siihen liittyvä vastaus kulkee kaikkien ketjussa olevien koneiden läpi.</p>

<div class="tehtavat">
  <h3>traceroute-työkalu</h3>

  <p>Linux-ympäristöissä on käytössä <code>traceroute</code>-työkalu, jolla voi tutkia viestin kulkemaa reittiä verkossa. Sitä käytetään kirjoittamalla</p>

<pre>
traceroute palvelun_osoite.net
</pre>

  <p>Vastauksena on lista palvelimista ja ajoista, jotka kertovat minkä verran viestillä meni kuhunkin osoitteeseen pääsemisessä. Alla esimerkki kyselystä <code>traceroute www.google.fi</code>. </p>

<pre>
$ traceroute www.google.fi
traceroute to www.google.fi (209.85.137.94), 30 hops max, 60 byte packets
 1  schengen.cs.helsinki.fi (128.214.9.157)  0.164 ms  0.137 ms  0.139 ms
 2  kumpula1-cs.fe.helsinki.fi (128.214.173.153)  0.488 ms  0.523 ms  0.602 ms
 3  vallila2-kumpula1.fe.helsinki.fi (128.214.173.22)  0.724 ms * *
 4  riippa-vallila2.fe.helsinki.fi (128.214.173.241)  0.625 ms  0.608 ms *
 5  * * *
 6  se-tug.nordu.net (109.105.102.61)  7.350 ms  7.406 ms  7.382 ms
 7  se-tug2.nordu.net (109.105.97.18)  7.268 ms  7.549 ms  7.520 ms
 8  * google-gw.nordu.net (109.105.98.6)  7.509 ms *
 9  * 209.85.250.192 (209.85.250.192)  7.717 ms 216.239.43.122 (216.239.43.122)  7.819 ms
10  209.85.249.40 (209.85.249.40)  17.190 ms 72.14.233.180 (72.14.233.180)  17.361 ms 209.85....
11  72.14.233.170 (72.14.233.170)  16.934 ms 72.14.233.172 (72.14.233.172)  16.845 ms  16.739 ms
12  209.85.254.33 (209.85.254.33)  27.601 ms *  18.017 ms
13  lpp01m02-in-f94.1e100.net (209.85.137.94)  16.781 ms  16.917 ms  19.168 ms
</pre>

  <p>Tracerouten näyttämät tähdet (<code>*</code>) tarkoittavat että lähetettyyn kyselyviestiin ei annettu vastausta, tai että vastaus katosi matkalla takaisin. Tätä kutsutaan yleisesti ottaen <code>packet loss</code>:iksi.</p>

  <p>Tehtävä: Kirjaudu jollekin TKTL:n koneelle ssh:n yli (esim melkille: melkki.cs.helsinki.fi), ja tutki mitä reittiä viestit kulkevat yhdysvaltojen puolustusministeriön verkkosivuille (<code>defense.gov</code>) ja FBI:n sivuille (<code>fbi.gov</code>). Ovatko verkkosivujen palvelimet samassa maanosassa? Perustele.</p> 
</div>

                <h4>Tilattomuus</h4>

		<p>HTTP on tilaton protokolla, eli se ei tarvitse jatkuvasti avoinna olevaa yhteyttä toimiakseen. HTTP:n versio 1.0 rajoitti palvelimen ja selaimen välisen yhteyden olemassaolon yhteen pyyntö-vastaus -tapahtumaan, jolloin pyyntöjä ei ollut edes mahdollista hoitaa saman yhteyden aikana. HTTP:n versio 1.1 (<code>HTTP/1.1</code>) olettaa että yhteys on olemassa kunnes palvelin tai selain katkaisee sen.</p>

		<p>Yhteyden olemassaoloa ja pysyvyyttä ei taata, joten pelkkää yhteyttä ei voida käyttää loppukäyttäjän tunnistamiseen.</p>

		<h4>HTTP-viestien rakenne: kysely</h4>
		
		<p>HTTP-viestit koostuvat riveistä jotka muodostavat otsakkeen, sekä riveistä jotka muodostavat viestin rungon. Viestin runkoa ei ole pakko olla olemassa. Kaksi peräkkäistä rivinvaihtoa kertoo viestin loppuneen.  Otsakkeen ensimmäisellä rivillä on erikoisrivi. Palvelimille lähetettävissä viesteissä ensimmäisellä rivillä esitetään pyyntötapa, haluttu polku ja HTTP-versionumero.</p>

<pre>
PYYNTÖTAPA /POLKU_HALUTTUUN_RESURSSIIN HTTP/versio
otsake-1: arvo
otsake-2: arvo

valinnainen viestin runko
</pre>

		<p>Pyyntötapa kertoo pyynnön tavan (esim. <code>GET</code> tai <code>POST</code>), polku haluttuun resurssiin kertoo haettavan resurssin sijainnin palvelimella (esim. <code>/index.html</code>), ja HTTP-versio kertoo käytettävän version (esim. <code>HTTP/1.1</code>). Alla esimerkki hyvin yksinkertaisesta -- joskin yleisestä -- pyynnöstä. Huomaa että pyyntöä tehdessä yhteys palvelimeen on jo muodostettu. Palvelimen osoitetta ei merkitä erikseen.</p>

<pre>
GET /index.html HTTP/1.0

</pre>

		<p>Palvelinkone voi sisältää useampia virtuaalisia palvelimia. Tällöin pelkkä polku haluttuun resurssiin ei riitä oikean resurssin löytämiseen -- se voisi olla millä tahansa koneeseen liittyvällä virtuaalisella palvelimella. Tämä on ratkaistu HTTP/1.1 -protokollassa siten, että pyyntöön tulee aina lisätä käytetyn palvelimen osoitteen kertova <code>Host</code>-otsake.</p>

<pre>
GET /index.html HTTP/1.1
Host: www.munpalvelin.net

</pre>
 
<div class="tehtavat">
  <h3>telnet-työkalu</h3>

  <p>Linux-ympäristöissä on traceroute-työkalun lisäksi käytössä myös telnet, jota voi käyttää yksinkertaisena asiakasohjelmistona. Telnet-yhteyden tietyn koneen tiettyyn porttiin saa luotua komennolla</p>

<pre>
telnet isäntäkone portti
</pre>

  <p>Luo telnet-yhteys web-palvelimen <code>t-avihavai.users.cs.helsinki.fi</code> porttiin 80 ja lähetä palvelimelle seuraava viesti:</p> 

<pre>
GET / HTTP/1.0

</pre>

  <p><em>Muistathan että viesti loppuu kahteen rivinvaihtoon.</em></p>

  <p>Avaa seuraavaksi sama yhteys uudestaan, mutta lähetä tällä kertaa viesti:</p> 

<pre>
GET / HTTP/1.1
Host: t-avihavai.users.cs.helsinki.fi

</pre>

  <p>Mitä yhteistä ja mitä eroa vastausviesteissä on? Miksi?</p>

  <p><em>Copy-pastesta voi olla hyötyä tässä tehtävässä...</em></p>
</div>

                <h4>HTTP-viestin rakenne: vastaus</h4>

		<p>Palvelimelta tulevissa vastauksissa on ensimmäisellä rivillä HTTP-versionumero, viestiin liittyvä statuskoodi ja statuskoodin selvennys. Tämän jälkeen on joukko otsakkeita, tyhjä rivi, ja mahdollinen vastausrunko. Vastausrunko ei ole pakollinen.</p>

<pre>
HTTP/versio statuskoodi selvennys
otsake-1: arvo
otsake-2: arvo

valinnainen vastauksen runko
</pre>

               <p>Esimerkiksi:</p>
<pre>
HTTP/1.1 200 OK
Date: Sat, 07 Jan 2012 03:12:45 GMT
Server: Apache/2.2.14 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 973
Connection: close
Content-Type: text/html;charset=UTF-8

.. runko ..
</pre>

                <h4>Statuskoodit</h4>

		<p>Statuskoodit (<em>status code</em>) kuvaavat palvelimella tapahtunutta toimintaa kolmella numerolla. Statuskoodien avulla palvelin kertoo mahdollisista ongelmista tai tarvittavista lisätoimenpiteistä. Yleisin statuskoodi on <code>200</code>, joka kertoo kaiken onnistuneen oikein. HTTP/1.1 sisältää viisi kategoriaa vastausviesteihin.</p>

<ul>
  <li>1**: informaatioviestit (esim 100 "Continue")</li>
  <li>2**: onnistuneet tapahtumat (esim 200 "OK")</li>
  <li>3**: asiakasohjelmistolta tarvitaan lisätoimintoja (esim 301 "Moved Permanently")</li>
  <li>4**: virhe pyynnössä tai erikoistilanne (esim 401 "Not Authorized" ja 404 "Not Found")</li>
  <li>5**: virhe palvelimella (esim 500 "Internal Server Error")</li>
</ul>

		<p>Lisätietoja osoitteessa <a href="http://httpcats.herokuapp.com" target="_blank">http://httpcats.herokuapp.com</a>.<br><img src="img/200.jpg" /></p>
		  
		  
<div class="tehtavat">
  <h3>HTTP-otsakkeet -- Let's bounce!</h3>
  
  <p>Mitä osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/lets/Bounce">http://t-avihavai.users.cs.helsinki.fi/lets/Bounce</a> on ja miksen voi katsoa sitä selainta käyttäen?</p>
  
  <p><em>Copy-pastesta voi olla hyötyä tässä tehtävässä...</em></p>

  <h3>Kuinka monta kyselyä?</h3>
  
  <p>Mene selaimella TKTL:n koneilla olevalle omalle kotisivullesi käyttämällä osoitetta <code>cs.helsinki.fi/u/omatunnus</code>. Jos sinulla ei ole omaa kotisivua käytössä, voit käyttää osoitetta <code>cs.helsinki.fi/u/avihavai</code>. Toimii hyvin, eikö?</p>
  
  <p>Tutki telnetin avulla monta kyselyä selain joutuu oikeasti tekemään päästäkseen katsomaan web-sivua. Miten voit hyödyntää tätä tietoa tehokkaita web-sovelluksia suunniteltaessa?</p>
  
  <p><em>Copy-pastesta voi olla hyötyä tässä tehtävässä...</em></p>
</div>

                <h4>Pyyntötavat</h4>

		<p>HTTP-protokolla määrittelee kahdeksan erillistä pyyntötapaa (<em>Request method</em>). Yleisimmin käytetyt ovat <code>GET</code>, <code>POST</code> ja <code>HEAD</code>, joiden lisäksi on olemassa <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>OPTIONS</code> ja <code>CONNECT</code>. Pyyntötavat määrittelevät rajoitteita ja suosituksia viestin rakenteeseen ja niiden prosessointiin palvelinpäässä. Esimerkiksi <a href="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html" target="_blank">Java Servlet API (versio 2.5)</a> sisältää seuraavan suosituksen GET-pyyntotapaan liittyen:</p>

		<p><em>The GET method should be safe, that is, without any side effects for which users are held responsible. For example, most form queries have no side effects. If a client request is intended to change stored data, the request should use some other HTTP method.</em></p>
		
		<p><em>The GET method should also be idempotent, meaning that it can be safely repeated. Sometimes making a method safe also makes it idempotent. For example, repeating queries is both safe and idempotent, but buying a product online or modifying data is neither safe nor idempotent.</em></p>

		<p>Suomeksi yksinkertaistaen: <code>GET</code>-tyyppisten pyyntöjen ei pitäisi muuttaa palvelimella olevaa dataa.</p>
		
 	        <p><strong>GET</strong></p>
		
		<p>GET on yksinkertaisin pyyntötapa. Sitä käytetään esimerkiksi dokumenttien hakemiseen: kun kirjoitat osoitteen selaimen osoitekenttään ja painat enter, selain tekee GET-pyynnön. GET-pyynnöt eivät tarvitse otsaketietoja HTTP/1.1:n vaatiman Host-otsakkeen lisäksi. Mahdolliset kyselyparametrit lähetetään palvelimelle osana haettavaa osoitetta.</p>

<pre>
GET /lets/See?porkkana=1 HTTP/1.1
Host: t-avihavai.users.cs.helsinki.fi

</pre>

		<p><strong>POST</strong></p>
		
		<p>Käytännön ero POST- ja GET-kyselyn välillä on se, että POST-tyyppisillä pyynnoillä kyselyparametrit liitetään pyynnön runkoon. Rungon sisältö ja koko määritellään otsakeosiossa. POST-kyselyt mahdollistavat multimedian (kuvat, videot, musiikki, ...) lähettämisen palvelimelle.</p>

<pre>
POST /lets/See HTTP/1.1
Host: t-avihavai.users.cs.helsinki.fi
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

porkkana=1
</pre>

		<p><strong>HEAD ja otsakkeet</strong></p>
		
		<p>HEAD-kyselyt ovat samantyyppisiä GET-kyselyiden kanssa, mutta niillä pyydetään palvelimelta vain haettavaan dokumenttiin liittyviä otsaketietoja. Tämä mahdollistaa muunmuassa muutosten seurannan palvelimelta saatavan <code>Last-modified</code>-otsakkeen avulla, sekä palvelimen toiminnallisuuden testaamisen.</p>

		<p>HEAD-kyselyä on perinteisesti käytetty välimuistitoiminnallisuuden toteuttamiseen, jolloin selaimen välimuistissa olevista dokumenteista on tehty ensiksi vain HEAD-kysely. Jos dokumentti ei ole muuttunut, eli otsake <code>Last-modified</code> sisältää tarpeeksi vanhan ajan, ei dokumenttiin liittyvää runkoa ole haettu. Nykyaikaisempi tapa on <code>ETag</code>-otsakkeen käyttäminen -- palaamme tähän myöhemmin kurssilla.</code></p>

		<p>Luodaan telnetillä yhteys palvelimeen <code>www.cs.helsinki.fi</code> ja kysytään otsaketietoja resurssiin <code>/home/</code> liittyen. Käytämme HTTP:n versiota 1.1 (<code>HTTP/1.1</code>), joten lisäämme pyyntöön myös <code>Host</code>-otsakkeen.</p>

<pre>
$ telnet www.cs.helsinki.fi 80
Trying 128.214.166.78...
Connected to www.cs.helsinki.fi.
Escape character is '^]'.
HEAD /home/ HTTP/1.1
Host: www.cs.helsinki.fi 

</pre>

		<p>Vastauksena saamme palvelimen vastausrivin jossa on HTTP-versio, statuskoodi ja selvennys. Seuraavilla riveillä on otsakkeita, jotka tarjoavat lisätietoa haettavasta dokumentista ja käytettävästä palvelimesta.</p>
<pre>
HTTP/1.1 200 OK
Date: Sat, 07 Jan 2012 07:13:49 GMT
Server: Apache/2.2.14 (Ubuntu)
X-Powered-By: PHP/5.3.2-1ubuntu4.11
Last-Modified: Sun, 07 Jan 2012 07:13:51 GMT
Cache-Control: store, no-cache, must-revalidate
Cache-Control: post-check=0, pre-check=0
Vary: Accept-Encoding
Content-Type: text/html; charset=utf-8
</pre>

		<p><code>Last-Modified</code> -otsake määrittelee tulevaisuudessa olevan päivämäärän (pyyntö tehty <code>Date</code> -otsakkeen määrittelemänä ajanhetkenä). Huomaamme palvelimen otsakkeista hyödyllistä tietoa. Esimerkiksi otsake <code>Cache-Control</code> sisältää välimuistitoiminnallisuuteen liittyviä ohjeita; arvo <code>no-cache</code> määrittelee että sivun ajankohtaisuus tulee aina varmistaa palvelimelta. Huomaamme myös mielenkiintoisen arvon <code>store</code>, jota -- sen yleisessä käytössä olemisesta huolimatta -- ei määritellä HTTP/1.1 -otsakkeeseen <code>Cache-Control</code> liittyvässä <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9" target="_blank">osiossa</a> (arvo <code>store</code> on määrittelemätön laajennus).</p>



<div class="tehtavat">
  <h3>Mitä otsakkeita näet ja mitä ne tarkoittavat?</h3>

  <p>Mitä otsakkeita (Request headers) näet sivulla <a href="http://t-avihavai.users.cs.helsinki.fi/lets/See" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/See</a> ? Mitä kukin otsake tarkoittaa? Käytä apunasi sivustoja <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a> ja <a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank">http://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>.</p>

  <h3>curl-työkalu</h3>

  <p>Telnetin lisäksi myös curl on hyödyllinen työväline pyyntöjen tekemiseen. Curl tarjoaa parametrin <code>-i</code> (<em>include headers in output</em>), jota voi käyttää otsaketietojen tarkasteluun pyynnön yhteydessä. Esimerkiksi kysely <code>curl -i hs.fi</code> palauttaa seuraavat tiedot:</p>

<pre>
HTTP/1.1 301 Object Moved
Location: http://www.hs.fi/
Content-Length: 0

</pre>

  <p>Tehtävä: Mitä otsakkeita saat tekemällä curl-pyynnön osoitteeseen <code>t-avihavai.users.cs.helsinki.fi</code>? Mitä HTTP-versiota curl käyttää kyselyyn? Perustele.</p> 

</div>

		<h4>Evästeet ja tilan ylläpitäminen</h4>

		<p>HTTP on tilaton protokolla, eli käyttäjän toimintaa ja tilaa ei pysty pitämään yllä puhtaasti HTTP-yhteyden avulla. Käytännössä suurin osa verkkosovelluksista sisältää käyttäjäkohtaista toiminnallisuutta, jonka toteuttamiseen sovelluksella täytyy olla jonkinlainen tieto tilasta. HTTP/1.1 tarjoaa mahdollisuuden tilallisten verkkosovellusten toteuttamiseen evästeiden (<em>cookies</em>) avulla. Evästeitä käytetään istuntojen (<em>session</em>) ylläpitämiseen. Istuntojen avulla pystytään pitämään kirjaa käyttäjän tiedoista useampien pyyntöjen yli.</p>

		<p>Evästeet toteutetaan otsakkeiden avulla. Evästettä luotaessa palvelin lähettää selaimelle otsakkeen <code>Set-Cookie</code>, jossa määritellään käyttäjäkohtainen evästetunnus.</p>

<pre>
Set-Cookie: nimi=arvo [; Comment=kommentti] [; Max-Age=elinaika sekunteina] 
                      [; Expires=parasta ennen paiva] [; Path=polku tai polunosa jossa eväste voimassa]
                      [; Domain=palvelimen osoite (URL) tai osoitteen osa jossa eväste voimassa]
                      [; Secure (jos määritelty, eväste lähetetään vain salatun yhteyden kanssa)]
                      [; Version=evästeen versio]
</pre>

<pre>
Set-Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg; Max-Age=3600; Domain=".helsinki.fi"
</pre>

		<p>Ylläoleva palvelimelta lähetetty vastaus pyytää selainta tallettamaan evästeen. Eväste <code>SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg</code> tulee lisätä jokaiseen <code>helsinki.fi</code>-osoitteeseen tehtävään pyyntöön seuraavan tunnin ajan.</p>

		<p>Evästeet tallennetaan selaimen sisäiseen evästerekisteriin. Evästeet lähetetään palvelimelle jokaisen viestin yhteydessä. Selain lähettää evästeen tiedot <code>Cookie</code>-otsakkeessa. </p>

<pre>
Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg
</pre>

		<p>Evästeiden nimet ja arvot ovat yleensä monimutkaisia (ja satunnaisesti luotuja) niiden yksilöllisyyden takaamiseksi. Evästeet ovat sekä hyödyllisiä että haitallisia. Evästeiden avulla voidaan luoda yksiöityjä käyttökokemuksia tarjoavia sovelluksia, mutta niitä voidaan käyttää myös käyttäjien seurantaan ympäri verkkoa.</p> 




		<h3>HTML</h3>

		<p><em>"In '93 to '94, every browser had its own flavor of HTML. So it was very difficult to know what you could put in a Web page and reliably have most of your readership see it."</em> -- Tim Berners-Lee</p>

		<p>HTML on rakenteellinen kuvauskieli, jolla voidaan esittää linkkejä sisältävää tekstiä sekä tekstin rakennetta. HTML koostuu elementeistä, jotka voivat olla sisäkkäin ja peräkkäin. Elementtejä käytetään ohjeina dokumentin jäsentämiseen ja käyttäjälle näyttämiseen. HTML-dokumenteissa elementit avataan elementin nimen sisältävällä pienempi kuin -merkillä (&lt;) alkavalla ja suurempi kuin -merkkiin (&gt) loppuvalla merkkijonolla (&lt;elementin_nimi&gt), ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva (&lt;/elementin_nimi&gt).</p>

		<p>HTML:ää voi ajatella myös puumaisena kielenä. Juurisolmuna on elementti <code>&lt;html&gt;</code>, jonka lapsina ovat elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>.</p>

		<p>Jos elementin sisällä ei ole muita elementtejä tai tekstisolmuja (tekstiä), voi elementin avata ja sulkea samalla merkkijonolla: (&lt;elementin_nimi /&gt;).</p> 

		<p>HTML:stä on useita erilaisia standardeja, joista viimeisin on HTML5.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html lang="fi"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä, 
     runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
     useammalle riville.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

		<p>Ylläoleva HTML5-dokumentti sisältää dokumentin tyypin ilmaisevan aloitustägin (<code>&lt;!DOCTYPE html&gt;</code>), dokumentin aloittavan html-elementin (<code>&lt;html&gt;</code>), otsake-elementin ja sivun otsikon (<code>&lt;head&gt;</code>, jonka sisällä <code>&lt;title&gt;</code>), sekä runkoelementin (<code>&lt;body&gt;</code>).</p>

		<p>Elementit voivat sisältää attribuutteja, joille voi antaa arvoja. Esimerkiksi ylläolevassa esimerkissä html-elementille on määritelty erillinen attribuutti <em>lang</em>, joka kertoo dokumentissa käytetystä kielestä.  Ylläolevan esimerkin otsakkeessa on myös metaelementti, jota käytetään lisävinkin antamiseen selaimelle: "dokumentissa käytetään utf-8 merkistöä". Tämä kannattaa olla dokumenteissa aina.</p>

		<p>Nykyaikaiset web-sivut sisältävät paljon muutakin kuin sarjan HTML-elementtejä. Linkitetyt resurssit, kuten kuvat ja tyylitiedostot, ovat oleellisia sivun ulkoasun ja rakenteen luomisessa. Selainpuolella suoritettavat skriptitiedostot, erityisesti Javascript, ovat luoneet huomattavan määrän syvyyttä nykyaikaiseen web-kokemukseen. Tällä kurssilla emme ehdi juurikaan paneutua selainpuolen toiminnallisuuteen, mutta TKTL:llä on sitä varten erillinen kurssi <a href="http://www.cs.helsinki.fi/courses/582302" target="_blank">Digitaalisen median tekniikat</a>, kts. <a href="http://www.cs.helsinki.fi/courses/582302/2011/s/k/1" target="_blank">viime syksyn kurssisivu</a>.</em>

		<h4>Lomake</h4>
		
		<p>Lomakkeita käytetään tiedon lähettämiseen web-palveluille. HTML-elementti lomakkeelle on&lt;form&gt;. Lomake-elementille voidaan antaa attribuutteina toiminto (<code>action</code>), jolle voidaan määrittelee osoite mihin lomakkeen sisältö lähetetään, ja lomakkeen lähetystapa (<code>method</code>). Lomakkeen lähetystapa (<code>GET</code> tai <code>POST</code>) kertoo lähetetäänkö lomakkeen tiedon kyselyparametreina osana osoitetta (<code>GET</code>) vai pyynnön yhteydessä erillisenä datana (<code>POST</code>). Käytetään lähetystapaa <code>POST</code>.</p>

<pre class="sh_xml">
&lt;form action="kohdeosoite" method="POST"&gt;
</pre>

		<p>Jos attribuuttia <code>action</code> ei ole määritelty, lähetetään lomake oletuksena nykyiseen osoitteeseen. Attribuutin <code>method</code> oletusarvo on <code>GET</code>.</p>

                <h4>Lomakekentät</h4>
		
		<p>Lomake-elementin alle voi asettaa useita erilaisia kenttiä. Jos kentän arvon haluaa lähettää eteenpäin, tulee kentällä olla attribuutti nimi (<code>name</code>), jonka arvoa käytetään kenttään asetetun tiedon avaimena. </p>
<ul>

  <li>tekstikenttä: <br/><input type="text" name="kentan_nimi" />
<pre class="sh_xml">
&lt;input type="text" /&gt;
</pre></li>

  <li>salasanakenttä: <br/><input type="password" name="kentan_nimi" />
<pre class="sh_xml">
&lt;input type="password" /&gt;
</pre></li>

  <li>tekstialue: <br/><textarea name="tekstialue"></textarea><br/>Toisin kuin monet muut lomakkeen kenttäelementit, tekstialue tulee sulkea erillisellä elementillä. 
<pre class="sh_xml">
&lt;textarea name="tekstialue"&gt;&lt/textarea&gt;
</pre></li>

  <li>valintaruutu: <br/>
    <input type="checkbox" name="porkkanaa" /> Porkkanaa<br/>
    <input type="checkbox" name="naurista" /> Naurista<br/>
    <input type="checkbox" name="kaalia" /> Kaalia<br/>
    Selaimesta riippuen valintaruudun tiedot lähetetään lomakkeen mukana vain kentän ollessa valittuna. 
<pre class="sh_xml">
&lt;input type="checkbox" name="porkkanaa" /&gt; Porkkanaa &lt;br/&gt;
&lt;input type="checkbox" name="naurista" /&gt; Naurista &lt;br/&gt;
&lt;input type="checkbox" name="kaalia" /&gt; Kaalia &lt;br/&gt;
</pre>
</li>

  <li>valintanappi:<br/>
    <input type="radio" name="valinta" value="porkkanaa"/> Porkkanaa<br/>
    <input type="radio" name="valinta" value="naurista"/> Naurista<br/>
    <input type="radio" name="valinta" value="kaalia"/> Kaalia<br/>
    Valintanappia käytettäessä vain yksi saman name-attribuutin omistava radio-tyyppinen input-elementti voi olla valittuna. Lomaketta lähetettäessä valitun elementin attribuutin <code>value</code> arvo lähetetään <code>name</code> attribuutin arvona.
<pre class="sh_xml">
&lt;input type="radio" name="valinta" value="porkkanaa"/&gt; Porkkanaa&lt;br/&gt;
&lt;input type="radio" name="valinta" value="naurista"/&gt; Naurista&lt;br/&gt;
&lt;input type="radio" name="valinta" value="kaalia"/&gt; Kaalia&lt;br/&gt;
</pre></li>

  <li>lähetysnappi:<br/>
    <input type="submit" value="Lähetä" /><br/>
    Lähetysnappia painettaessa lomakkeen tiedot lähetetään kohdeosoitteeseen valitulla lähetystavalla.
<pre class="sh_xml">
&lt;input type="submit" value="Lähetä" /&gt;
</pre></li>

  </ul>

		<h4>Lomakkeen lähettäminen</h4>

		<p>Kun lomake lähetetään selain ohjaa käyttäjän kohdeosoitteeseen siten, että lähetettävän lomakkeen tiedot ovat mukana selaimen tekemässä pyynnössä. Jos lomakkeen lähetystapa on <code>GET</code>, on lomakkeen tiedot osana osoitetta. Lähetystavassa <code>POST</code> arvot tulevat erillisinä.</p>

		<p>Alla on lomake jolla voi visualisoida tietojen lähettämistä. Lomakkeiden toimintona on <a href="http://t-avihavai.users.cs.helsinki.fi/lets/See" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/See</a>), jossa on pyynnössä saatujen tiedojen tulostava web-palvelu.</p>

		<p>
		  <form method="POST" action="http://t-avihavai.users.cs.helsinki.fi/lets/See">
		    <label>Käyttäjätunnus: <input type="text" name="tunnus" /></label>
		    <label>Salasana: <input type="password" name="salasana" /></label>
		    <input type="submit" />
		  </form>
		</p>
		    
<pre class="sh_xml">
&lt;form method="POST" action="http://t-avihavai.users.cs.helsinki.fi/lets/See"&gt;
  &lt;label&gt;Käyttäjätunnus: &lt;input type="text" name="tunnus" /&gt;&lt;/label&gt;
  &lt;label&gt;Salasana: &lt;input type="password" name="salasana" /&gt;&lt;/label&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;
</pre>


<div class="tehtavat">
  <h3>Salasanat ja GET</h3>
  
  <p>Tee ylläolevasta lomakkeesta kopio siten, että se lähettää lomakkeen tiedot GET-lähetystapaa käyttäen. Jos oletetaan että jokainen verkon välityspalvelin tallettaa kohdeosoitteen tilastointia varten ja viesti kulkee 12 välityspalvelimen kautta, kuinka moneen paikkaan syöttämäsi salasana tallentui?</p>

  <h3>Chat-websovellus</h3>
  
  <p>Kerrataan seuraavaksi edellä olleita asioita ja toteutetaan pienimuotoinen Chat-verkkopalvelu (lopullinen muoto osoitteessa: <a href="http://t-avihavai.users.cs.helsinki.fi/lets/Chat" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/Chat</a>). Voit käyttää allaolevaa Chat-servlettiä runkona.</p>

<pre class="sh_java">
// täältä puuttuu pakettimäärittely ja importit

public class Chat extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {
            // tulostaminen
        } finally {
            out.close();
        }
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // ei mitään vielä
    }
}
</pre>
		
		<h4>Chat-lomake</h4>

		<p>Luo Servletluokka Chat, joka kuuntelee haluamaasi polkua. Kopioi ylläoleva runko luomasi Chat-servletluokan päälle kun olet luonut Chat-servletin NetBeansissa -- näin sinun ei tarvitse muistella web.xml:n konfigurointia.</p>

		<p>Kun käyttäjä avaa selaimella osoitteen (tekee GET-pyynnön), tulosta <code>PrintWriter</code>-luokasta tehdyn <code>out</code>-olion avulla seuraavanlainen lomake:</p>

<div class="naytto">
  <strong>Chat</strong><br/>

  <form method="POST">
    <input type="text" name="viesti" /><input type="submit" value="Lähetä" />
  </form>
</div>

		<p>Käytä seuraavaa lähdekoodia lomakkeen luontiin. Varmista että tekstikentän <code>name</code>-attribuutilla on arvona <code>viesti</code>.</p>

<pre class="sh_xml">
&lt;strong&gt;Chat&lt;/strong&gt;&lt;br /&gt;

&lt;form method="POST"&gt;
  &lt;input type="text" name="viesti" /&gt;&lt;input type="submit" value="Lähetä" /&gt;
&lt;/form&gt;
</pre>

                <h4>Viestin vastaanottaminen</h4>

		<p>Kun käyttäjä kirjoittaa viestikenttään tekstiä ja painaa Lähetä-nappia, lomakkeen sisältö (eli tekstikentän <code>viesti</code> sisältö) lähetetään POST-tyyppisenä pyyntönä oletusosoitteeseen -- eli Chat-servletillesi. Jos Chat-servletissäsi ei ole <code>doPost</code>-metodia, johon POST-tyyppiset pyynnöt päätyvät, toteuta se.</p>

<pre class="sh_java">
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // koodia
    }
</pre>

		<p>Web-palvelin tallentaa pyyntöön liittyvät parametrit <code>HttpServletRequest</code>-olioon, josta niihin pääsee käsiksi mm. metodilla <code>getParameter</code>. Lisää <code>doPost</code>-metodiin toiminnallisuus, joka tulostaa lähetetyn viestin käyttäjälle ja lopettaa suorituksen. Chat-ohjelmasi tulee siis tulostaa vain parametrina saatu viesti-kentän arvo. Esimerkiksi viesti-kentästä lähetetty viesti "Hei!"</pre> 
<div class="naytto">
  Hei!<br/>
</div>

                <h4>Viestien väliaikainen tallentaminen</h4>

		<p>Luo Chat-servletille LinkedList-tyyppinen oliomuuttuja <code>viestit</code>, johon käyttäjän lähettämät viestit tallennetaan merkkijonona.</p>

<pre class="sh_java">
// täältä puuttuu pakettimäärittely ja importit

public class Chat extends HttpServlet {

    private Queue&lt;String&gt; viestit = new LinkedList();

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
        // .. jne
</pre>

		<p>Muuta <code>doPost</code>-metodin toiminnallisuutta siten, että se pitää kirjaa kymmenestä viimeisimmästä viestistä viestistä <code>viestit</code>-listassa. Tulosta viestit näkyville.</p>

		<p>Nyt jos käyttäjä lähettää kaksi viestiä, ensimmäinen "Moi!" ja toinen "Hei!", tulee lomakkeen lähetystä seuraavan sivun näyttää seuraavalta.</p>

<div class="naytto">
  Moi!<br/>
  Hei!<br/>
</div>

		<p>Huomaa ettet voi käyttää selaimen refresh-nappia sivun uudelleenlataamiseen -- se lähettää lomakkeen tiedot uudestaan eteenpäin. Kun haluat nähdä Chat-lomakkeen, tulee sinun mennä osoitteeseen selaimella uudestaan (painaa enteriä osoitepalkissa).</p>

		<h4>Viestit Chat-sivulle</h4>
		
		<p>Lisää viestien tulostus Chat-sivulle. Kun käyttäjä on lähettänyt kaksi viestiä, tulee Chat-sivun näyttää seuraavalta. Viestien lähetyksen jälkeen käyttäjä päätyy vielä edellisessä tehtävässä määritellylle erinäköiselle sivulle.</p>

<div class="naytto">
  <strong>Chat</strong><br/>

  <form method="POST">
    <input type="text" name="viesti" /><input type="submit" value="Lähetä" />
  </form>

  <br/>
  <strong>Viestit</strong><br/>
  Moi!<br/>
  Hei!<br/>
</div>

                <h4>Uudelleenohjaus</h4>

		<p>On hyvin ärsyttävää ettei selaimen refresh-nappia voi käyttää sivun uudelleenlataamiseen. Lisätään <code>doPost</code>-metodiin uudelleenohjaus, joka pyytää selainta siirtymään uuteen -- tapauksessamme vanhaan -- osoitteeseen. Selain tekee siis POST-kutsun jälkeen uuden GET-kutsun, ja näyttää Chat-lomakkeen.</p>


		<p>HttpServletResponse-oliolla on metodit <code>sendRedirect</code>, jolla ohjauspyyntö tehdään, ja HttpServletRequest-oliolla on <code>getRequestURI</code>, jolla saadaan nykyinen osoite. Käytä näitä tietoja toteuttaaksesi <code>doPost</code>-metodin loppuun toiminnallisuus, jolla käyttäjä ohjataan chat-sivulle kun hän lähettää uuden viestin.</p>

		<p>Kun ohjaus on toteutettu käyttäjä voi viestin kirjoittamisen jälkeen painaa selaimen refresh-nappia ja nähdä päivittyneet viestit chatista -- ilman että hänen aiemmin kirjoittamansa viesti lähetetään uudestaan.</p>

		<h4>Kirjautuminen</h4>

		<p>Chat-ohjelmassa ei tällä hetkellä ole mitään tapaa erottaa käyttäjiä toisistaan. Toteutetaan kirjautumistoiminnallisuus. HTTP/1.1 mahdollistaa evästeiden avulla tapahtuvan tilan ylläpitämisen. Web-palvelimet käyttävät evästeitä ns. sessioiden luomiseen ja ylläpitämiseen.</p>

		<p>HttpServletRequest-oliolla on metodi <code>getSession</code>, jota kutsumalla saamme viitteen <code>HttpSession</code>-olioon. HttpSession-olioon tallennetut attribuutit, joita voi muokata metodeilla <code>getAttribute</code> ja <code>setAttribute</code>, ovat käytössä toisistaan erillisissä HTTP-pyynnöissä.</p>

		<p>Tee erillinen Servlet-luokka nimeltä Login, joka näyttää käyttäjälle seuraavalaisen lomakkeen.</p>

<div class="naytto">
<strong>Käyttäjätunnus</strong><br/>
<form method="POST">
<input type="text" name="tunnus" /><input type="submit" value="Kirjaudu" />
</form>
</div>

		<p>Varmista että käyttäjätunnus-kentän nimi on <code>tunnus</code>.</p>

		<p>Luo Login-servletille <code>doPost</code>-metodi, jossa tallennetaan lähetetty tunnus sessioon. Tallenna tunnus vain jos sen pituus on väliltä [4,8] (eli vähintään 4 merkkiä, korkeintaan 8 merkkiä). Voit käyttää seuraavaa koodipätkää pohjana.</p>

<pre class="sh_java">
        String tunnus = request.getParameter("tunnus");
        
        if(tunnus != null && tunnus.length() > 3 && tunnus.length() < 9) {
            HttpSession session = request.getSession();
            // lisää sessioon attribuutti tunnus

            // ohjaa osoitteeseen request.getContextPath() + "/Chat"
            //   missä "/Chat" on Chat-servletin kuuntelema polku

            // lähetä tiedot vastaukseen ja palaa metodikutsusta
            response.flushBuffer();
            return;
        }
</pre>

		<h4>Käyttäjätunnuksen lisääminen kirjoitettavaan viestiin</h4>

		<p>Muuta Chat-servlettiä siten, että sessiossa oleva käyttäjätunnus tallennetaan jokaisen viestin yhteyteen.</p>

<pre class="sh_java">
String tunnus = "" + request.getSession().getAttribute("tunnus");
String viesti = tunnus + ": " + request.getParameter("viesti");
</pre>
		<p>Sovelluksen tulee nyt näyttää seuraavanlaiselta, esimerkissä nimimerkki "El Barto" on kirjoittanut viestin "Muerto o Vivo":</p>

<div class="naytto">
<strong>Chat</strong><br />
<form method="POST">
<input type="text" name="viesti" /><input type="submit" value="Lähetä" />
</form>
<strong>Viestit</strong><br />
El Barto: Muerto o Vivo<br/>
</div>


		<h4>Kirjautumisen validointi</h4>		

		<p>Lisää Chat-servletille metodi <code>onKirjautunut</code>, joka tarkistaa että käyttäjä on kirjautunut ja hänen tiedot ovat sessiossa.</p>

<pre class="sh_java">
private boolean onKirjautunut(HttpServletRequest request, HttpServletResponse response) 
            throws IOException {
    // jos sessiossa ei ole attribuuttia tunnus
    //   ohjaa käyttäjä osoitteeseen request.getContextPath() + "/Login"
    //   palauta tällöin arvo false
    // kaikki ok -- palauta true
}
</pre>

		<p>Kutsu metodia Chat-servletissä sekä <code>doGet</code>- että <code>doPost</code>-metodin alussa. Jos metodi palauttaa arvon <em>false</em>, eli käyttäjä ei ole kirjautunut, älä jatka doGet tai doPost -metodin suoritusta. Yhdelle pyynnölle saa siis antaa vain yhden vastauksen.</p>

		<p>Nyt käyttäjän tulee olla kirjautunut voidakseen chättäillä.</p>

		<h4>Uloskirjautuminen</h4>
		
		<p>Luo vielä erillinen Logout-servlet. Kun käyttäjä kutsuu tätä servlettiä kutsutaan <code>HttpSession</code>-olion <code>invalidate</code>-metodia ja kirjoitetaan käyttäjälle viesti "Kiitos!".</p>

		<p>Lisää Chat-servletin tulostukseen linkki Logout-servlettiin: </p>

<pre class="sh_java">
            out.println("&lt;a href=\"" + request.getContextPath() + "/Logout\"&gt;kirjaudu ulos&lt;/a&gt;");
</pre>

		<p>Sovelluksen tulee nyt näyttää seuraavanlaiselta, esimerkissä nimimerkki "El Barto" on kirjoittanut viestin "Muerto o Vivo":</p>

<div class="naytto">
<strong>Chat</strong><br />
<form method="POST">
<input type="text" name="viesti" /><input type="submit" value="Lähetä" />
</form>
<strong>Viestit</strong><br />
El Barto: Muerto o Vivo<br/>
<a href="/lets/Logout">kirjaudu ulos</a>
</div>

<h4>Sovelluksen siirtäminen users-koneelle</h4>

		<p>Siirretään sovellus users-koneelle. Tämä osio on lyhennelmä osoitteessa <a href="http://www.cs.helsinki.fi/u/avihavai/edutainment/2011/tsoha/ohje/" target="_blank">http://www.cs.helsinki.fi/u/avihavai/edutainment/2011/tsoha/ohje/</a> olevan oppaan seitsemännestä osasta.</p>

		<p>Kone <code>users.cs.helsinki.fi</code> on TKTL:n opiskelijoille tarkoitettu palvelin, jossa voi ajaa omia ohjelmistoja. Users-koneella on käytössä java web-sovelluksia pyörittävä tomcat-palvelin sekä useita tietokannanhallintajärjestelmiä: MySQL, Oracle ja PostgreSQL. Users-koneelle pääsee kirjautumaan komennolla.</p>

<pre>
ssh users.cs.helsinki.fi -l &lt;omatunnus&gt;
</pre>

		<p>Saamme käyttöömme tomcat-palvelimen komennolla <code>wanna-tomcat</code>. Laitoksella on käytössä tomcatin versio 6.</p>

<pre>
tunnus@users:~$ wanna-tomcat

This script will create a new tomcat environment for you in directory
/home/tunnus/tomcat. Please see http://users.cs.helsinki.fi/tomcat for more
information. Do you want to create a new tomcat installation
in /home/tunnus/tomcat (y/n)? &lt;syötä y&gt;

....

Tomcat environment has been setup for you. Now you can run 'start-tomcat'.
tunnus@users:~$
</pre>

		<p>Käynnistetään palvelin komennolla <code>start-tomcat</code>.</p>
<pre>
tunnus@users:~$ start-tomcat
Using CATALINA_BASE:   /home/tunnus/tomcat
Using CATALINA_HOME:   /usr/share/tomcat6
Using CATALINA_TMPDIR: /home/tunnus/tomcat/temp
Using JRE_HOME:        /usr/lib/jvm/java-6-sun
Using CLASSPATH:       /usr/share/tomcat6/bin/bootstrap.jar
Tomcat has been started. It should be visible through URL
http://t-tunnus.users.cs.helsinki.fi/

If you have problems, your tomcat log files are
available from /home/tunnus/tomcat/logs

Please, remember to stop (with stop-tomcat) tomcat instances with are
not used.
tunnus@users:~$ 
</pre>

		<p>Kun menet web-selaimella osoitteeseen http://t-&lt;tunnus&gt;.users.cs.helsinki.fi/, näet sivun jossa on otsikkona viesti "It works!".</p>

		<p>Tomcat-palvelimen saa suljettua komennolla <code>stop-tomcat</code>.</p>

		<p><strong>Siirretään seuraavaksi sovellus users-koneelle.</strong> Valitse NetBeansista chat-projektisi oikealla hiirennapilla, ja valitse <code>Clean and Build</code>.  Tämä luo projektista <code>war</code>-tiedoston (web application archive) projektin dist-kansioon.</p>

		<p>Kopioidaan paketti users-koneelle.</p>
<pre>
tunnus@kone:~$ scp ~/NetBeansProjects/&lt;projektinnimi&gt;/dist/&lt;projektinnimi&gt;.war users.cs.helsinki.fi:
</pre>
		<p>Mennään koneelle <code>users.cs.helsinki.fi</code>, ja siirretään pakkaus tomcat-kansiossa olevaan webapps-kansioon.</p>
<pre>
tunnus@kone:~$ ssh users.cs.helsinki.fi
tunnus@users:~$ mv &lt;projektinnimi&gt;.war tomcat/webapps/
tunnus@users:~$
</pre>

		<p>Jos tomcat on päällä, pyrkii se käynnistämään sovelluksen automaattisesti.  Näet tomcatin logeista <code>tomcat/logs/catalina.out</code> ohjelman logiin kirjoittamat viestit. Jos tomcat ei ole päällä, käynnistä se, ja selaa osoitteeseen <code>http://t-tunnus.users.cs.helsinki.fi/&lt;projektinnimi&gt;/Chat</code>.</p> 

		<p>Ohjelman pitäisi uudelleenohjata sinut sivulle <code>http://t-tunnus.users.cs.helsinki.fi/&lt;projektinnimi&gt;/Login</code> ja pyytää sinua kirjautumaan.</p>

		<p>Onneksi olkoon! Olet tehnyt pienen Chat-sovelluksen!</p>
</div>

		
		<h2 id="web_sovelluksen_rakenne">Web-sovelluksen rakenne</h2>

		<h3 id="kerrostettu_arkkitehtuuri">Kerrosarkkitehtuuri</h3>

		<p>Kerrosarkkitehtuuri jakaa web-sovelluksen kolmeen kerrokseen; tiedon tallentamiseen ja hakemiseen liittyvään logiikkaan, sovelluksen palveluihin liittyvään logiikkaan, ja käyttöliittymästä tehtyjä pyyntöjä ohjaavaan kerrokseen. Näiden päällä ja näistä erillisenä toimii käyttöliittymäkerros.</p>

		<p>Tiedon hakemiseen ja tallentamiseen liittyvä logiikka ratkaistaan lähes aina valmiita komponentteja käyttäen. Alimman kerroksen toiminnallisuus -- relaatiotietokannat, key/value -tietokannat, dokumenttitietokannat, jne.. -- ovat web-sovelluskehittäjän näkökulmasta "done", eli omaa ei kannata lähteä toteuttamaan.</p>

		<p>Sovelluksen oleellisin osa on palveluissa, eli keskitasossa. <em>Sovelluslogiikka sisältää toiminnallisuuden, joka tekee sovelluksestamme arvokkaan.</em> Sovelluslogiikka käyttää alempana olevan tietovarastokerroksen tarjoamia palveluita.</p>

		<p>Sovelluslogiikkakerroksen päällä on käyttöliittymäkutsuja ohjaava kerros, "kontrollikerros". Käyttöliittymäkutsuja ohjaavan kerroksen tehtävänä on toimia rajapintana sovelluskerroksen ja käyttöliittymän välillä. Se vastaanottaa käyttäjän tekemiä pyyntöjä ja ohjaa niitä eteenpäin tarpeellisille palveluille. Kontrollikerroksen tulee olla mahdollisimman ohut; siinä käytetään sovelluskerroksen tarjoamaa toiminnallisuutta. Kutsun suorittamisen jälkeen kotrollikerros palauttaa dataa <em>jossain muodossa</em>. Javascript-kutsulla voi pyytää XML- tai JSON-muodossa olevaa dataa, jonka näyttäminen tapahtuu selainpuolella. Toisaalta, palautettu data voidaan ohjata erilliselle käyttöliittymän renderöintipalvelulle, joka luo näytettävän HTML-sivun.</p>

		<p>Kerrosarkkitehtuurista erillisenä -- kontrollikerroksen päällä -- on käyttöliittymä. Käyttöliittymiä voi olla useita erilaisia. Kaikille yhteistä on se, että ne tekevät pyyntöjä web-sovelluksen tarjoamiin osoitteisiin.<p>

		<h3>Käyttöliittymä</h3>

		<p>Dynaamiset web-sivut tarvitsevat hieman logiikkaa sivujen näyttämiseen. Esimerkiksi listamuotoisen datan tulostaminen HTML-sivuksi -- kun listan koko vaihtelee pyynnöstä toiseen -- vaatii toistorakenteen. Perinteisissä web-sivuissa käyttöliittymä koostuu näkymää muokkaavasta koodista (esim. CSS) ja datan sisältävästä koodista (esim. HTML), jotka eivät itsessään sisällä logiikkaa. Yksi nykyaikaisten (web-)sovellusten nyrkkisääntö on <em>pidä käyttöliittymälogiikka ja sovelluslogiikka erillään</em>.</p>

		<p>Käyttöliittymien luomiseen web-sovelluksia varten on luotu useita erilaisia lähestymistapoja. Loppupeleissä kaikki näytetään käyttäjälle HTML:nä -- riippumatta siitä miten sovelluskehittäjä luo käyttöliittymän. Tutustutaan seuraavaksi JSP-sivujen luomiseen (<em>Java Server Pages</em>).<p>

		<h4>JSP</h4>

		<p>JSP-sivut ovat käytännössä HTML-sivuja, joissa on mahdollista suorittaa myös Java-koodia (Java-koodin sisällyttäminen JSP-sivuille on huonoa ohjelmointityyliä -- eli emme käytä tätä mahdollisuutta). JSP-sivutiedostot loppuvat yleensä päätteeseen <em>jsp</em>.</p>

		<p>JSP-sivuja säilytetään erillään Java-koodista. NetBeansin hakemistorakenteessa JSP-sivut ovat <code>web</code>-kansion alla. Projektinäkymässä ne näkyvät kansiossa <em>Web Pages</em>.</p> 

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;JSP Page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>		

		<p>JSP-sivut muutetaan niitä kutsuttaessa servleteiksi, joiden tuottama sisältö näytetään käyttäjälle. Servlettien ja JSP-sivujen yhteistyö tapahtuu perinteisessä Servlet-maailmassa <code>HttpServletRequest</code>-luokalta saatavan <code>RequestDispatcher</code>-olion avulla. RequestDispatcher-oliota käytetään pyynnön eteenpäin ohjaamiseen.</p>

		<p>Seuraava esimerkki ohjaa pyynnön <code>index.jsp</code>-nimiselle JSP-sivulle, joka löytyy <code>web</code>-kansiosta.</p>

<pre class="sh_java">
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        
        RequestDispatcher dispatcher = request.getRequestDispatcher("index.jsp");
        dispatcher.forward(request, response);
    }
</pre>
		<p>JSP-sivujen ollessa <code>web</code>-kansiossa käyttäjä pääsee niihin käsiksi suoraan selaamalla osoitteeseen <code>http://osoite/sovellus/sivu.jsp</code>. Jos haluamme pitää JSP-sivut käyttäjältä näkymättömissä, tulee niiden olla <code>web</code>-kansiossa sijaitsevassa <code>WEB-INF</code> -kansiossa (tai sen sisältämässä kansiossa). RequestDispatcher-olion osoittaminen <code>WEB-INF</code>-kansiossa sijaitsevaan JSP-sivuun tapahtuu helposti.</p>

<pre class="sh_java">
        RequestDispatcher dispatcher = request.getRequestDispatcher("WEB-INF/index.jsp");
</pre>

		<p><strong>Datan näyttäminen sivulla</strong></p>

		<p>JSP mahdollistaa pyyntöön lisättyjen attribuuttien näyttämisen sivulla EL-kieltä (<em>Expression Language</em>) käyttäen. EL-kutsut alkavat dollarimerkillä ja avaavalla aaltosulkeella (<code>${</code>), ja päättyvät sulkevaan aaltosulkuun (<code>}</code>). Viittaus attribuuttiin nimeltä <code>porkkana</code> tapahtuisi komennolla <code>${porkkana}</code>. Attribuutteja voi lisätä pyyntöön <code>HttpServletRequest</code>-olion <code>setAttribute</code>-metodilla. Esimerkiksi <code>viesti</code>-nimisen attribuutin lisääminen pyyntöön tapahtuu seuraavasti.</p>

<pre class="sh_java">
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        request.setAttribute("viesti", "kolaa kuluu!");
        
        RequestDispatcher dispatcher = request.getRequestDispatcher("index.jsp");
        dispatcher.forward(request, response);
    }
</pre>
		<p>EL-kutsu, jolla voisimme tulostaa attribuutin <code>viesti</code> sisällön on seuraavanlainen.</p>

<pre class="sh_xml">
  &lt;p&gt;html:ää ja muuta kivaa -- sekä ${viesti}.&lt;/p&gt;
</pre>

		<p>Ylläolevan -- standardeja heikosti noudattavan -- JSP-sivun tulostama sisältö olisi kutsun jälkeen seuraavanlainen (olettaen että pyyntö JSP-sivulle tulee edeltävästä <code>doGet</code>-metodista).</p>

<pre class="sh_xml">
  &lt;p&gt;html:ää ja muuta kivaa -- sekä kolaa kuluu!.&lt;/p&gt;
</pre>

		<p>EL mahdollistaa myös olioiden get-tyyppisiin metodeihin tehtävät metodikutsut. Tekemällä kutsun ${alkio.tyyppi} kutsuisimme alkio-nimisen attribuutin viittaamaan olioon liittyvää <code>getTyyppi</code>-metodia. Katsotaan seuraavaa <code>Kasvis</code>-luokkaa.</p>

<pre class="sh_java">
public class Kasvis {
    private String tyyppi;

    public Kasvis(String tyyppi) {
        this.tyyppi = tyyppi;
    }

    public String getTyyppi() {
        return tyyppi;
    }
}
</pre>

<pre class="sh_java">
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        Kasvis porkkana = new Kasvis("porkkana");

        request.setAttribute("kasvis", porkkana);
        
        RequestDispatcher dispatcher = request.getRequestDispatcher("index.jsp");
        dispatcher.forward(request, response);
    }
</pre>

		<p>Attribuuttina <code>kasvis</code> olevaa <code>Kasvis</code>-luokan ilmentymää käyttäen voisimme tehdä JSP-koodissa kutsun <code>${kasvis.tyyppi}</code>, joka vuorostaan kutsuisi metodia <code>getTyyppi</code> kasvis-attribuutin viittaamalle oliolle -- riippumatta olion tyypistä.</p>

<pre class="sh_xml">
  &lt;p&gt;Ja tänään jälkiruokakasviksena on ${kasvis.tyyppi}.&lt;/p&gt;
</pre>

<pre class="sh_xml">
  &lt;p&gt;Ja tänään jälkiruokakasviksena on porkkana.&lt;/p&gt;
</pre>


		<p><strong>Tägikirjastot</strong></p>

		<p>EL ei tarjoa toistolausekkeita. JSP:tä varten on kehitetty joukko erillisiä kirjastorutiineja dynaamisten toiminnallisuuksien toteuttamiseen. JSTL (<em>JavaServer Pages Standard Tag Library</em>) on tägikirjasto, jota voi käyttää esimerkiksi toistolauseiden sisällyttämiseen JSP-sivuille. JSTL:n ydintoiminnallisuudet saa JSP-sivun käyttöön lisäämällä JSP-sivun alkuun seuraavan rivin.</p>

<pre class="sh_java">
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
</pre>

		<p>Oleellisin toiminto meille on <code>forEach</code>-lause, jota käytetään kokoelmaolioiden (<code>Collection</code>-rajapinnan toteuttavien olioiden) kanssa seuraavasti.</p>

<pre class="sh_java">
&lt;pre&gt;
  &lt;c:forEach var="alkio" items="${joukko}"&gt;
    ${alkio}
  &lt;/c:forEach&gt;
&lt;/pre&gt;
</pre>

		<p>Yllä viittaamme attribuuttiin nimeltä <code>joukko</code>. Oletetaan että <code>joukko</code> lisätty pyynnön attribuutiksi seuraavasti.</p>

<pre class="sh_java">
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");

        List&lt;String&gt; lista = Arrays.asList("joukossa", "tyhmyys", "tiivistyy");
        request.setAttribute("joukko", lista);
        
        RequestDispatcher dispatcher = request.getRequestDispatcher("index.jsp");
        dispatcher.forward(request, response);
    }
</pre>

		<p>Toistolausekkeen tulostus olisi seuraava.</p>

<pre class="sh_java">
&lt;pre&gt;
    joukossa
        
    tyhmyys
        
    tiivistyy

&lt;/pre&gt;
</pre>

		<p>Lisää JSTL-kirjastosta löytyy mm. osoitteesta <a href="http://www.jsptutorial.net/jsp-standard-tag-library-jstl.aspx" target="_blank">http://www.jsptutorial.net/jsp-standard-tag-library-jstl.aspx</a>.</p>


		<p><strong>Huom!</strong> Jos -- ja kun -- törmäät virheeseen <code>org.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application</code>, lisää JSTL 1.1-kirjasto projektiin valitsemalla "Project Properties" -> Libraries -> Add Library, joka avaa listan josta kirjasto JSTL 1.1 löytyy.</p>
	
	<div><img src="opas/eka-servlet/img/add-library.png" /></div>
	
	<div><img src="opas/eka-servlet/img/jstl-added.png" /></div>


	

		<h3>Olemassaolevien sovellusten nykyaikaistaminen</h3>

		<p>Huomattava osa olemassaolevista web-sovelluksista on luotu jo pidemmän aikaa sitten. Näiden ohjelmistojen kohdalla on kolme vaihtoehtoa. 
		  <ol>
		    <li>päivitetään olemassaolevaa versiota tarpeen vaatiessa</li>
		    <li>luodaan uusi ohjelmisto</li>
		    <li>lähdetään hiljalleen nykyaikaistamaan ohjelmistoa</li>
		  </ol> Vaihtoehdon valinta riippuu käytettävissä olevasta ajasta (ja rahasta).</p>

		<p>Olemassaolevan version päivitys tarpeen vaatiessa on hyvä vaihtoehto kun sovelluksella on jo paljon käyttäjiä ja uudelleenkirjoitus veisi enemmän aikaa (ja rahaa) kuin on käytettävissä.</p>

		<p>Uuden ohjelmiston luonnissa tulee varmistaa että mukana on myös vanhan ohjelmiston luonnissa olleita ihmisiä -- jokaisen ohjelmiston kehityksessä on tullut vastaan tapahtumia jotka ovat ohjanneet kehitysprosessia.</p> 

		<p>Kolmas vaihtoehto on ohjelmiston muokkaaminen nykyaikaisemmaksi. Wanhat sovellukset ovat usein isoja kokonaisuuksia. Eräs muutosprosessi on seuraavanlainen.
		  <ol>
		    <li>erota sovelluslogiikka käyttöliittymäkoodista</li>
		    <li>erota yksittäiset sivut omiksi komponenteikseen</li>
		    <li>siirrä käyttöliittymäkoodi erillisiin sivuihin, jotka käyttävät jotain templatejärjestelmää</li>
		  </ol>
		</p>

		<p>Seuraava esimerkki selventää ylläolevaa muutosprosessia.</p>

		<h4>Esimerkki: Kassakirjanpidon siistiminen</h4>

		<p>Esimerkissä muokataan kassakirjanpitoon suunnattua Servlet-ohjelmaa, johon käyttäjä voi syöttää kassatapahtumia.</p>

<pre class="sh_java">
// importit

public class Kirjanpito extends HttpServlet {

    private String tiedostonNimi = "data.csv";
    private String erotin = ";";

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        
        
        if (request.getParameter("tapahtuma") != null
                && request.getParameter("kustannus") != null) {
            FileWriter fw = new FileWriter(tiedostonNimi, true);
            fw.write(new SimpleDateFormat("dd.MM.yyyy").format(new Date()) + erotin);
            fw.write(request.getParameter("tapahtuma") + erotin);
            fw.write(request.getParameter("kustannus") + "\n");
            
            fw.flush();
            fw.close();
        }

        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {

            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;Kirjanpito&lt;/title&gt;");
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");

            out.println("&lt;strong&gt;Kirjanpito&lt;/strong&gt;&lt;br /&gt;");
            out.println("&lt;form&gt;");
            out.println("Tapahtuma: &lt;input type=\"text\" name=\"tapahtuma\" /&gt;&lt;br /&gt;");
            out.println("Kustannus: &lt;input type=\"text\" name=\"kustannus\" /&gt;&lt;br /&gt;");
            out.println("&lt;input type=\"submit\" value=\"Lisää\" /&gt;");
            out.println("&lt;/form&gt;");

            out.println("&lt;table&gt;");
            out.println("&lt;tr&gt;&lt;th&gt;PVM&lt;/th&gt;&lt;th&gt;Tapahtuma&lt;/th&gt;&lt;th&gt;Kustannus&lt;/th&gt;&lt;/tr&gt;");
            
            Scanner lukija = new Scanner(new FileReader(tiedostonNimi));
            while(lukija.hasNextLine()) {
                String rivi = lukija.nextLine();
                String[] data = rivi.split(erotin);
                out.println("&lt;tr&gt;&lt;td&gt;" + data[0] + 
                        "&lt;/td&gt;&lt;td&gt;" + data[1] + 
                        "&lt;/td&gt;&lt;td&gt;" + data[2] + "&lt;/td&gt;&lt;td&gt;&lt;/tr&gt;");
            }

            out.println("&lt;/table&gt;");

            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
        } finally {
            out.close();
        }
    }
}
</pre>

		<p>Ohjelmaa muokatessa ylläpitoystävällisemmäksi ensimmäinen askel on <em>käyttöliittymälogiikan ja sovelluslogiikan erottaminen toisistaan</em>. Luodaan luokka <code>Tapahtumanhallinta</code>, jonka tehtävänä on hoitaa tapahtumien lukeminen ja tallentaminen. Kopioimme toiminnallisuuden suoraan ylläolevasta luokasta. Toteutuksessamme kaikki toiminnallisuus on luokkakohtaista (eli static). Näemme myöhemmin kurssilla huomattavasti järkevämpiä ratkaisuja.</p>

<pre class="sh_java">
public class Tapahtumanhallinta {

    private static String tiedostonNimi = "data.csv";
    private static String erotin = ";";

    public static void lisaaTapahtuma(String tapahtuma, String kustannus)
            throws IOException {
        FileWriter fw = new FileWriter(tiedostonNimi, true);
        fw.write(new SimpleDateFormat("dd.MM.yyyy").format(new Date()) + erotin);
        fw.write(tapahtuma + erotin);
        fw.write(kustannus + "\n");

        fw.flush();
        fw.close();
    }

    public static List&lt;String&gt; lueTiedostonRivit() throws FileNotFoundException {
        List&lt;String&gt; rivit = new ArrayList();
        Scanner lukija = new Scanner(new FileReader(tiedostonNimi));
        while (lukija.hasNextLine()) {
            rivit.add(lukija.nextLine());
        }
        
        return rivit;
    }
}
</pre>

		<p>Muokataan <code>Kirjanpito</code>-servletin <code>doGet</code>-metodia siten, että se käyttää <code>Tapahtumanhalllinta</code>-luokan tarjoamia palveluita.</p>

<pre class="sh_java">

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        if (request.getParameter("tapahtuma") != null
                && request.getParameter("kustannus") != null) {
            Tapahtumanhallinta.lisaaTapahtuma(request.getParameter("tapahtuma"),
                                              request.getParameter("kustannus"));
        }
        

        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {

            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;Kirjanpito&lt;/title&gt;");
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");

            out.println("&lt;strong&gt;Kirjanpito&lt;/strong&gt;&lt;br /&gt;");
            out.println("&lt;form method=\"POST\"&gt;");
            out.println("Tapahtuma: &lt;input type=\"text\" name=\"tapahtuma\" /&gt;&lt;br /&gt;");
            out.println("Kustannus: &lt;input type=\"text\" name=\"kustannus\" /&gt;&lt;br /&gt;");
            out.println("&lt;input type=\"submit\" value=\"Lisää\" /&gt;");
            out.println("&lt;/form&gt;");

            out.println("&lt;table&gt;");
            out.println("&lt;tr&gt;&lt;th&gt;PVM&lt;/th&gt;&lt;th&gt;Tapahtuma&lt;/th&gt;&lt;th&gt;Kustannus&lt;/th&gt;&lt;/tr&gt;");

            for(String rivi: Tapahtumanhallinta.lueTiedostonRivit() {
                String[] tapahtuma = rivi.split(";");
                out.println("&lt;tr&gt;&lt;td&gt;" + tapahtuma[0]
                        + "&lt;/td&gt;&lt;td&gt;" + tapahtuma[1]
                        + "&lt;/td&gt;&lt;td&gt;" + tapahtuma[2] + "&lt;/td&gt;&lt;td&gt;&lt;/tr&gt;");
            }

            out.println("&lt;/table&gt;");

            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
        } finally {
            out.close();
        }
    }
</pre>

		<p>GET-metodikutsujen tulee olla turvallisia, eli niiden ei tule tarjota mahdollisuutta sivujen sisällön muokkaamiseen. Muokataan <code>Kirjanpito</code>-luokkaa siten, että lomakkeen tyyppi on POST. Lisäämme samalla <code>doPost</code>-metodin, joka käsittelee POST-tyyppiset kutsut ja ohjaa käyttäjän lopuksi takaisin normaalille sivulle.</p>

		<p>Servlettimme <code>Kirjanpito</code> näyttää nyt kokonaisuudessaan seuraavalta.</p>

<pre class="sh_java">
// importit ym

public class Kirjanpito extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        try {

            out.println("&lt;html&gt;");
            out.println("&lt;head&gt;");
            out.println("&lt;title&gt;Kirjanpito&lt;/title&gt;");
            out.println("&lt;/head&gt;");
            out.println("&lt;body&gt;");

            out.println("&lt;strong&gt;Kirjanpito&lt;/strong&gt;&lt;br /&gt;");
            out.println("&lt;form method=\"POST\"&gt;");
            out.println("Tapahtuma: &lt;input type=\"text\" name=\"tapahtuma\" /&gt;&lt;br /&gt;");
            out.println("Kustannus: &lt;input type=\"text\" name=\"kustannus\" /&gt;&lt;br /&gt;");
            out.println("&lt;input type=\"submit\" value=\"Lisää\" /&gt;");
            out.println("&lt;/form&gt;");

            out.println("&lt;table&gt;");
            out.println("&lt;tr&gt;&lt;th&gt;PVM&lt;/th&gt;&lt;th&gt;Tapahtuma&lt;/th&gt;&lt;th&gt;Kustannus&lt;/th&gt;&lt;/tr&gt;");

            for (String[] tapahtuma : Tapahtumanhallinta.annaTapahtumat()) {
                out.println("&lt;tr&gt;&lt;td&gt;" + tapahtuma[0]
                        + "&lt;/td&gt;&lt;td&gt;" + tapahtuma[1]
                        + "&lt;/td&gt;&lt;td&gt;" + tapahtuma[2] + "&lt;/td&gt;&lt;td&gt;&lt;/tr&gt;");
            }

            out.println("&lt;/table&gt;");

            out.println("&lt;/body&gt;");
            out.println("&lt;/html&gt;");
        } finally {
            out.close();
        }
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        
        if (request.getParameter("tapahtuma") != null
                && request.getParameter("kustannus") != null) {
            Tapahtumanhallinta.lisaaTapahtuma(
                    request.getParameter("tapahtuma"),
                    request.getParameter("kustannus"));
        }
        
        // POST-kutsun jälkeen takaisin listaukseen
        response.setStatus(302);
        // Kirjanpito-servlet kuuntelee osoitetta /Kirjanpito
        response.setHeader("Location", request.getContextPath() + "/Kirjanpito");
        response.flushBuffer();
    }
}
</pre>

		<p>Tiedämme ohjelmistojen mallintamisesta ja ohjelmointikursseilta että <em>luokalla tulee olla selkeä vastuu</em>. Tapahtuman kuvaaminen merkkijonona ole järkevää. Luodaan luokka <code>Kirjanpitotapahtuma</code>, joka kuvaa yksittäistä kirjanpitotapahtumaa. Kirjanpitotapahtumaan liittyy päivämäärä, tapahtuman kuvaus ja kustannus. Esimerkissä kustannus on merkkijonona, mutta oikeasti sen voisi ilmaista kokonaislukuna (sentteinä) -- jolloin tarvitsisimme myös erillisen kentän valuutalle.</p>

<pre class="sh_java">
import java.util.Date;

public class Kirjanpitotapahtuma {
    private Date paivamaara;
    private String kuvaus;
    private String kustannus;
   
    public Kirjanpitotapahtuma(String kuvaus, String kustannus) {
        this(new Date(), kuvaus, kustannus);
    }

    public Kirjanpitotapahtuma(Date paivamaara, String kuvaus, String kustannus) {
        this.paivamaara = paivamaara;
        this.kuvaus = kuvaus;
        this.kustannus = kustannus;
    }

    public Date getPaivamaara() {
        return paivamaara;
    }
    
    public String getKuvaus() {
        return kuvaus;
    }

    public String getKustannus() {
        return kustannus;
    }
}
</pre>
		<p>Kun luot luokkaa <code>Kirjanpitotapahtuma</code> muista että kaikki nykyaikaiset editorit osaavat täydentää lähdekoodiin konstruktorit, getterit ja setterit olemassaolevien attribuuttien perusteella. Sinun tarvitsee kirjoittaa vain attribuutit ja valita editorin täydennystoiminnallisuus. NetBeansista se löytyy valitsemalla "Source" ja "Insert Code".</p>

		<p>Luokan <code>Kirjanpitotapahtuma</code> luomisen jälkeen luokkaa <code>Tapahtumanhallinta</code> muutetaan siten, että se käsittelee kirjanpitotapahtumaolioita. Jatkossa päivämäärät tallennetaan millisekuntiesityksenä. Jätämme väliin aiemmin tallennetun datan muuntamisen nykyaikaiseen muotoon, eli konversion, tämä tulisi toki myös tehdä.</p>

<pre class="sh_java">
// importit jne

public class Tapahtumanhallinta {

    private static String tiedostonNimi = "data.csv";
    private static String erotin = ";";

    public static void lisaaTapahtuma(Kirjanpitotapahtuma tapahtuma)
            throws IOException {
        FileWriter fw = new FileWriter(tiedostonNimi, true);
        
        Date pvm = tapahtuma.getPaivamaara();
        fw.write(pvm.getTime() + erotin);
        fw.write(tapahtuma.getKuvaus() + erotin);
        fw.write(tapahtuma.getKustannus() + "\n");
        
        fw.flush();
        fw.close();
    }

    public static List&lt;Kirjanpitotapahtuma&gt; annaTapahtumat() throws FileNotFoundException {
        List&lt;Kirjanpitotapahtuma&gt; tapahtumat = new ArrayList();
        Scanner lukija = new Scanner(new FileReader(tiedostonNimi));
        while (lukija.hasNextLine()) {
            String rivi = lukija.nextLine();
            String[] data = rivi.split(erotin);
            
            try {
                Date pvm = new Date(Long.parseLong(data[0]));
                tapahtumat.add(new Kirjanpitotapahtuma(pvm, data[1], data[2]));
            } catch (ArrayIndexOutOfBoundsException e) {
                System.err.println("Epäkelpo rivi: " + rivi);
            } catch (NumberFormatException e) {
                System.err.println("Epäkelpo rivi: " + rivi);
            }
        }

        return tapahtumat;
    }
}
</pre>

		<p>Kirjanpito-servletin doGet-metodia muutetaan ottamaan tapahtumat huomioon. Käytämme Javan <a href="http://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html" target="_blank">SimpleDateFormat</a>-luokkaa Date-olioiden merkkijonoesitykseksi muutamiseen.</p>
<pre class="sh_java">
            // ...
            out.println("&lt;table&gt;");
            out.println("&lt;tr&gt;&lt;th&gt;PVM&lt;/th&gt;&lt;th&gt;Tapahtuma&lt;/th&gt;&lt;th&gt;Kustannus&lt;/th&gt;&lt;/tr&gt;");
            SimpleDateFormat muuntaja = new SimpleDateFormat("dd.MM.yyyy");

            for (Kirjanpitotapahtuma tapahtuma : Tapahtumanhallinta.annaTapahtumat()) {
                out.println("&lt;tr&gt;&lt;td&gt;" + muuntaja.format(tapahtuma.getPaivamaara())
                        + "&lt;/td&gt;&lt;td&gt;" + tapahtuma.getKuvaus()
                        + "&lt;/td&gt;&lt;td&gt;" + tapahtuma.getKustannus() + "&lt;/td&gt;&lt;td&gt;&lt;/tr&gt;");
            }
            // ...
</pre>

		<p>Sovelluslogiikka ja käyttöliittymälogiikka on erotettu toisistaan. Seuraavana tehtävänä on <em>yksittäisten sivujen erottaminen omiksi komponenteikseen</em>. Tällä tarkoitetaan esimerkiksi montaa eri sivua tulostavan Servletin pilkkomista useampaan Servlet-luokkaan. Kirjanpitojärjestelmässä on vain yksi sivu, joten meidän ei tarvitse tehdä pitään.</p>

		<p>Kolmantena askeleena on <em>käyttöliittymäkoodin siirtäminen erillisiin sivuihin, jotka käyttävät templatejärjestelmää</em>. Siirrämme jokaisen Servlet-luokan sisältämän käyttöliittymäkoodin (HTML:n) erilliseen JSP-sivuun. Luodaan Kirjanpito-servletin käyttöliittymäkoodin sisältävä sivu, <code>kirjanpito.jsp</code>. Aluksi kopioimme sivulle sovelluksemme HTML-rungon ja lisäämme JSP-otsakkeen joka kertoo sivun käyttämästä merkistöstä.</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Kirjanpito&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;strong&gt;Kirjanpito&lt;/strong&gt;&lt;br /&gt;

    &lt;form method="POST"&gt;
      Tapahtuma: &lt;input type="text" name="tapahtuma" /&gt;&lt;br /&gt;
      Kustannus: &lt;input type="text" name="kustannus" /&gt;&lt;br /&gt;
      &lt;input type="submit" value="Lisää" /&gt;
    &lt;/form&gt;

    &lt;table&gt;
      &lt;tr&gt;&lt;th&gt;PVM&lt;/th&gt;&lt;th&gt;Tapahtuma&lt;/th&gt;&lt;th&gt;Kustannus&lt;/th&gt;&lt;/tr&gt;
    &lt;/table&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>

		<p>JSP-sivu asetetaan NetBeansissa projektikansioon "Web Pages" tai fyysiseen kansioon "web".</p>
		
		<p>Voimme ohjata Servletille saapuneen pyynnön toiselle Servletille (tai JSP-sivulle) käyttämällä Servlet-API:n <code>RequestDispatcher</code>-oliota. <code>RequestDispatcher</code>-olioon pääsee käsiksi <code>HttpServletRequest</code>-olion <code>getRequestDispatcher</code>-metodin avulla. Muutamme <code>Kirjanpito</code>-servletin doGet-metodin seuraavanlaiseksi.</p>

<pre class="sh_java">
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        RequestDispatcher dispatcher = request.getRequestDispatcher("kirjanpito.jsp");
        dispatcher.forward(request, response);
    }
</pre>

		<p>Yllä käyttöliittymään liittyvä koodi on siirretty pois Kirjanpito-servletistä. Kutsussa <code>request.getRequestDispatcher("kirjanpito.jsp")</code> annettu tiedosto <code>kirjanpito.jsp</code> löytyy ohjelmamme web-kansiosta. Kun avaamme sovelluksen selaimessa, näemme JSP-sivun tuottaman sivun.</p>

		<p>Sivulta puuttuu tapahtumien listaus. Lisäämällä <code>Tapahtumanhallinta</code>-luokan tarjoamat kirjanpitotapahtumat attribuutiksi pyyntöön, pääsee niihin käsiksi myös muilla samaa pyyntöä käsittelevillä JSP-sivuilla ja Servleteillä. Pyyntöön voi lisätä attribuutteja <code>HttpServletRequest</code>-luokan <code>setAttribute</code>-metodin avulla. Muutamme <code>Kirjanpito</code>-servletin <code>doGet</code>-metodia seuraavanlaiseksi.</p>

<pre class="sh_java">
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        
        request.setAttribute("tapahtumat", Tapahtumanhallinta.annaTapahtumat());
        
        RequestDispatcher dispatcher = request.getRequestDispatcher("kirjanpito.jsp");
        dispatcher.forward(request, response);
    }
</pre>

		<p>Pyyntöön lisätään <code>tapahtumat</code>-niminen attribuutti, joka viittaa kokoelmaan <code>Kirjanpitotapahtuma</code>-tyyppisiä olioita.</p>

		<p>JSP:hen liittyy joukko apukirjastoja, joilla voi toteuttaa yksinkertaisia tulostustoiminnallisuuksia JSP-sivuille. JSTL (<em>JavaServer Pages Standard Tag Library</em>) on näistä yleisin. JSTL tarjoaa muunmuassa toiminnon <code>forEach</code>, jonka avulla voidaan iteroida läpi kokoelman sisältämät elementit.</p>

		<p>Pyynnön attribuuttina olevan kokoelman "tapahtumat" läpikäynti käy seuraavasti.</p>

<pre class="sh_xml">
&lt;c:forEach var="tapahtuma" items="${tapahtumat}"&gt;
    ${tapahtuma.kuvaus}
&lt;/c:forEach&gt;
</pre>

		<p>Ylläolevalla esimerkillä tulostaisimme jokaiseen tapahtumat-kokoelmasta saatavaan olioon liittyvän metodin <em>getKuvaus</em> palauttaman arvon. Kutsu <code>${tapahtuma.kuvaus}</code> kutsuu siis käsiteltävän olion metodia <code>getKuvaus</code>. Jos vastaavaa metodia ei ole olemassa, näemme poikkeuksen.</p>

		<p>Lisätään tapahtumaan liittyvien tietojen tulostus JSP-sivulle, huomaa myös lisätty <code>taglib</code>-otsake.</p>

<pre class="sh_xml">
&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Kirjanpito&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;strong&gt;Kirjanpito&lt;/strong&gt;&lt;br /&gt;

    &lt;form method="POST"&gt;
      Tapahtuma: &lt;input type="text" name="tapahtuma" /&gt;&lt;br /&gt;
      Kustannus: &lt;input type="text" name="kustannus" /&gt;&lt;br /&gt;
      &lt;input type="submit" value="Lisää" /&gt;
    &lt;/form&gt;

    &lt;table&gt;
      &lt;tr&gt;&lt;th&gt;PVM&lt;/th&gt;&lt;th&gt;Tapahtuma&lt;/th&gt;&lt;th&gt;Kustannus&lt;/th&gt;&lt;/tr&gt;
      &lt;c:forEach var="tapahtuma" items="${tapahtumat}"&gt;
          &lt;tr&gt;&lt;td&gt;${tapahtuma.paivamaara}&lt;/td&gt;&lt;td&gt;${tapahtuma.kuvaus}&lt;/td&gt;&lt;td&gt;${tapahtuma.kustannus}&lt;/td&gt;&lt;/tr&gt;
      &lt;/c:forEach&gt;
    &lt;/table&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>

		<p>Ohjelmamme toimii lähes oikein, mutta päivämäärien tulostus ei ole halutunlainen. Päivämäärät tulostetaan <code>Date</code>-luokan <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Date.html#toString%28%29" target="_blank">oletustulostusmuodossa</a>. Onneksi JSTL:ssä on olemassa format-kirjasto joka tarjoaa juuri tätä tapausta varten tarkoitetun <code>formatDate</code>-toiminnon.</p>

<pre class="sh_java">
&lt;%@taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
// ...
          &ltfmt:formatDate pattern="dd.MM.yyyy" value="${tapahtuma.paivamaara}" /&gt;
// ...
</pre>

		<p>JSP-sivumme näyttää kokonaisuudessaan nyt seuraavalta.</p>

<pre class="sh_xml">
&lt;%@taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;
&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Kirjanpito&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;strong&gt;Kirjanpito&lt;/strong&gt;&lt;br /&gt;

    &lt;form method="POST"&gt;
      Tapahtuma: &lt;input type="text" name="tapahtuma" /&gt;&lt;br /&gt;
      Kustannus: &lt;input type="text" name="kustannus" /&gt;&lt;br /&gt;
      &lt;input type="submit" value="Lisää" /&gt;
    &lt;/form&gt;

    &lt;table&gt;
      &lt;tr&gt;&lt;th&gt;PVM&lt;/th&gt;&lt;th&gt;Tapahtuma&lt;/th&gt;&lt;th&gt;Kustannus&lt;/th&gt;&lt;/tr&gt;
      &lt;c:forEach var="tapahtuma" items="${tapahtumat}"&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;fmt:formatDate pattern="dd.MM.yyyy" value="${tapahtuma.paivamaara}" /&gt;&lt;/td&gt;
            &lt;td&gt;${tapahtuma.kuvaus}&lt;/td&gt;
            &lt;td&gt;${tapahtuma.kustannus}&lt;/td&gt;&lt;/tr&gt;
      &lt;/c:forEach&gt;
    &lt;/table&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>

		<p>Ja sovelluksemme on pilkottu selkeämpiin osakokonaisuuksiin. Ole!</p>

		<p><strong>Huom!</strong> Vaikka aluksi voi äyttää siltä että muutimme yksinkertaisen ohjelman paljon monimutkaisemmaksi on muutoksista huomattavasti hyötyä. Tilanteessa jossa sovelluksen tuottamaan sivuun haluttaisiin uusi ulkoasu, erilainen tallennuslogiikka, ja uusia näytettäviä tietoja -- esimerkiksi tehtyjen pyyntöjen määrä -- jokaista näistä tehtävistä voisi työstää rinnakkain.</p>


		<p>MVC-näkökulmasta JSP:n ja Servletin perinteinen yhteistyö on seuraava.
		  <ol>
		    <li>Näkymä -&gt; Ohjaaja: Käyttäjä tekee pyynnön osoitteeseen, jossa toimii Servlet-olio Servlet-olio.</li>
		    <li>Ohjaaja -&gt; Malli: Ohjaaja tekee pyyntöjä palveluita tarjoaville luokille, luoden ja hakien dataa. Data asetetaan pyynnön attribuutiksi.</li>
		    <li>Ohjaaja -&gt; Näkymä: Servletissä valitaan käyttöliittymän sisältävä JSP-sivu. Pyyntö ohjataan näkymää luovaan palveluun.</li>
		    <li>Näkymä -&gt; Malli: JSP-sivu renderöidään käyttäjää varten pyynnön attribuuttina olevaa dataa käyttäen. Sivu lähetetään vastauksena käyttäjälle.</li>
		    <li>Näkymä -&gt; Ohjaaja: ...</li>
		  </ol>
		</p>



<div class="tehtavat">
  <h3>Aikaisemmat syntimme, osa 1</h3>
  
  <p>Olemme aiemmin tehneet vääryyksiä. Onneksi ehdimme vielä korjaamaan ne.</p>

  <h4>Ensimmäinen web-sovellus</h4>

  <p>Muunna aiemmin luomasi web-sovellus <code>eka-servlet</code> sellaiseksi, että lähdekoodissa ei tulosteta ollenkaan HTML-koodia. Siirrä siis kaikki HTML-koodi uudelle jsp-sivulle -- älä käytä sivua <code>index.jsp</code>.</p>

  <h4>Uudelleenohjaus sivulta <code>index.jsp</code></h4>

  <p>Muuta sivun <code>index.jsp</code> sisältö seuraavanlaiseksi.</p>

<pre class="sh_xml">
&lt;meta http-equiv="refresh" content="0;url=${pageContext.request.requestURI}AwesomeServlet"&gt;
</pre>

  <p>Nyt kaikki web-sovelluksen juuripolkuun tulevat pyynnöt uudelleenohjataan <code>/AwesomeServlet</code> -osoitteeseen. </p>
  
  <h4>Kävijälaskuri</h4>

  <p>Lisää sovellukseen kävijälaskuri. Sovelluksen ei tarvitse tallentaa kävijöiden määrää erilliseen tietovarastoon -- kävijöiden määrän pitäminen muistissa on tarpeeksi.</p>

<pre class="sh_xml">
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Servlet AwesomeServlet&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Awesomer! x ${kavijoita}&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

  <h4>Sovelluksen siirto <code>Users</code>-koneelle</h4>

  <p>Siirrä sovellus <code>eka-servlet</code> Users-koneelle.</p>


  <h3>Aikaisemmat syntimme, osa 2</h3>

  <p>Refaktoroi aiemmin toteuttamasi <code>Chat</code>-sovellus siten, että käyttöliittymäkoodi (HTML) on jsp-tiedostoissa, viestit omassa luokassa, ja ohjauslogiikka Servlet-luokissa. Kun olet valmis, siirrä uusi versiosi <code>Users</code>-koneelle.</p>

  <h3>Testaus, viikko 1</h3>

  <p>Tarkista luomasi ohjelmistot osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester</a> olevassa palvelussa. Jos tiedät että ohjelmistossasi on jotain vialla, ja web-palvelu ei tarkasta siihen liittyvää vikaa, korjaa se silti.</p>
  <p>
    <ol>
      <li>Awesome-palvelun testaaja haluaa että sivullasi on laskuri, joka kasvaa pyyntöjen välillä</li>
      <li>Chat-palvelun testaaja haluaa että:
        <ol>
          <li>Palvelulle annetaan Chat-palvelun osoite.</li>
          <li>Käyttäjä ohjataan kirjautumissivulle aloitussivulta kun hän ei ole kirjautunut.</li>
          <li>Kirjautumissivulla on kenttä nimeltä <em>tunnus</em>. Käyttäjä ohjataan chat-sivulle kun tunnus-kenttään kirjoittaa tunnuksen ja lähettää lomakkeen.</li>
          <li>Chat-sivulla on kenttä <em>viesti</em>. Kun viestikenttään kirjoittaa viestin, ja lähettää lomakkeen, viesti näkyy käyttäjälle.</li>
          <li>Chat-sivulla on linkki, joka sisältää tekstin <em>kirjaudu</em>. Linkin klikkaaminen siirtää käyttäjän pois chat-sivulta.</li>
          <li>Kun käyttäjä on kirjautunut ulos, eli klikannut tekstin kirjaudu sisältävää linkkiä, käyttäjä ei pääse chat-sivulle ilman uutta kirjautumista.</li>
        </ol>
      </li>
    </ol>
  </p>
  
  <h3>Käytetyt tunnit, viikko 1</h3>

  <p>Kirjaa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tunnit" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tunnit</a> olevaan palveluun ensimmäisen viikon materiaalin ja tehtävien parissa käyttämäsi aika.</p>

</div>

                <h2 id="ohjelmistoprojektin_hallinta">Ohjelmistoprojektin hallinta</h2>

		<p>Ohjelmistokehittäjän arjesta huomattava osa menee projekteihin liittyviin tehtäviin kuten ylläpitoon. Jokaisessa ohjelmistoprojektissa on erilaisia lähdekoodiin liittyviä tavoitteita, joita kehittäjien tulee pystyä toteuttamaan. Lähdekoodia tulee pystyä paketoimaan tuotantoon siirettäväksi paketiksi (esim -.jar ja -.war -tiedostot), lähdekoodiin liittyviä testejä tulee pystyä ajamaan erillisellä palvelimella, lähdekoodista tulee pystyä generoimaan erilaisia raportteja ja luonnollisesti dokumentaatiota.</p>

		<p>Työkalut kuten <em><a href="http://ant.apache.org/" target="_blank">Apache Ant</a></em> auttavat projektiin liittyvän lähdekoodin hallinnoinnissa ja kääntämisessä. Ant on käytännössä 2000-luvun alun vastine perinteisille Makefile-tiedostoille. Nykyaikaisempi <em><a href="http://maven.apache.org/" target="_blank">Apache Maven</a></em> auttaa käännösprosessin lisäksi projektiin liittyvien lisäkirjastojen hallinnassa. Työkalut ovat oleellinen osa ohjelmistoryhmän yhteisten pelisääntöjä, ja ne muunmuassa tukevat jatkuvaa integrointia.</p>

		<h3>Maven</h3>

		<p>Apache Maven on projektinhallintatyökalu, jota voi käyttää käynnösten automatisoinnin lisäksi lähes koko projektin elinkaaren hallintaan uuden projektin aloittamisesta lähtien. Maveniin voi konfiguroida tavoitteita (<em>goals</em>), joita suoritetaan tarpeen vaatiessa. Tyypillinen tavoite on build, joka paketoi lähdekoodin projektityypistä riippuen sopivaan pakettiin. Oikeastaan maven on sovelluskehys plugin-komponenttien suoritukseen, yksinkertaisimmatkin tehtävät on tehty pluginien avulla.</p>

		<p>Mavenin pluginit jakautuvat karkeasti kahteen osa-alueeseen, käännösprosessiin ja raportointiin. Käännösprosessiin liittyvät pluginit suoritetaan käännösvaiheessa, ja näitä on muunmuassa testaaminen, paketointi, ym. Raportointiin liittyvät pluginit taas hoitavat tehtäviä JavaDoc-dokumentaation luomisesta staattisten lähdekoodianalyysityökalujen suorittamiseen ja niiden luoman raportoinnin hallinnointiin. Mavenin plugineista löytyy (ei kattava) lista osoitteessa <a href="http://maven.apache.org/plugins/index.html" target="_blank">http://maven.apache.org/plugins/index.html</a>.</p>

		<p>Maven automatisoi uusien projektien luomisen <em>archetype</em>-mekanisminsa avulla, jonka avulla käyttäjät voivat tarjota valmiita projektirunkoja toisilleen. Projektirungot toimivat pohjina uusille samaa arkkitehtuuria käyttäville projekteille. Runkojen avulla ohjelmistokehittäjät voivat jakaa hyviksi todettuja käytänteitä, ja ne helpottavat myös organisaatioiden sisällä tapahtuvaa erilaisiin projektityyppeihin liittyvien arkkitehtuurien ylläpitoa.</p>

		<p>Tutustutaan seuraavaksi yksinkertaisen (ei-web) -sovelluksen luomiseen mavenia käyttäen.</p>

<div class="tehtavat">

  <h3>Maveniin tutustuminen</h3>
  
  <h4>Mavenin asennus</h4>
  
  <p>Jos käytössäsi ei ole mavenia, asenna se osoitteesta <a href="http://maven.apache.org/download.html" target="_blank">http://maven.apache.org/download.html</a>. Tietojenkäsittelytieteen laitoksella käytössämme on versio 2.2.1, jatkossa oletamme että käytössäsi on se tai uudempi.</p>

  <h4>Uuden projektin luominen sovellusrungosta</h4>
 
  <p>Kutsu komentoriviltä seuraavaa komentoa. Parametrilla <code>-DgroupId</code> kerrotaan katto-organisaation tai ryhmän tunnus, parametrilla <code>-DartifactId</code> kerrotaan luotavan sovelluksen nimi.</p>
<pre>
mvn archetype:generate -DgroupId=fi.organisaatio -DartifactId=sovelluksen-nimi
</pre>

  <p>Voit vastailla mavenin kysymyksiin kysymyksiin enter-painalluksilla, jolloin maven käyttää oletusvastauksia. Maven luo projektillesi seuraavanlaisen kansiorakenteen.</p>

<pre>
sovelluksen-nimi/
├── pom.xml
└── src
    ├── main
    │   └── java
    │       └── fi
    │           └── organisaatio
    │               └── App.java
    └── test
        └── java
            └── fi
                └── organisaatio
                    └── AppTest.java


</pre>

  <p>Sovelluksen ja testien lähdekoodit ovat eritelty erillisiin kansioihin. Lähdekoodien runkokansio on <code>src</code>, jonka alla on kansiot <code>main</code> ja <code>test</code>. Projektiin liittyvä pom.xml -tiedosto (<em>Project Object Model</em>) näyttää seuraavalta.</p>

<pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;fi.organisaatio&lt;/groupId&gt;
  &lt;artifactId&gt;sovelluksen-nimi&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;sovelluksen-nimi&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</pre>

  <p>Alkuosio määrittelee projektin tiedot, keskellä määritellään että projekti käyttää UTF-8 -merkistökoodausta, ja alaosassa määritellään kirjastot, joista projekti riippuu. Projektille on määritelty riippuvuus JUnit-sovelluskirjastoon. Käytännössä tämä tarkoittaa sitä, että maven noutaa JUnit-kirjaston sovellustamme varten.</p>

  <h4>Testien suorittaminen</h4>

  <p>Mavenin testit suoritetaan maveniin sisäänrakennetulla <a href="http://maven.apache.org/plugins/maven-surefire-plugin/" target="_blank">surefire</a>-pluginilla. Suorita projektiin liittyvät testit kirjoittamalla <code>mvn test</code> pom.xml -tiedoston sisältävässä kansiossa.</p>

<pre>
mvn test
</pre>

  <p>Näet viestin, jonka loppupuolella on merkkijono <em>BUILD SUCCESSFUL</em></p>
<pre>
...
[INFO] BUILD SUCCESSFUL
...
</pre>


<h4>Riippuvuudet ja JUnit 4</h4>

  <p>Mavenin pom.xml -sisältää tietoa projektiin liittyvästä konfiguraatiosta. Riippuvuudet ilmaistaan elementin <code>&lt;dependencies&gt;</code>-alla. Mavenin oletusprojektin pom.xml -tiedostossa on oletuksena JUnit-versio 3.<em>papu</em>. Muuta versioksi 4.10.</p>

<pre class="sh_xml">
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.10&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
</pre>

  <p>Aja testit uudestaan komennolla <code>mvn test</code>. Huomaat että ennen testien suorittamista maven lataa JUnit-version 4.10 käyttöösi. Koska JUnit on yhteensopiva taaksepäin, testit menevät läpi. <em>Älä enää jatkossa hallinnoi jar-tiedostoja käsin</em>.</p>

  <h4>Paketointi</h4>

  <p>Kirjoittaessamme komennon <code>mvn</code>, näemme seuraavan viestin.</p>

<pre>
You must specify at least one goal or lifecycle phase to perform build steps.
The following list illustrates some commonly used build commands:

  mvn clean
    Deletes any build output (e.g. class files or JARs).
  mvn test
    Runs the unit tests for the project.
  mvn install
    Copies the project artifacts into your local repository.
  mvn deploy
    Copies the project artifacts into the remote repository.
  mvn site
    Creates project documentation (e.g. reports or Javadoc).

Please see
http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
for a complete description of available lifecycle phases.
</pre>

  <p>Selaamalla osoitteeseen <a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a> näemme tarkemman listan toiminnoista, joita maven tarjoaa ohjelmistoprojektin eri elinkaarivaiheisiin. Yksi vaihe on <em>packaging</em>, joka sisältää muunmuassa komennot <em>test</em> -- eli yllä käyttämämme komennon -- ja <em>package</em> -- eli paketoinnin. Suorita komento</p>

<pre>
mvn package
</pre>

  <p>Käytössäsi on nyt <code>.jar</code>-tiedosto, johon projektiin liittyvät käännetyt lähdekooditiedostot on paketoitu.</p>

  <h4>Maven pluginit Like A Boss</h4>

  <p>Kaikille plugineille ei ole yksiosaista komentoa, vaan jotkut tulee suorittaa kaksiosaisella komennolla <code>mvn plugin:tavoite</code> -komentoa. Etsi osoitteessa <a href="http://maven.apache.org/plugins/index.html" target="_blank">http://maven.apache.org/plugins/index.html</a> olevasta listasta Checkstyle ja PMD-pluginit ja
    <ol>
      <li>ota selvää miten Checkstyle -pluginin voi suorittaa ja suorita se nykyiselle projektille</li>
      <li>ota selvää miten PMD:n Copy/Paste Detector (CPD) -työkalun voi suorittaa ja suorita se nykyiselle projektille.</li>
    </ol>
  </p>

  <p>Tutustu myös luotuihin raportteihin. Huomaa että raportit luodaan pluginien oletusasetuksilla -- jokainen organisaatio voi toki luoda itselleen sopivat asetukset.</p>

  <h4>Clean</h4>

  <p>Projektiisi liittyvään kansiorakenteeseen on ilmestynyt kansio <code>target</code>, joka sisältää käännettyjä lähdekooditiedostoja. Koska pidämme mavenista, käytämme sen putsauskomentoa. Kirjoita komento <code>mvn clean</code>.</p>

  <p>Projektiin liittyvät raportit ja lähdekooditiedostot on nyt poistettu.</p>
</div>

	<p>Kuten ylläolevassa tehtävässä huomasimme, mavenin avulla voimme hallinnoida projekteihin liittyviä riippuvuuksia ja tehdä <em>paljon</em> muuta. Riippuvuuksien automatisoitu hallinta on nykyaikaisissa web-sovelluksissa oleellista -- käytännössä kaikki sovellukset koostuvat useammasta komponentista. Myös muut työkalut, kuten Checkstyle ja PMD, helpottavat sovituissa koodikäytänteissä pysymistä.</p>

	<h4>Maven ja web-projektit</h4>

	<p>Maven on yleisesti käytössä oleva projektinhallintatyökalu. Mikään ei estä meitä käyttämästä mavenia myös web-sovellusten hallintaan. NetBeans 7.1 tarjoaa hyvän maven-integraation. Tutustutaan siihen seuraavassa tehtäväsarjassa.</p>

<div class="tehtavat">

  <h3>Maven ja NetBeans</h3>

  <p>Tutustutaan seuraavaksi NetBeansin maven-integraatioon.</p>

  <p><strong>Huom!</strong> Jos et käytä NetBeansin versiota 7.1, ala käyttämään sitä viimeistään nyt. Aiempien versioiden Maven-integraatio ei ole läheskään yhtä hyvä kuin version 7.1. Laitoksen koneilla versio 7.1 löytyy kansiosta <code>/opt/netbeans-7.1/</code>, suoritettava binääri on <code>/opt/netbeans-7.1/bin/netbeans</code>.</p>

  <h4>Uuden projektin luominen</h4>

  <p>Luo uusi projekti valitsemalla File -> New Project. Valitse projektin tyypiksi Maven ja Web Application.</p>

  <img src="opas/netbeans-maven/uusi-projekti.png"/>

  <p>Aseta projektin nimeksi <code>maven-intro</code> ja ryhmän tunnukseksi <code>wad</code>. Paina Next.</p>
  <img src="opas/netbeans-maven/maven-intro.png"/>

  <p>Valitse palvelimeksi joku Java EE 5-versiota tukeva palvelin. NetBeansin mukana tuleva GlassFish käy hyvin. Huom! Varmista että valitset version <em>Java EE 5</em>.</p>

  <img src="opas/netbeans-maven/palvelin-ja-javaee5.png"/>

  <p>Olé! Projekti on luotu.</p>

  <h4>Riippuvuusanalyysi</h4>

  <p>Valitse projektin nimi oikealla hiirennäppäimellä ja valitse vaihtoehto <em>Show Dependency Graph</em>. NetBeans näyttää sinulle projektiisi liittyvät riippuvuudet. Riippuvuuden analysointia helpottavasta työkalusta on hyötyä tulevaisuudessa -- kolmannen osapuolen komponentit saattavat viitata toisiinsa ristiin, tai viitata eri versioihin. Näiden näkeminen visuaalisesti auttaa ongelmatilanteissa huomattavasti.</p>

  <img src="opas/netbeans-maven/riippuvuusanalyysi.png"/>

  <h4>Muutos ja users.cs.helsinki.fi -koneelle siirtäminen</h4>

  <p>Etsi käsiisi projektissa oleva <code>index.jsp</code>, ja muokkaa sitä siten, että &lt;h1&gt;-tason otsikkona on Hello Maven!</p>

  <img src="opas/netbeans-maven/jsp-hello-maven.png"/>

  <p>Valitse vasaran kuva, eli Build Main project (olettaen että projekti maven-intro on aktiivisena -- aktiivinen projekti näkyy tummennettuna).</p>

  <img src="opas/netbeans-maven/build-main-project.png"/>

  <p>Vasaran klikkaaminen luo  projektista war-tiedoston, jonka voi kopioida users-koneelle. Tiedosto luodaan projektin alla olevaan kansioon <em>target</em>. Huomaa että war-tiedosto saa pidemmän -- versionumeron sisältävän -- nimen. Esimerkissämme nimeksi tulee <em>maven-intro-1.0-SNAPSHOT.war</em>.</p>

  <p>Kopioi tiedosto nimellä maven-intro.war users.cs.helsinki.fi-koneelle.</p>
<pre>
omakone$ scp .../maven-intro-1.0-SNAPSHOT.war tunnus@users.cs.helsinki.fi:
</pre>

  <p>Ja käy siirtämässä tiedosto <code>tomcat/webapps/</code> -kansioon.</p>

<pre>
users$ mv maven-intro-1.0-SNAPSHOT.war tomcat/webapps/maven-intro.war
</pre>

  <p>Huom! Nimeämme tiedoston uudestaan siirtovaiheessa. Tiedoston nimi määrittelee polun, jossa web-sovellus loppujenlopuksi toimii. Esimerkiksi maven-intro.war -niminen tiedosto käynnistetään osoitteeseen <code<.../maven-intro/</code>, my-test.war -niminen tiedosto käynnistetään osoitteeseen <code>.../my-test/</code></p>

 <p>Varmista että näet sovelluksen osoitteessa <code>http://t-omatunnus.users.cs.helsinki.fi/maven-intro/</code>.</p>

  <img src="opas/netbeans-maven/hello-maven.png"/>

</div>

	<p>Käytämme ohjelmistoissa jatkossa Mavenia.</p>

		<h3>Jatkuva integrointi</h3>

		<p>Maven helpottaa jatkuvaa integrointiprosessia huomattavasti tarjoamalla komentoriviltä suoritettavat ja ohjelmointiympäristöstä riippuvat tavoitteet.</p>

		<p>Jatkuvassa integroinnissa (<em><a href="http://www.extremeprogramming.org/rules/integrateoften.html" target="_blank">Continuous integration</a></em>) jokainen ohjelmistoprojektin jäsen lisää päivittäiset muutoksensa olemassaolevaan kokonaisuuteen. Tämä vähentää virheiden löytämiseen ja korjaamiseen kuluvaa aikaa, koska virheet löytyvät jo varhaisessa vaiheessa. Virheiden löytyessä aikaisin, tehdyt muutokset ovat kehittäjillä vielä mielessä, ja virheiden etsiminen vie huomattavasti vähemmän aikaa kuin silloin, jos integraatioita tehtäisiin harvemmin.</p>

		<p>Jatkuvaa integrointia seuraten ohjelmistokehittäjä hakee kehityksen alla olevan version versionhallinnasta aloittaessaan työn. Hän toteuttaa uuden pienen ominaisuuden testeineen, testaten uutta toiminnallisuutta jatkuvasti. Kun ohjelmistokehittäjä on saanut muutoksen tehtyä, ja kaikki testit menevät läpi hänen paikallisella työasemalla, hän lähettää muutokset versionhallintaan. Kun versionhallintaan tulee muutos, jatkuvaa integrointia suorittava työkalu hakee uusimman version ja suorittaa sille sekä yksikkö- että integraatiotestit.</p>

		<p>Testejä sekä paikallisella kehityskoneella että erillisellä integraatiokoneella ajettaessa ohjelmistotiimi mahdollisesti huomaa virheet, jotka ovat piilossa kehittäjän paikallisen konfiguraation johdosta. Kehittäjä ei aina ota koko ohjelmistoa omalle koneelleen -- ohjelmisto voi koostua useista komponenteista --  jolloin kaikkien vaikutusten testaaminen paikallisesti on mahdotonta. Jos käännös ei mene läpi integraatiokoneella, kehittäjän tulee tehdä korjaukset mahdollisimman nopeasti.</p>

	        <p>Työkaluja automaattiseen kääntämiseen ja jatkuvaan integrointiin ovat muunmuassa <a href="http://continuum.apache.org/" target="_blank">Apache Continuum</a>, <a href="http://cruisecontrol.sourceforge.net/" target="_blank">CruiseControl</a> ja <a href="http://jenkins-ci.org/" target="_blank">Jenkins</a>.</p>

		<p><em>Vinkki työpaikalle: Kun sovelluskehittäjä lähettää muutoksen versionhallintaan ja testit menevät läpi integraatiopalvelimella, soita ryhmätilassa yksinkertainen ja rentouttava ääni -- esim tuulenpuhallus. Jos testit eivät mene läpi, soita huumoria ja/tai ärsytystä herättävä kappale -- esim <a href="http://www.youtube.com/watch?v=MK6TXMsvgQg" target="_blank">Benny Hill Theme</a> tai kurssikanavalla nimimerkin EiZei ehdottama <a href="http://www.youtube.com/watch?v=1ytCEuuW2_A" target="_blank">The Price is Right losing horn</a>.</em></p>


		<h2 id="web_sovelluskehykset">Web-sovelluskehykset</h2>
		
	<p>Kuten normaalit sovelluskehykset, web-sovelluskehykset tarjoavat valmiin rungon ja toiminnallisuutta kehitettävälle ohjelmistolle. Web-sovelluskehykset pyrkivät helpottamaan usein toistettujen toiminnallisuuksien tekemistä, esimerkiksi helpottamalla tietokantayhteyksien ja osoitteita kuuntelevien palveluiden konfigurointia ja hallinnointia.</p>

	<p>Käydään läpi pikaisesti suunnittelumalleja ja ideoita web-sovelluskehysten takana.</p>

	<h3>Templatejärjestelmä</h3>

	<p>Lähes kaikilla web-sovelluskehyksillä on jonkinlainen templatejärjestelmä, jonka avulla käyttöliittymäkoodiin voi lisätä palvelimella generoitua dataa. Templatejärjestelmät tarjoavat myös sivun osien lataamista erikseen (esim. otsakkeet), sekä -- riippuen sovelluskehyksestä -- käyttöliittymäkomponenttikohtaisia lisätoiminnallisuuksia (esim. lomakkeiden generointi).</p>

	<h3>Front Controller</h3>
	
	<p><em>Front Controller</em> on suunnittelumalli, jossa kaikki sovellukseen liittyvät pyynnöt ohjautuvat aluksi yhdelle kontrollipalvelulle, esimerkiksi servletille, joka ohjaa ne eteenpäin muualla määritellyn konfiguraation perusteella. Tämä mahdollistaa web-sovelluskehyksille sovelluskehyskohtaisen kuunneltavien osoitteiden ja tarjottavien palveluiden konfiguroinnin.</p>
	
	<h3>MVC</h3>
	
	<p>Suurin osa web-sovelluskehyksistä helpottaa MVC-mallin käyttämistä tarjoamalla valmiin arkkitehtuuripohjan. Käyttäjän vastuulle jää yleensä sovelluslogiikan tuottaminen. MVC-mallin lopullinen käyttäminen riippuu lopullisesta sovelluksesta. Toisin kuin perinteisessä MVC-mallissa, web-sovelluksissa pyritään yleensä siihen, että näkymästä ei pysty muokkaamaan mallia suoraan.</p>

	<p>Web-sovellukset toteutetaan yleensä kerrosarkkitehtuuria käyttäen (<em>Multitier architecture</em>). Yleisimmin käytetty kerrosarkkitehtuuri on kolmikerrosarkkitehtuuri, jossa päällimmäisenä on sovelluksen kontrollilogiikka ja näyttökerros, keskellä sovelluslogiikka ja alimmaisena tietovarastoon liittyvä logiikka.</p>

	<h3>Automaattinen konfigurointi</h3>

	<p>Sovelluskehykset seuraavat usein ns. <em>Convention-over-Configuration</em> -paradigmaa, jossa käyttäjän tulee seurata sovelluskehyksille tyypillisiä ohjelmointikäytänteitä. Käytännössä ajatuksena on se, ettei kaikkea tule konfiguroida itse, vaan sovelluskehys tekee huomattavan osan määrittelystä käyttäjältä piilossa.</p>

	<h3>Sovellustyypit ja sopivan web-sovelluskehyksen valinta</h3>

	<p>Web-sovellukset voi jakaa karkeasti viiteen erilaiseen ryhmään.

	  <ol>
	    <li>CRUD-sovellus, sanoista <em>Create, Read, Update, Delete</em>. CRUD-sovellukset tarjoavat lähinnä toiminnallisuuksia datan luomiseen, lukemiseen, päivittämiseen ja poistamiseen. Sovellukset, joissa päätavoitteena on yksinkertaisen lisää-poista-muokkaa -lomakkeen tekeminen, hyötyvät paljon web-sovelluskehyksistä jotka tarjoavat mahdollisimman paljon automaattista koodin generointia ja kofigurointia (esim. rails, groovy, roo).</li><br/>

	    <li>Perinteinen web-sovellus, ohut asiakaspuoli (<em>thin client</em>). Perinteiset web-sovellukset koostuvat useammasta sivusta, joiden välillä käyttäjä voi surffata. Mahdollisuus myös rooleihin (esim. kirjautumaton asiakas, asiakas ja admin). Sivujen sisältöä yleensä muokataan erillisellä admin-käyttöliittymällä. Perinteisiä web-sovelluksia voidaan toteuttaa useammalla eri tavalla. Esimerkiksi <a href="http://wicket.apache.org/" target="_blank">Apache Wicket</a> on komponenttipohjainen (<em>component-based</em>) web-sovelluskehys, jossa käyttäjä ohjelmoi sivujen sisällöt. Pyyntöpohjaiset (<em>request-based</em>) sovelluskehykset taas toteutetaan sovelluksen tarjoamien osoitteiden näkökulmasta. Riippuen toteutettevasta sivustosta, sovelluskehittäjän / palvelua tarvitsevan kannattaa tutustua myös olemassaoleviin sisällönhallintajärjestelmiin.</li><br/>

	    <li>Rikas asiakas, (<em>rich client</em>), laajentaa perinteistä web-sovellusta lisäämällä dynaamista toiminnallisuutta, esimerkiksi AJAXin avulla. Rikas asiakas -malli ei tuo vain lisää käyttöliittymään, vaan se vaatii web-sovellukselta myös rajapintoja datan hakemiseen.</li><br/>

	    <li>Rikkaat internet-sovellukset (<em>rich internet applications</em>). Rikkaat internet-sovellukset muistuttavat hyvin paljolti perinteisiä työpöytäsovelluksia. Sovelluksen latauksen jälkeen suurin osa työstä tapahtuu selainpuolella, ja selain ja palvelin kommunikoivat asynkronisesti. Selainpuoli toteutetaan esimerkiksi Ajax-tekniikoita käyttäen, esimerkiksi <a href="http://code.google.com/webtoolkit/">Google Web Toolkit</a>in avulla. Palvelinpuoli tarjoaa rajapinnat selaimelle datan hakemiseen.</li><br/>

	    <li>Portaalit</li> mahdollistavat useiden sovellusten näyttämisen yhtenä sovelluksena. Portaaleja kehitettäessä oleellista on palveluiden integraatio. Käytännössä portaalien kehityksessä käytetään useampia web-sovelluskehyksiä.<br/>
	  </ol>
	</p>

	<p>Käytettävän sovelluskehyksen valinta riippuu sovelluksen tarkoituksesta. Esimerkiksi prototyyppiä rakennettaessa nopeaan kehitykseen tarkoitetut sovelluskehykset (spring, spring roo, wicket, rails jne) ovat hyödyllisiä. Toisaalta, prototyyppejä lähdetään usein laajentamaan suoraan, jolloin sovelluskehyksen ja arkkitehtuuristen päätösten tulee mukautua laajentamiseen.</p>
	
	<p>Oleellista sovelluskehyksen valinnassa on sen taustalla oleva yhteisö tai yritys ja tarjottu tuki, sekä tietenkin oma osaaminen. Mikään web-sovelluskehys ei tee työtä puolestasi, vaan sinä itse olet se, joka loppupeleissä sovelluksen toteuttaa. Sovelluskehykset tuovat vain tukea toteutukseen. Mitä paremmin tunnet sovelluskehyksen, sitä paremmin pystyt käyttämään sitä tukena. Kannattaa pyrkiä tutustumaan useampaan sovelluskehykseen, ja sitä kautta löytää sopivat vaihtoehdot erilaisille tavoitteille -- ja kehittää samalla omaa osaamistaan.</p>

	<h2 id="solid">SOLID</h2>

	<p>Robert "Uncle Bob" Martin lanseerasi 2000 luvun alussa termin <strong>SOLID</strong> olio-ohjelmoinnin suunnitteluun ja kehitykseen. SOLID on akronyymi seuraaville käsitteille: <strong>S</strong>ingle responsibility principle, <strong>O</strong>pen/closed principle, <strong>L</strong>iskov substitution principle</strong>, <strong>I</strong>nterface segregation principle, ja <strong>D</strong>ependency inversion principle.</p>

  <p>
    <ul>
      <li>Single responsibility principle: Oliolla tulee olla vain yksi selkeä vastuu</li><br/>
      <li>Open/closed principle: Komponenttien tulee olla avoimia laajennukselle, mutta suljettuja muokkaukselle. Jos komponenttia muokataan, muutosten ei tule aiheuttaa muutoksia komponenttia laajentaville tai käyttäville komponenteille.</li><br/>
      <li>Liskov substitution principle: Jos komponentti vaihdetaan sitä laajentavaan komponenttiin, ohjelmien jotka käyttävät komponenttia toiminnallisuuden ei tule muuttua.</li><br/>
      <li>Interface segregation principle: Erottele rajapinnat toiminnallisuuksien perusteella. Monta asiakas/tapauskohtaista rajapintaa on parempi kuin yksi yleinen rajapinta.</li><br/>
      <li>Dependency inversion principle: Käytä abstraktioita, älä ole riippuvainen konkreettisista toteutuksista.</li><br/>
    </ul>
  </p>

  <p>Käytännössä SOLID on lista oliosuunnittelun periaatteita, joita seuratessa järjestelmän ylläpidettävyys ja kehitettävyys on huomattavasti helpompaa. Haluamme että omat web-sovelluksemme seuraavat yllälistattuja periaatteita. </p>
  
	<h2 id="spring">Spring</h2>

	<p>Spring on sovelluskehys joka sisältää myös web-sovelluskehyksen. Spring on rakennettu komponenttiperustaiseksi, joten sovelluskehittäjä voi ottaa käyttöönsä vain halutut osat. Muut osat voidaan jättää pois -- tai korvata muilla tekniikoilla. Tällä kurssilla olemme lähinnä kiinnostuneet web-sovelluskehyspuolesta ja Spring Web MVC:stä. Spring on ehkäpä yleisin käytetty vaihtoehtoinen sovelluskehys JavaEE-standardille.</p>

	<p>Spring sisältää käytännössä kaikki perustoiminnallisuudet kuin muutkin Web-sovelluskehykset. Asiakkaan tekemät pyynnöt ohjataan <em>Front Controller</em>ille, joka ohjaa pyynnöt pyyntöjä vastaanottaville kontrolliluokille. Kontrolliluokat ovat normaaleja Java-luokkia, eli POJOja (<em>Plain Old Java Objects</em>). Kontrolliluokat kommunikoivat palvelujen kanssa ja rakentavat mallin, jonka Front Controller ohjaa näkymää luovalle palvelulle. Näkymän voi luoda esimerkiksi JSP-sivuilla.</p>

	<h3>Ensimmäinen Spring-sovellus</h3>

	<p>Luodaan <code>spring-jea</code> -niminen Maven web-projekti NetBeansissa.</p>

	<p>Iso osa Spring-konfiguraatiosta tapahtuu annotaatioiden avulla. Java EE 5-mallissa käytämme myös XML:ää: ns. DispatcherServlet -- eli Front Controller -- tulee konfiguroida web.xml -tiedostoon.</p>




<div class="tehtavat">
	<h3>Ensimmäinen Spring-sovellus</h3>

	<p>Tässä tehtäväsarjassa tehdään askeleittain yksinkertainen Spring web-sovellus.</p>

	<h4>Projektin luominen NetBeansissa</h4>
	
	<p>Luo NetBeansissa Maven-websovellusprojekti nimeltä <em>spring-jea</em>. Kun luot projektin, Varmista että valitset käyttöösi Java EE 5:den. Voit valita pakkaukseksi (Package) nimen <code>wad</code>. Nimi <code>wad</code> on mielivaltainen nimi, ja tulee lyhenteestä <em>Web Application Development</em>. Pakkauksia käytetään normaalisti lähdekoodin loogiseen jakamiseen.</p>

	<p>Luodun projektihakemiston fyysinen rakenne on seuraavanlainen, jos käytät Glassfish -palvelinta käytössäsi on lisäksi tiedosto <code>glassfish-web.xml</code> kansiossa WEB-INF. Tällöin myös kansio META-INF ja sen sisältö puuttuu. Tämä ei haittaa.</p>

<pre>
.
|-- nb-configuration.xml
|-- pom.xml
`-- src
    `-- main
        |-- java
        |   `-- wad
        `-- webapp
            |-- index.jsp
            |-- META-INF
            |   `-- context.xml
            `-- WEB-INF
                `-- web.xml
</pre>

	<p>NetBeansin sisällä projekti näyttää kutakuinkin seuraavalta. </p>

	<div><img src="opas/nb-spring-jea/hakemistorakenne.png"/></div>

	<h4>Spring-kirjastojen hakeminen</h4>

	<p>Mene sivulle <a href="http://www.springsource.org/download" target="_blank">http://www.springsource.org/download</a> ja lataa.. Eiku! Opimme aiemmin käyttämään Mavenia, joten tehdään tämä kuten pitääkin.</p>

	<p>Tällä hetkellä projektisi <em>pom.xml</em>, eli tiedosto joka sisältää Maven-konfiguraation, näyttää kutakuinkin seuraavalta.</p>

<pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;wad&lt;/groupId&gt;
  &lt;artifactId&gt;spring-jea&lt;/artifactId&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

  &lt;name&gt;spring-jea&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.5&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
      &lt;version&gt;2.1&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.0.2&lt;/version&gt;
        &lt;configuration&gt;
          &lt;source&gt;1.5&lt;/source&gt;
          &lt;target&gt;1.5&lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</pre>

	<p>Konfiguraatio määrittelee riippuvuudet Javan servlet-apiin ja jsp-apiin, sekä käyttää kääntämispluginia määrittelemään oletuslähdekoodiversion.</p>

	<p>Riippuvuuksien hakeminen ja Mavenin konfigurointi on oma taiteenlajinsa -- helpohkoa kun sen osaa. Riippuvuuksien hakupalvelu löytyy muunmuassa osoitteessa <a href="http://mvnrepository.com/" target="_blank">http://mvnrepository.com/</a>, jonka lisäksi iso osa ohjelmistokomponenttien valmistajista tarjoaa omia jakelujaan ja maven-palvelimia. MVNRepositorystä löytyy Spring-kirjastot, joita tarvitsemme. Springin omalta kotisivu <a href="http://www.springsource.org" target="_blank">http://www.springsource.org</a> löytäisimme myös oleelliset komponentit.</p>

	<p>Tyhjennä alkuperäinen pom-konfiguraatiosi, ja kopioi allaoleva sen tilalle. Allaolevassa konfiguraatiossa olemme lisänneet spring-kirjastot ja loggaukseen käytettäviä kirjastoja. Muutimme lisäksi Javan lähdekoodiversioksi 1.6 (Java 6).</p>

<pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;wad&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jea&lt;/artifactId&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;name&gt;spring-jea&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;

    &lt;dependencies&gt;
        
        &lt;!-- spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;3.1.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;3.1.0.RELEASE&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;!-- käytetään simple logging facadea commons logging-kirjaston sijaan --&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;!-- servlet ja jsp api --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- jstl --&gt;
        &lt;dependency&gt;
	    &lt;groupId&gt;jstl&lt;/groupId&gt;
	    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
	    &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
         
        &lt;!-- loggauskirjastot --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.6.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
            &lt;version&gt;1.6.1&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;1.6.1&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.16&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.3.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.6&lt;/source&gt;
                    &lt;target&gt;1.6&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</pre>

	<p>SLF eli <a href="http://www.slf4j.org/" target="_blank">Simple Logging Facade</a> on fasaadi lähes kaikkien loggauskirjastojen käyttöön. Jostain syystä Java-kehittäjät ovat kehittäneet huomattavan määrän erilaisia loggauskirjastoja, joiden tarkoitus on tarjota toiminnallisuus -- logien kirjoittamiseen. Tähän liittyy ns. Not invented here -syndrooma, kts. <a href="http://en.wikipedia.org/wiki/Not_invented_here" target="_blank">http://en.wikipedia.org/wiki/Not_invented_here</a>. SLF toimii kattokirjastona muille loggauskirjastoille. </p>

	<p>Kun tallennat ylläolevan pom.xml-sisällön, huomaat vähän ajan kuluttua että Projektin nimessä on pieni keltainen kolmio, joka ilmaisee ongelmaa projektissa. Kun viet hiiren projektin nimen päälle, näet seuraavankaltaisen viestin:</p>

	<div><img src="opas/nb-spring-jea/artifacts-not-in-repo.png"/></div>

	<p>Viesti käytännössä kertoo että projektiin liittyviä riippuvuuksia ei löydy paikallisesta varastosta. Maven lataa paikalliset lähdekooditiedostot käyttäjätunnuksen alle kansioon <code>.m2/repository/</code>. Lähdekoodiriippuvuudet saa ladattua (esimerkiksi) klikkaamalla kansiota Dependencies oikealla hiirennapilla ja valitsemalla <em>Download Declared Dependencies</em>.</p>

	<div><img src="opas/nb-spring-jea/download-declared-dependencies.png"/></div>

	<p>Klikkaa <em>Download Declared Dependencies</em>, jolloin NB hakee riippuvuudet käyttöösi. Koska luotamme NetBeansiin vain silloin tällöin, valitse vielä Clean and Build. Riippuvuuksien lataamisessa menee hetki:</p>

	<div><img src="opas/nb-spring-jea/riippuvuudet.png"/></div>

	<p>(<em>kuvassa riippuvuuksia järjestelty siistimpään asetelmaan..</em>)</p>

	<h4>Front Controllerin konfigurointi</h4>

	<p>Avaa projektiin liittyvä <code>web.xml</code> -tiedosto. Springin Front Controller on Servlet nimeltä <em>DispatcherServlet</em>, ja se löytyy pakkauksesta <code>org.springframework.web.servlet</code>. DispatcherServlet ottaa alustusparametrina parametrin <code>contextConfigLocation</code>, jonka arvoksi tulee sovelluksen konfiguraatiotiedoston sijainti. Asetetaan konfiguraatiotiedoston sijainniksi <code>/WEB-INF/spring-context.xml</code>.</p>

	<p>Front Controller kuuntelee kaikkia sovellukseen kohdistuvia pyyntöjä, joten sen kuuntelemaksi osoitteeksi tulee <code>/</code>.</p>

	<p>Muuta web.xml-tiedoston sisältö seuraavanlaiseksi.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
         http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
    &lt;display-name&gt;spring-jea&lt;/display-name&gt;
    
    &lt;!-- front controller --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;spring-front-controller&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/spring-context.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;        
 
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring-front-controller&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;session-config&gt;
        &lt;session-timeout&gt;
            30
        &lt;/session-timeout&gt;
    &lt;/session-config&gt;
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;
</pre>

	<p>Konfiguraatioparametrin <code>load-on-startup</code> arvo <code>1</code> tarkoittaa että Servlet ladataan heti kun on mahdollista muistiin (joissain tapauksissa servletit ladataan vasta kun ensimmäinen pyyntö tehdään).</p>

<h4>spring-context.xml</h4>


	<p>Uuden xml-tiedoston luominen tapahtuu esimerkiksi seuraavasti NetBeansissa: Valitse File -> New File -> XML -> XML Document. Kun olet saanut dokumentin luotua, voit tyhjentää sen ja käyttää sitä pohjana. Jos valitset projektin oikealla hiirennapilla, tiedoston voi luoda valitsemalla New -> Other -> XML -> XML Document.</p>

	<p>Luo kansioon WEB-INF xml-tiedosto nimeltä <code>spring-context.xml</code>. Annoimme tämän aiemmin <code>contextConfigLocation</code>-parametrina Springin DispatcherServlet-luokalle. Tiedosto <code>spring-context.xml</code> sisältää osan ohjelmiston konfiguratiosta. Java-sovelluskehitystä <em>mollaavat</em> kutsuvat tätä <em>xml</em>-viidakoksi.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
        http://www.springframework.org/schema/mvc 
          http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
        http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context 
          http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;
 
    &lt;!-- DispatcherServletin (front-controllerin) konfiguraatio, jolla määritellään pyynnön kulku. --&gt;
 
    &lt;!-- Sovelluksemme lähdekooditiedostot sijaitsevat pakkauksessa wad tai sen alipakkauksissa--&gt;
    &lt;context:component-scan base-package="wad" /&gt;
 
    &lt;!-- Käytetään Spring MVC:tä annotaatioiden avulla --&gt;
    &lt;mvc:annotation-driven /&gt; 
&lt;/beans&gt;
</pre>

	<p>Web-sovelluksen (ja Spring-sovelluskehystä käyttävän sovelluksen) konfigurointi ilman yhtään xml-riviä on mahdollista esimerkiksi käyttämällä ns. Bootstrap-mekanismia, jossa sovellus ja palvelin käynnistetään erillisen käynnistysohjelman avulla. Sama onnistuu ilman bootstrappia Java EE 6:ssa. Käytämme kuitenkin xml:ää ja Java EE 5:ttä -- osittain nähdäksemme mitä takana liikkuu, osittain koska laitoksen users-ympäristö ei tue Java EE:n versiota 6.</p>

	<h4>Ensimmäinen kontrolleri</h4>

	<p>Luo luokka (ei servlet!) <code>EkaController</code> pakkaukseen wad. Spring etsii oleelliset luokat annotaatioiden perusteella, kontrolleriluokilla on annotaatio <code>@Controller</code>. Kontrolleriluokilla on huomattava määrä konfiguraatiomahdollisuuksia, tärkein tällä hetkellä <code>@RequestMapping</code>. Annotaation <code>@RequestMapping</code> avulla voimme määritellä metodille (ja luokalle) kuunneltavat osoitteet. Luodaan luokkaan merkkijonon palauttava metodi <code>heiSpring()</code>.</p>

<pre class="sh_java">
package wad;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class EkaController {

    @RequestMapping("eka")
    public String heiSpring() {
        System.out.println("Heippa!");
        return "index.jsp";
    }
}
</pre>

	<p>Ylläolevaa lähdekoodia katsoessa varmaan arvaatkin että merkkijonona palautetaan jsp-sivu, jolle pyyntö ohjataan. Ylläoleva kontrollerimme tulostaa standarditulostusvirtaan viestin "Heippa!", ja ohjaa pyynnön sivulle <code>index.jsp</code>.</p>

	<p>Käynnistä palvelin ja kokeile sen toimintaa. Kun teet pyynnön osoitteeseen <code>&lt;palvelinosoite&gt;:&lt;portti&gt;/spring-jea/eka</code>, näet palvelimen logeissa viestin "Heippa!". Selaimessa näkyy sivun index.jsp-sisältö.</p>

	<p><strong>Huom!</strong> Riippuen käyttämästäsi palvelimesta, on mahdollista että sivulle <code>index.jsp</code> ei ohjauduta automaattisesti. Tällöin sinun tulee kirjoittaa sivu index.jsp käsin palvelimen osoitteen perään. NetBeansilla voit myös määritellä aloitusosoitteen valitsemalla projektin oikealla hiirennäppäimellä, valitsemalla Properties -> Run -> ja asettamalla kentän Relative URL -arvoksi <code>/index.jsp</code>.</p>

	<p><em>Jos et löydä palvelua osoitteesta <code>&lt;palvelinosoite&gt;:&lt;portti&gt;/spring-jea/eka</code>, tarkista logeista mihin palvelu on käynnistetty. NetBeansin vanhemmilla versioilla Glassfish voi lisätä sovelluksen esimerkiksi osoitteeseen <code>&lt;palvelinosoite&gt;:&lt;portti&gt;/spring-jea-1.0-SNAPSHOT/eka</code></em>.</p>

	<div><img src="opas/nb-spring-jea/oletus-index-jsp.png"/></div>

	<p><strong>Huom!</strong> Jos Maven tai NetBeans ilmoittaa että sinulta puuttuu joku kirjasto käynnistäessäsi palvelinta, ongelma todennäköisesti johtuu aiemmista käytössäsi olevista kirjastoista. Käy poistamassa kotikansiossasi olevasta <code>.m2</code> -hakemistosta kansio <code>repositories</code>.  Maven luo kansioon repositories paikallisen varaston käytetyille kirjastoille, ja on mahdollista että sinulla on ollut Springin aiempi versio kirjastossasi.</p>


	<h4>Oman viestin näyttäminen sivulla EL-kielen avulla</h4>

	<p>Lisätään JSP-tutustumisestamme tutun EL-kielen avulla viesti ${viesti} JSP-sivulle, ja muutetaan näytettäväksi tekstiksi Hello Spring. Muuta index.jsp:n sisältö seuraavanlaiseksi.</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd"&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;JSP Page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello Spring * ${viesti}&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

	<p>JSP-sivua renderöidessä pyynnön attribuuteista etsitään siis attribuuttien nimeltä <em>viesti</em>. Servleteillä lisäsimme attribuutit pyyntöön HttpServletRequest-olion metodilla <code>setAttribute</code>.</p>

	<p>Kun haet osoitteen <code>&lt;palvelinosoite&gt;:&lt;portti&gt;/spring-jea/eka</code> uudestaan näet seuraavanlaisen sivun.</p>

	<div><img src="opas/nb-spring-jea/hello-spring.png"/></div>

	<p>Spring, kuten mikään muukaan sovelluskehys, ei tee taikatemppuja puolestamme.</p>

	<h4>Kontrolleriluokissa olevien metodien siisteys, osa 1</h4>

	<p>Lisää luokassa EkaController olevalle metodille <code>heiSpring</code> HttpServletRequest -tyyppinen parametri.</p>

<pre class="sh_java">
    public String heiSpring(HttpServletRequest request) {
</pre>

	<p>Ja muuta metodia siten, että asetat <code>request</code>-oliolle attribuutin viesti. Alla attribuutille nimeltä viesti on asetettu arvo "2".</p>

<pre class="sh_java">
    @RequestMapping("eka")
    public String heiSpring(HttpServletRequest request) {
        System.out.println("Heippa!");

        request.setAttribute("viesti", "2");
        return "index.jsp";
    }
</pre>

	<p>Lataa sivu uudelleen, näet nyt seuraavanlaisen tekstin.</p>

	<div><img src="opas/nb-spring-jea/hello-spring-2.png"/></div>

	<p>Ok, miten ihmeessä toi HttpServletRequest pääsee tonne?</p>

	<h4>Kontrolleriluokissa olevien metodien siisteys, osa 2</h4>

	<p>Haluammekin pääsyn myös HttpSession-olioon, teemme seuraavaksi yksinkertaisen laskuria joka laskee käyttäjäkohtaiset pyynnöt session avulla. Muuta metodi <code>heiSpring</code> sellaiseksi, että se saa parametrinaan <code>HttpServletRequest</code>-luokan ilmentymän lisäksi <code>HttpSession</code>-luokan ilmentymän.</p>

	<p>Lisää luokkaan toiminnallisuus: Jos sessiossa on olemassa attribuutti "kaynnit", kasvatetaan sen arvoa yhdellä. Muuten asetetaan sen arvoksi 1. Lisää käyntien määrä pyynnön attribuutin "viesti" arvoksi.</p>

	<p>Muutostesi jälkeen lähdekoodin tulisi näyttää suunnilleen seuraavalta.</p>

<pre class="sh_java">
    @RequestMapping("eka")
    public String heiSpring(HttpServletRequest request, HttpSession session) {
        System.out.println("Heippa!");

        int kaynteja = 0;
        if (session.getAttribute("kaynnit") != null) {
            kaynteja = (Integer) session.getAttribute("kaynnit");
        }

        kaynteja = kaynteja + 1;
        session.setAttribute("kaynnit", kaynteja);

        request.setAttribute("viesti", kaynteja);
        return "index.jsp";
    }
</pre>

	<p>Nyt kun haet osoitteen <code>&lt;palvelinosoite&gt;:&lt;portti&gt;/spring-jea/eka</code>, sinulla on henkilökohtainen käyntilaskuri.</p>

	<div><img src="opas/nb-spring-jea/spring-kayntilaskuri.png"/></div>

	<p>Mitä tässä oikein tapahtuu?</p>

	<p><em>Spring tuo kontrolliluokkiisi tarvitsemasi luokat silloin kun sinä niitä tarvitset.</em></p>

	<h4>Model</h4>

	<p>HttpServletRequest on <em>passé</em>. MVC-mallin mukaisesti haluamme täyttää pyynnössä mallin. Spring tarjoaa meille luokan Model, johon lisäämme pyynnön attribuutit. Muutetaan metodia heiSpring siten, että se saa parametrinaan Model-luokan ilmentymän. Attribuutti viesti lisätään Model-luokan ilmentymälle metodilla <code>addAttribute</code>. Ohjelmasi pitäisi olla kokonaisuudessaan nyt seuraavanlainen.</p>

<pre class="sh_java">
package wad;

import javax.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class EkaController {

    @RequestMapping("eka")
    public String heiSpring(Model model, HttpSession session) {
        System.out.println("Heippa!");

        int kaynteja = 0;
        if (session.getAttribute("kaynnit") != null) {
            kaynteja = (Integer) session.getAttribute("kaynnit");
        }

        kaynteja = kaynteja + 1;
        session.setAttribute("kaynnit", kaynteja);


        model.addAttribute("viesti", kaynteja);
        return "index.jsp";
    }
}
</pre>

	<p>Tarkista vielä että web-sovelluksesi tarjoama toiminnallisuus ei muuttunut millään tavalla.</p>

	<p>Onneksi olkoon, olet tehnyt ensimmäisen Spring-web sovelluksesi ja tutustunut Springin kontrollilogiikaan</p>

</div>

  <h3>Näkymät ja Controller-luokat</h3>

  <p>Palautimme edellisessä tehtävässä JSP-sivun nimen kontrolliluokan metodissa. Kontrolliluokan metodi toimii oletuksena kuin Servlet-teknologiasta tuttu DispatcherServlet, eli sille voi antaa osoitteen mihin pyyntö ohjataan. Sovelluskehittäjät haluavat usein pitää näkymätiedostoja WEB-INF -kansion alla, jolloin selainohjelmiston käyttäjät eivät pääse niihin suoraan käsiksi. <em>Jos et halua että käyttäjä voi kirjoittaa suoraan .../tiedosto.jsp, pidä tiedosto WEB-INF -kansion alla</em>.Voimme konfiguroida tiedostojen sijainnin joko <code>spring-context.xml</code>-tiedoston sisään XML:nä:</p>

<pre class="sh_xml">
&lt;!-- ohjaa palautetut nimet /WEB-INF/view-kansiossa oleviin jsp-sivuihin --&gt;
&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
    &lt;property name="prefix" value="/WEB-INF/view/" /&gt;
    &lt;property name="suffix" value=".jsp" /&gt;
&lt;/bean&gt;
</pre>

  <p>Tai ohjelmallisesti:</p>

<pre class="sh_java">
package wad.config;
 
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.view.InternalResourceViewResolver;
 
@Configuration
public class WadConfig {
 
    // ohjaa palautetut nimet /WEB-INF/view-kansiossa oleviin jsp-sivuihin
    @Bean
    ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("WEB-INF/view/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
}
</pre>

  <p>Jos käytät ohjelmallista konfiguraatiota, tarvitset lisäkirjaston nimeltä CGLIB käyttöösi. CGLIB tarjoaa toiminnallisuutta koodin automaattiseen generointiin, lisätietoa osoitteesta <a href="http://cglib.sourceforge.net/" target="_blank">http://cglib.sourceforge.net/</a>. CGLIB-kirjaston saa käyttöön Mavenin avulla lisäämällä riippuvuuden pom.xml-tiedostoon. </p> 

<pre>
        &lt;dependency&gt;
            &lt;groupId&gt;cglib&lt;/groupId&gt;
            &lt;artifactId&gt;cglib&lt;/artifactId&gt;
            &lt;version&gt;2.2.2&lt;/version&gt;
        &lt;/dependency&gt; 
</pre>

  <p>Kumpaa tahansa ylläolevaa lähestymistapaa käytettäessä kontrolliluokasta palautettu merkkijono "sivu" näytettäisiin kansiossa <code>WEB-INF/sivu.jsp</code>-tiedoston avulla. Huomaa että loppuliite <em>suffix</em> on määritelty <em>.jsp</em>:ksi, joten kontrollerimetodilta palautettavaan merkkijonoon ei lisätä .jsp -päätettä.</p>

  <p>Springin vahvuutena on näkymäteknologioiden erotus sovelluslogiikasta. Käyttäjä voi käytännössä valita oman näkymäteknologian, tekniikan vaihto vaatii toki konfigurointia. Käytämme kurssilla lähinnä JSP:tä, lisää tietoa näkymien konfiguroinnista springistä löytyy mm. osoitteista <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-viewresolver" target="_blank">http://static.springsource.org/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-viewresolver</a> ja <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/view.html" target="_blank">http://static.springsource.org/spring/docs/current/spring-framework-reference/html/view.html</a>.</p>

  <h4>Pyynnön parametrit</h4>

  <p>Pyynnössä lähetettyjen parametrien käsittely on myös suhteellisen helppoa. Parametrit saadaan kiinni annotaatiolla @RequestParam, jota seuraa muuttuja johon parametri asetetaan. Esimerkiksi seuraava kontrolleriluokan metodi <code>tulostaNimi</code> tulostaa osoitteeseen <code>palvelin:portti/sovellus/tulosta</code> saadun pyynnön parametrina saadun muuttujan <code>nimi</code> arvon.</p>

<pre class="sh_java">
    @RequestMapping("tulosta")
    public String tulostaNimi(@RequestParam String nimi) {
        System.out.println("Nimi: " + nimi);
        return "done";
    }
</pre>

  <p>Yllä oleva metodi ottaa pyynnöstä parametrin nimeltä <code>nimi</code> ja tulostaa sen arvon standarditulostusvirtaan. Metodi palauttaa merkkijonon <code>done</code>, jonka avulla -- konfiguraatiosta riippuen -- valitaan näkymä.</p>

  <p>Vaikka HTTP:llä parametrit ovat aina merkkijonomuotoisia, voimme pyytää Springiä muuttamaan parametrit valmiiksi meitä varten. Esimerkiksi seuraava metodi summaa kahden kokonaisluvun arvon.</p>  

<pre class="sh_java">
    @RequestMapping("summaa")
    public String summaaArvot(@RequestParam Integer eka, @RequestParam Integer toka) {
        System.out.println("Summa: " + (eka + toka));
        return "done";
    }
</pre>


<div class="tehtavat">
  <h3>Laskin</h3>
  
  <p>Tässä tehtävässä toteutetaan yksinkertainen laskin, joka tarjoaa operaatiot summa- kerto- ja jakolaskut.</p>

  <h4>Runko</h4>

  <p>Luo itsellesi projektirunko jossa käytössäsi on Spring-sovelluskehys. Käytä näkymänohjausta siten, että kun palautat kontrolliluokkien metodeista merkkijonon, merkkijonon perusteella haetaan JSP-sivua kansiosta <code>/WEB-INF/view/</code>.</p>

  <h4>JSP-sivu</h4>

  <p>Luo kansioon <code>/WEB-INF/view/</code> JSP-sivu <code>laskin.jsp</code>, joka sisältää seuraavan määrittelyn:</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;JSP Page&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Tulos on ${tulos}&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


<h4>Summalasku</h4>

  <p>Luo luokka <code>LaskinController</code>. Määrittele se kontrolleriksi @Controller-annotaation avulla.</p>

  <p>Luo luokkaan metodi <code>summalasku</code>, joka kuuntelee osoitetta <code>summa</code>. Metodi saa kaksi pyyntöparametria <code>eka</code> ja <code>toka</code>, jotka molemmat ovat kokonaislukuja, sekä mallin (<em>Model</em>), johon tulos tallennetaan myöhempää näyttöä varten.</p>

  <p>Laske metodissa parametrina saatujen lukujen summa, ja lisää se attribuuttina "tulos" malliin. Palauta metodista merkkijono "laskin", jolloin web-sovelluksesi pitäisi ohjata tulos kansiossa /WEB-INF/view/ olevalle laskin.jsp-sivulle.</p>

  <p>Voit testata laskintasi käyttämällä selaintasi. Esimerkiksi pyyntö osoitteeseen .../sovellus/summa?eka=1&toka=3 tulee lisätä malliin arvo 4 ja tulostaa se käyttäjälle seuraavannäköisenä sivuna.</p>

<div><img src="opas/nb-spring-laskin/tulos-nelja.png"/></div>


  <h4>Kertolasku ja jakolasku</h4>

  <p>Lisää metodit <code>kertolasku</code>, joka kuuntelee osoitetta <code>kerto</code>, ja <code>jakolasku</code>, joka kuuntelee osoitetta <code>jako</code>. Muista että Javassa kahden kokonaisluvun jakolaskun tulos on myös kokonaisluku. Saat tulokseksi liukuluvun kertomalla esimerkiksi ensimmäisen luvun 1.0:lla ennen laskua.</p>

  <h4>Siirrä ohjelmasi users-koneelle ja palauta se</h4>
  
  <p>Saat ohjelman paketoitua kuten aiemminkin valitsemalla "clean & build". Siirrä laskimesi users-koneelle, ja lähetä se tarkastettavaksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester2/">http://t-avihavai.users.cs.helsinki.fi/tester2/</a> olevaan palveluun.</p>

  <p><strong>Huom!</strong> Kun palautat vain yhtä tehtävää kerrallaan, tarkastaja valittaa ettei muita ole lähetetty. Tämä on täysin ok -- jos et näe virheilmoitusta omaan tehtävääsi liittyen. </p>

  <p>Web-sovelluksen vaatimukset:</p>

  <ul>
    <li>Lukee parametrit <code>eka</code> ja <code>toka</code></li>
    <li>Kuuntelee osoitetta <code>...sovellus/summa</code>, joka näyttää käyttäjälle sivun jossa on summalaskun tulos.</li>
    <li>Kuuntelee osoitetta <code>...sovellus/kerto</code>, joka näyttää käyttäjälle sivun jossa on kertolaskun tulos.</li>
    <li>Kuuntelee osoitetta <code>...sovellus/jako</code>, joka näyttää käyttäjälle sivun jossa on jakolaskun tulos.</li>
  </ul>
</div>

<h4>Listat</h4>

  <p>Näemme usein käyttötapauksia, joissa meidän tulee ottaa kiinni useampia samannimisiä parametreja. Samannimiset parametrit voidaan ottaa kiinni määrittelemällä taulukkotyyppinen muuttuja ja käyttämällä tuttua @RequestParam-annotaatiota.</p>

<pre class="sh_java">
    @RequestMapping("montaViestia")
    public String tulostaNimi(@RequestParam String[] viestit) {
        for (String viesti : viestit) {
            System.out.println(viesti);
        }
        
        return "done";
    }
</pre>

  <p>Ylläoleva kontrolliluokan metodi pystyy käsittelemään esimerkiksi allaolevan lomakkeen.</p>

<pre class="sh_xml">
    &lt;form action="montaViestia" method="POST"&gt;
        &lt;input type="text" name="viestit" &gt;&lt;br&gt;
        &lt;input type="text" name="viestit" &gt;&lt;br&gt;
        &lt;input type="text" name="viestit" &gt;&lt;br&gt;
        &lt;input type="submit"&gt;
    &lt;/form&gt;
</pre>

<h4>Lomakkeista ja olioista</h4>

  <p>On myös mahdollista asettaa pyynnön attribuutteja luokan ilmentymän arvoiksi. Luokalla täytyy olla tätä varten setterit (set-metodit). Haluamme kerätä henkilöltä nimen ja sähköpostiosoitteen. Luodaan tätä varten oma luokka <code>Henkilo</code>, jonka sisältö on seuraavanlainen.</p>

<pre class="sh_java">
public class Henkilo {

    private String nimi;
    private String email;

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getNimi() {
        return nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}
</pre>

  <p>Kai muistat että sinun tarvitsee kirjoittaa luokalle vain attribuutit, NetBeansin insert code-toiminnallisuus hoitaa loput?</p>

  <p>Henkilo-luokalla on kentät <code>nimi</code> ja <code>email</code>. Luodaan seuraavaksi lomake henkilön tietojen pyytämiseen.</p>

<pre class="sh_xml">
    &lt;form action="yhteystiedot" method="POST"&gt;
        &lt;span&gt;Nimi: &lt;input type="text" name="nimi" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;span&gt;Sähköpostiosoite: &lt;input type="text" name="email" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;input type="submit"&gt;
    &lt;/form&gt;
</pre>

  <p>Ja lopuksi kontrollerimetodi. Saamme annotaatiolla <em>@ModelAttribute</em> asetettua pyyntöön liittyviä parametreja suoraan olion arvoksi.</p>

<pre class="sh_java">
    @RequestMapping("yhteystiedot")
    public String tulostaHenkilo(@ModelAttribute Henkilo henkilo) {
        System.out.println("Henkilön nimi: " + henkilo.getNimi());
        System.out.println("Henkilön sähköpostiosoite: " + henkilo.getEmail());

        return "done";
    }
</pre>

<div class="tehtavat">
  <h3>Kilpailuun osallistuminen</h3>

  <p>Luo web-sovellus jonka avulla voidaan ilmoittautua kilpailuun. Kilpailuun ilmoittautumisia ei tallenneta mihinkään, vaan ne näytetään suoraan käyttäjälle.</p>
  
  <p>Käytä lomakkeena seuraavaa (tarvitset siis kontrolleriluokan jossa on osoitetta "osallistu" kuunteleva metodi:</p>
  
<pre class="sh_xml">
    &lt;form action="osallistu" method="POST"&gt;
        &lt;span&gt;Nimi: &lt;input type="text" name="nimi" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;span&gt;Email: &lt;input type="text" name="email" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;span&gt;Saa mainostaa jatkossa: &lt;input type="checkbox" name="osallistuuKilpailuun" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;input type="submit"&gt;
    &lt;/form&gt;
</pre>

<p>Voit määritellä kontrolliluokan metodin ottamaan vastaan vain POST-tyyppisiä pyyntöjä @RequestMapping-annotaation avulla:</p>

<pre class="sh_java">@RequestMapping(value="osoite", method=RequestMethod.POST)</pre>

<p>Kun lomake on lähetetty, tulosta lomakkeen tiedot seuraavaa sivupohjaa käyttäen. Sivupohjaan on jo määritelty tarvitut EL-tägit.</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Ilmoittautuminen&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h2&gt;Osallistujan nimi: ${osallistuja.nimi}&lt;/h2&gt;
        &lt;h2&gt;Osallistujan email: ${osallistuja.email}&lt;/h2&gt;
        &lt;h2&gt;Osallistuu: ${osallistuja.osallistuuKilpailuun}&lt;/h2&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


  <p>Huom! On ok että Osallistuu -kohtaan tulostuu tyhjää kun käyttäjä ei ruksaa checkbox-nappia</p>


  <p>Siirrä ohjelmasi users-koneelle, ja lähetä se tarkastettavaksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester2/">http://t-avihavai.users.cs.helsinki.fi/tester2/</a> olevassa palvelussa.</p>

</div>

<h4>POST</h4>

  <p>Kontrolleriluokan metodin voi asettaa kuuntelemaan vain POST-kutsuja @RequestMapping-annotaation parametreillä</p>

<pre class="sh_java">@RequestMapping(value="osoite", method=RequestMethod.POST)</pre>

  <p>POST-tapahtumien jälkeen haluamme tehdä uudelleenohjauksen normaaliin listaukseen, jotta refresh-napin painaminen ei haittaisi. Servleteillä käytettiin <code>HttpServletRequest</code>-luokan <code>sendRedirect</code>-metodia, Springissä voimme palauttaa merkkijonon "redirect:/uusiosoite".</p>

  <h4>Pyyntöparametriannotaatioiden suoritusjärjestyksestä</h4>

  <p>Kun teet pyynnön Spring yrittää ensin asettaa pyynnon parametreja @ModelAttribute-annotaatiolla merkattuihin olioihin. Tämän jälkeen arvoja asetetaan @RequestParam-annotaatiolla merkattuihin muuttujiin. Voit siis myös käyttää kumpiakin kenttiä sovellusta rakennettaessa, esimerkiksi seuraavasti:</p>

<pre class="sh_java">
    @RequestMapping("yhteystiedot")
    public String tulostaHenkilo(@ModelAttribute Henkilo henkilo, @RequestParam Integer piilotunnus) {
        System.out.println("Henkilön nimi: " + henkilo.getNimi());
        System.out.println("Henkilön sähköpostiosoite: " + henkilo.getEmail());

        System.out.println("Piilotunnus: " + piilotunnus);

        return "done";
    }
</pre>

<pre class="sh_xml">
    &lt;form action="yhteystiedot" method="POST"&gt;
        &lt;span&gt;Nimi: &lt;input type="text" name="nimi" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;span&gt;Sähköpostiosoite: &lt;input type="text" name="email" &gt;&lt;/span&gt;&lt;br&gt;
        &lt;input type="hidden" name="piilotunnus" value="42" &gt;
        &lt;input type="submit"&gt;
    &lt;/form&gt;
</pre>

  <p>Piilotunnus on määritelty lomakkeeseen hidden-kenttänä jolla on arvo 42. Syötekentän tyyppi <em>hidden</em> tarkoittaa sitä että kenttää ei näytetä käyttäjälle.</p>

  <h4>Oletusarvot ja parametrin pakollisuus</h4>

  <p>Pyynnön parametrille voi määritellä oletusarvon. Tämä auttaa esimerkiksi checkbox-tyyppisissä kentissä. Valintaruutukentästä ei lähetetä tietoa palvelimelle jos sitä ei ole valittu.</p>

<pre class="sh_xml">
    &lt;form action="check" method="POST"&gt;
        &lt;span&gt;Asia selvä? &lt;input type="checkbox" name="kaikkiOk" &gt; Jep! &lt;/span&gt;&lt;br&gt;
        &lt;input type="submit"&gt;
    &lt;/form&gt;
</pre>

<pre class="sh_java">
    @RequestMapping("check")
    public String tulostaHenkilo(@RequestParam(required=false, defaultValue="false") Boolean kaikkiOk) {
        System.out.println("Mukana: " + ok);
        return "done";
    }
</pre>


  <p>Oletusarvo määritellään @RequestParam-annotaation parametrin defaultValue avulla. Huomaa että defaultValue saa arvokseen aina merkkijonon. Parametrin voi määritellä vapaaehtoiseksi asettamalla RequestParam-annotaation parametrille required arvo false.</p>

  <p>Spring tarjoaa myös oman tägikirjaston lomakkeiden luomiseen JSP-sivuille. Emme kuitenkaan tutustu siihen <em>vielä</em>.</p>


  <h3>Sovelluslogiikka ja Service-annotaatio</h3>

  <p>Sovelluslogiikka jaetaan oliosuunnittelun periaatteiden mukaisesti toiminnallisuutta tarjoaviin palveluihin, joita kontrollikerros käyttää. Spring tarjoaa hyvät välineet sovelluslogiikan ja kontrollikerroksen erottamiseen. Edellisessä kappaleessa tutustuimme kontrollilogiikan ja näkymän erottamiseen, sekä Springin kontrolliluokan toimintaan. Tutustumme seuraavaksi kontrolliluokan ja sovelluslogiikan yhteistoimintaan.</p>

  <h4>Inversion of Control ja Dependency Injection</h4>

  <p>Jokaisella oliolla on oma selkeä vastuualueensa, ja niiden sekoittamista tulee välttää. Inversion of Control ja Dependency Injection ovat suunnitelumalleja, joilla pyritään vähentämään olioiden turhia riippuvuuksia.</p>

  <p><strong>Inversion of Control</strong></p>

  <p>Perinteisissä ohjelmistoissa luokkien ilmentymien luominen on ohjelmoijan vastuulla. Huomasimme jo aiemmin että Spring luo käyttöömme luokkia joita tarvitsemme: Kontrollin käännöllä tarkoitetaan ohjelman toiminnan hallinnan vastuun siirtämistä sovelluskehykselle ja ohjelmaa suorittavalle palvelimelle.</p>

  <p><strong>Dependency Injection</strong></p>

  <p>Dependency Injectionin tehtävänä on syöttää riippuvuudet silloin kun niitä tarvitaan.</p>

  <p>Käytännössä siis: palvelin ja sovelluskehys ottaa vastuuta luokkien hallinnoinnista. Sovelluskehys syöttää riippuvuudet niitä tarvittaessa. Molemmat toiminnallisuudet ovat oleellisia kerrosarkkitehtuurin kerrosten toisistaan erottamisessa.</p>

  <h4>Palveluesimerkki: HitCounter</h4>
  
  <p>Luodaan palvelu jonka tehtävänä on yksittäisten vierailujen määrän laskeminen. Oletetaan että meillä on käytössä aiemmin ensimmäinen Spring-sovellus -kohdassa luotu tyhjä projekti.</p>

  <p>Määritellään rajapinta HitCounter-palvelulle. Rajapinta tarjoaa kaksi metodia: <code>getCount()</code>, joka palauttaa kävijöiden määrän, ja <code>incrementCount()</code>, joka kasvattaa kävijöiden määrää yhdellä.</p>

<pre class="sh_java">
package wad.hitcounter;

public interface HitCounter {
    int getCount();
    void incrementCount();
}
</pre>

  <p>Viimeistään tässä vaiheessa tekisimme oikeasti muutaman testin HitCounter-palvelulle. Keskitymme kuitenkin tässä esimerkissä itse palveluun, palaamme testaamiseen myöhemmin.</p> 

  <p>Luodaan rajapinnalle toteutus <em>SimpleHitCounter</em>. Toteutus merkitään annotaatiolla <em>@Service</em>. Annotaatiolle vinkkaamme sovelluskehykselle luokan SimpleHitCounter olevan luokka, jota sovelluskehyksen tulee hallinnoida.</p>

<pre class="sh_java">
package wad.hitcounter;

@Service
public class SimpleHitCounter implements HitCounter {
    private int count = 0;

    @Override
    public int getCount() {
        return count;
    }

    @Override
    public void incrementCount() {
        count++;
    }
}
</pre>

  <p>Luodaan seuraavaksi näkymä, jonka tehtävänä on kertoa käyntien määrä. Esimerkissämme näkymä sijaitsee tiedostossa <code>check.jsp</code>.</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;uno dos tres&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hits: ${hits}&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre> 

  <p>Näkymässämme on EL-tägi <em>hits</em>, jonka tehtävänä on näyttää osumien määrä. Luodaan lopuksi kontrolleri <em>HitController</em>, joka vastaanottaa pyynnöt osoitteeseen <em>hitme</em>, kutsuu HitCounter-palvelun tarjoamia metodeja, ja palauttaa lopuksi luodun mallin näkymää varten.</p>

<pre class="sh_java">
package wad.hitcounter;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HitController {

    @Autowired
    HitCounter hitCounter;

    @RequestMapping("hitme")
    public String incrementAndReturn(Model model) {
        hitCounter.incrementCount();
        model.addAttribute("hits", hitCounter.getCount());
        
        return "check";
    }
}
</pre>

  <p>Kontrolliluokassa <code>HitController</code> oleellisinta on <em>@Autowired</em> -annotaatio ja se, että käytämme <code>HitCounter</code>-rajapintaa. Sovelluskehys löytää rajapinnan <code>HitCounter</code> toteuttavan luokan <code>SimpleHitCounter</code>, jolla on annotaatio <em>@Service</em>. Sovelluskehys osaa annotaation ja toteutetun rajapinnan avulla päätellä että luokasta <code>SimpleHitCounter</code> tulee luoda ilmentymä kontrolliluokkaamme.</p>

  <p>Kun käynnistämme palvelun ja kutsumme hitme-sivua, näemme lopputuloksen. Alla olevassa kuvassa sivulla on käyty jo muutama kerta.</p>

  <div><img src="opas/nb-spring-hitcounter/hits.png" /></div>

  <p>Edellisen esimerkin pääosat:
    <ul>
      <li>Palveluiden ja kontrollilogiikan erotus toisistaan</li>
      <li>Käyttöliittymän ja kontrollilogiikan erotus toisistaan</li>
      <li>Palveluiden automaattinen käyttöön tuominen</li>
    </ul>
  </p>
    

<div class="tehtavat">
  <h3>10 * HitCounter</h3>
  
  <p>Muokkaa ylläolevaa sovellusta siten, että kasvatat osumien määrää kymmenellä yhden sijaan. Kun osumien määrä on yli 100, aloita laskeminen nollasta.</p>

  <p>Kun olet valmis, siirrä ohjelmasi users-koneelle, ja lähetä se tarkastettavaksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester2/">http://t-avihavai.users.cs.helsinki.fi/tester2/</a> olevassa palvelussa.</p>

  <h3>Spring-Chat</h3>

  <p>Päivitä viikolla 1 toteuttamasi Chat-sovellus Spring-sovelluskehystä käyttäväksi.</p>

  <p>Kun olet valmis, siirrä ohjelmasi users-koneelle, ja lähetä se tarkastettavaksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester2/">http://t-avihavai.users.cs.helsinki.fi/tester2/</a> olevaan palveluun.</p>

  <h3>Varastonhallinta</h3>

  <p>Tehdään ohjattuna yksinkertainen varastonhallinta. Varastonhallinta tarjoaa esineille lisäystoiminnallisuuden, poistotoiminnallisuuden ja listaustoiminnallisuuden HTML-käyttöliittymän kautta.</p>

  <p>Luo (tai kopioi aiempi) spring-web-projekti käyttöösi. Luo projektille pakkaus <code>wad.varasto</code>.</p>

  <h4>Domain</h4>

  <p>Suunnittelemme varastonhallintaa esineille. Esineillä on nimi ja paino. Lisätään jokaiselle esineelle lisäksi yksilöllinen tunniste. Luo luokka esine pakkaukseen <code>wad.varasto.domain</code>. Tähän pakkaukseen tulisivat muutkin ns. Domain-objektit, jotka kuvaavat sovellusaluetta.</p>

  <p>Kopioi allaoleva Esine-luokan runko käyttöösi. Lisää luokalle vielä getterit ja setterit.</p>

<pre class="sh_java">
// pakkaus

public class Esine {
    private static int LASKURI = 1;

    private int id;
    private String nimi;
    private Double paino;

    public Esine() {
        id = LASKURI++;
    }
    
    // getterit ja setterit
}
</pre>

  <h4>Näkymä</h4>

  <p>Seuraavaksi näkymä. Näkymässä on toiminnallisuus esineiden lisäämiseen, listaamiseen ja poistamiseen. JSP-sivulla on käytössä JSTL forEach-lausekkeiden tekemiseen.</p>

<pre class="sh_xml">
&lt;%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Varasto&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Varasto&lt;/h1&gt;

        &lt;h2&gt;Lisää esine&lt;/h2&gt;
        &lt;form action="lisaa" method="POST"&gt;
            Esineen nimi: &lt;input type="text" name="nimi"&gt;&lt;br/&gt;
            Esineen paino (desimaalilukuna): &lt;input type="text" name="paino"&gt;&lt;br/&gt;
            &lt;input type="submit" value="Lisää"&gt;            
        &lt;/form&gt;

        &lt;h2&gt;Esineet&lt;/h2&gt;
        &lt;ul&gt;
            &lt;c:forEach var="esine" items="${esineet}"&gt;
                &lt;li&gt;${esine.nimi}, paino ${esine.paino}, &lt;a href="poista/${esine.id}"&gt;poista&lt;/a&gt;&lt;/li&gt;
            &lt;/c:forEach&gt;
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

  <p><em>Käyttöliittymän voi rakentaa jo ennen kuin sovellus tarjoaa yhtäkään konkreettista toiminnallisuutta. Käyttöliittymädrafteista on hyvä lähteä eteenpäin myös asiakkaalle sovellusta esiteltäessä.</em></p>

  <h4>EsinePalvelu</h4>

  <p>Koodia tuottava kaverisi ehti määritellä EsinePalvelulle seuraavan rajapinnan.</p>

<pre class="sh_java">
package wad.varasto.service;

import java.util.List;
import wad.varasto.domain.Esine;

public interface EsinePalvelu {
    void lisaa(Esine esine);
    List&lt;Esine&gt; listaa();
    void poista(int esineId);
}
</pre>

  <p>Toteuta rajapinnan määrittelemät toiminnallisuudet toteuttava luokka <code>SimpleEsinePalvelu</code>. Käytä ArrayListiä esineiden tallettamiseen.</p>

<pre class="sh_java">
package wad.varasto.service;

import java.util.ArrayList;
import java.util.List;
import org.springframework.stereotype.Service;
import wad.varasto.domain.Esine;

@Service
public class SimpleEsinePalvelu implements EsinePalvelu {
    private List&lt;Esine&gt; esineet = new ArrayList();
   
    // ...
</pre>


  <p>Voit poistaa esineen listasta id-kentän avulla esimerkiksi seuraavasti.</p>

<pre class="sh_java">
        Esine esine = null;
        for (Esine e : esineet) {
            if (e.getId() == esineId) {
                esine = e;
                break;
            }
        }
        
        if (esine != null) {
            esineet.remove(esine);
        }
</pre>


<h4>VarastoController, listaaminen ja lisääminen</h4>

  <p>Alla on annettu pohja VarastoControllerille. VarastoControllerin tulee olla pakkauksessa <code>wad.varasto.controller</code>. Lisää pohjaan ensin metodi, joka kuuntelee osoitetta "listaa", ja lisää näkymälle vietävään malliin kaikki esineet. Käytä <code>EsinePalvelu</code>-rajapinnan määrittelemää <code>listaa</code>-metodia esineiden listaamiseen.</p>

  <p>Kun listaa-osoitetta kuunteleva palvelu on toteutettu, lisää metodi esineen lisäämiseksi. Käytä <code>EsinePalvelu</code>-rajapinnan määrittelemää <code>lisaa</code>-metodia. Lisää-palvelun tulee toimia osoitteessa "lisaa" ja se saa kuunnella vain POST-pyyntöjä. Kun esine on lisätty, ohjaa pyyntö listaa-osoitteeseen.</p>

<pre class="sh_java">
// importit

@Controller
public class VarastoController {

    @Autowired
    private EsinePalvelu esinePalvelu;

    @RequestMapping("*")
    public String nayta() {
        // oletus, ohjataan kaikki pyynnöt listaa-osoitteeseen
        return "redirect:/listaa";
    }
    
    //..

}
</pre>


<h4>VarastoController, poistaminen</h4>

  <p>Käyttöliittymälogiikkaa suunniteltaessa sinne päätyi linkki joka osoittaa poista/id -osoitteeseen, missä id on esineen tunnus.</p>

<pre class="sh_xml">
    &lt;a href="poista/${esine.id}"&gt;poista&lt;/a&gt;
</pre>

  <p>Polussa määriteltäviä muuttujia saa otettua kiinni @PathVariable-annotaation avulla. Toteuta metodi poistotoiminnallisuuden lisäämiseen seuraavan rungon pohjalta.</p>

<pre class="sh_java">
    @RequestMapping(value = "poista/{esineId}")
    public String poista(@PathVariable Integer esineId) {
        // ...
</pre>

  <p>Ylläoleva metodi kuuntelee polkuun "poista/{esineId}" tulevia pyyntöjä. Merkintä <code>{esineId}</code> kertoo sovelluskehyksellemme että polussa tulee sovellukselle tarpeellista tietoa. Tiedon saa käyttöön @PathVariable-annotaatiolla merkityllä muuttujalla. Muuttujalla on sama nimi kuin polkumäärittelyssä olevalla merkinnällä.</p>

  <p>Ohjaa käyttäjä poista-metodin suorituksen lopuksi "listaa"-osoitteeseen.</p>

  <p>Kun olet valmis, siirrä ohjelmasi users-koneelle, ja lähetä se tarkastettavaksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester2/">http://t-avihavai.users.cs.helsinki.fi/tester2/</a> olevassa palvelussa.</p>

</div>


<h2 id="palveluorientoituneet_arkkitehtuurit">Palvelukeskeiset arkkitehtuurit</h2>

  <p>Palvelukeskeisissä arkkitehtuureissä palvelut on toimivat itsenäisinä palveluina joita käytetään avoimien rajapintojen kautta. Tutustutaan aluksi palvelukeskeisiin arkkitehtuureihin muutaman tehtävän avulla.</p>

<div class="tehtavat">
  <h3>SOA HitCounter</h3>

  <p>Luodaan palvelu, joka käyttää keskitettyä palvelua kävijöiden laskemiseen. Palvelu toimii osoitteessa http://t-avihavai.users.cs.helsinki.fi/hitcounter/ -- kyselyiden rajapintana on HTTP.</p>

  <p>Apache HTTPComponents on kätevä kirjasto kyselyjen tekemiseen HTTP:n yli, joten otetaan se käyttöön. Saat sen ladattua lisäämällä projektiisi seuraavan riippuvuuden: </p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
            &lt;version&gt;4.1.2&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

  <p>HTTPComponents -kirjaston osoitteeseen <code>url</code> tehtävän pyynnön vastauksen voi lukea esimerkiksi seuraavasti:</p>

<pre class="sh_java">
    private String getResponseBody(String url) {
        HttpClient httpclient = new DefaultHttpClient();
        HttpGet httpget = new HttpGet(url);
        try {
            HttpResponse response = httpclient.execute(httpget);
            return readInputStream(response.getEntity().getContent());
        } catch (IOException ex) {
            Logger.getLogger(SimpleHitCounter.class.getName()).log(Level.SEVERE, null, ex);
        }

        return null;
    }

    private String readInputStream(InputStream is) {
        StringBuilder sb = new StringBuilder();
        Scanner sc = new Scanner(is);
        while (sc.hasNextLine()) {
            sb.append(sc.nextLine()).append("\n");
        }

        return sb.toString();
    }
</pre>
 
  <p>Tehtävä: Toteuta kävijöiden määrää laskeva web-sovellus, joka käyttää laskemiseen osoitteessa <code>http://t-avihavai.users.cs.helsinki.fi/hitcounter/{opiskelijanumerosi}</code> toimivaa palvelua. Jos opiskelijanumerosi on 012345678, tee pyynnöt osoitteeseen <code>http://t-avihavai.users.cs.helsinki.fi/hitcounter/012345678</code>. Palvelu palauttaa aina numeron, joka kertoo käyntien määrän.</p>

  <p>Toteuta sovelluksesi logiikka seuraavan rajapinnan alle kerrostetun arkkitehtuurin mukaisesti.</p>

<pre class="sh_java">
// pakkaus

public interface HitCounter {
    int getAndIncrementCount();
}
</pre>

  <p>Sovelluksen sivupohjana voit käyttää esimerkiksi seuraavaa.</p>

<pre class="sh_xml">
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;uno dos tres&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;SOA Hits: ${hits}&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre> 

  <p>Saat merkkijonomuodossa olevan numeron muunnettua numeroksi Integer-luokan parseInt-metodilla.</p>

  <p>Kun olet valmis, siirrä ohjelmasi users-koneelle, ja lähetä se tarkastettavaksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester2/">http://t-avihavai.users.cs.helsinki.fi/tester2/</a> olevassa palvelussa.</p>


  <h3>Tehdyt tehtävät</h3>

  <p>Toteuta palvelu, jota käytetään ensimmäisen viikon tehtävien tarkistamiseen. Käytä HTTP-rajapintaa osoitteessa http://t-avihavai.users.cs.helsinki.fi/tehdyt/{opiskelijanumerosi} toimivaa palvelua. Jos opiskelijanumerosi on 012345678, tee pyynnöt osoitteeseen http://t-avihavai.users.cs.helsinki.fi/tehdyt/012345678</p>

  <p>Käytä seuraavaa lomaketta oman palvelusi käyttöliittymän luomiseen.</p>

<pre class="sh_xml">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Tarkistus&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Viikon 1 tehtävien tarkistus&lt;/h1&gt;

        &lt;p&gt;Syötä opiskelijanumerosi ja paina nappia:&lt;/p&gt;
        &lt;form action="check" method="POST"&gt;
            &lt;input type="text" name="opiskelijanumero"&gt;
            &lt;input type="submit"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

  <p>Tulosta palvelun palauttamat tiedot palautus sellaisenaan käyttäjälle. </p>

  <p>Kun olet valmis, siirrä ohjelmasi users-koneelle, ja lähetä se tarkastettavaksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester2/">http://t-avihavai.users.cs.helsinki.fi/tester2/</a> olevassa palvelussa.</p>

  <h3>Käytetyt tunnit, viikko 2</h3>

  <p>Kirjaa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tunnit2" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tunnit2</a> olevaan palveluun toisen viikon materiaalin ja tehtävien parissa käyttämäsi aika.</p>

  <p>Koska usersilla on huomattava määrä käyttäjiä, sammuta palvelimesi komennolla <code>stop-tomcat</code> jos et käytä sitä muuhun.</p>

</div>

  <p>Palvelukeskeisissä arkkitehtuureissä järjestelmä rakentuu useammasta pienemmästä järjestelmästä. Osajärjestelmiä -- palveluita -- käytetään avoimien rajapintojen kautta, esimerkiksi HTTP:n yli. Omaa kolmannen osapuolen palveluihin perustuvaa järjestelmää rakennettaessa oleellista on järkevä arkkitehtuuri -- esimerkiksi kerrosarkkitehtuuri. Ylläolevissa tehtävissä <em>SOA Hitcounter</em> ja <em>Tehdyt tehtävät</em> kolmannen osapuolen palvelun käyttö tulee kapseloida -- sovelluslogiikkaa ei saa ikinä sotkea kontrolleriluokkiin.</p>

  <h3>REST</h3>

  <p>REST (representational state transfer) on ehkäpä yleisin lähestymistapa palvelukeskeisten arkkitehtuurien rakentamiseen. RESTin taustaidea on yksinkertainen tiedon hallinta web-osoitteita ja HTTP-protokollaa käyttäen. HTTP:n GET- ja POST-komentojen lisäksi REST-sovellukset käyttävät ainakin PUT ja DELETE-pyyntöjä. Esimerkiksi henkilöstörekisteri voitaisiin toteuttaa seuraavilla osoitteilla ja pyyntötavoilla.</p>
  
  <p>
    <ul>
      <li>GET osoitteeseen <em>/henkilo</em> palauttaa henkilöiden tiedot <em>tai</em> osajoukon henkilöiden tiedoista -- riippuen toteutuksesta.</li>
      <li>PUT osoitteeseen <em>/henkilo/{tunnus}</em> lisää tai muokkaa henkilön tietoja tietyllä tunnuksella. Henkilön tiedot lähetetään pyynnössä.</li>
      <li>DELETE osoitteeseen <em>/henkilo/{tunnus}</em> poistaa henkilön tietyllä tunnuksella.</li>
      <li>POST osoitteeseen <em>/henkilo</em> lisää uuden henkilön -- palvelimen vastuulla on päättää henkilölle tunnus. Henkilön tiedot lähetetään pyynnössä.</li>
    </ul>
  </p>
  

  <p>Oleellisia asioita RESTissä ovat resurssien nimentä web-osoitteita käyttäen sekä HTTP-protokollan tarjoamien pyyntötyyppien käyttö. Osoitteissa käytetään substantiivejä -- ei getHenkilo?id={tunnus} vaan /henkilo/{tunnus} -- ja pyynnöt kategorisoidaan pyyntötyyppien mukaan. DELETE-tyyppisessä pyynnössä poistetaan, PUT-tyyppisessä pyynnössä lisätään tai päivitetään, GET-tyyppisessä pyynnössä haetaan. Kuten normaalissakin HTTP-kommunikaatiossa, GET-pyyntöjen ei tule muuttaa käytössä olevien resurssien tietoja.</p>

  <p><strong>Käytettyjen resurssien muuttamisesta</strong> Aiemmin kurssilla on puhuttu siitä, että GET-pyynnöillä ei tule muuttaa tiedon tilaa. Tällä tarkoitetaan sitä, että riippumatta siitä kuinka monta kertaa pyyntö tehdään, lopputuloksen tulisi olla sama. GET-pyyntöjä voi käyttää turvallisesti myös tiedon poistamiseen -- yksi kutsu <em>ei REST</em>-tyyppiseen osoitteeseen <code>/poista/{tunnus}</code> tulee luoda sama lopputulos kuin tuhannen peräkkäisen pyynnön saaman osoitteeseen.</p>

  <p>REST on hyvä rajapinta olemassaolevien jo hieman ikääntyneiden palveluiden kapselointiin. Sovelluskehittäjä voi kehittää uuden käyttöliittymän, ja käyttää vanhaan sovellukseen liittyvää toiminnallisuutta REST-rajapinnan kautta. Palvelua luodessa palvelun toiminnallisuutta kuvaava dokumentaatio on oleellinen!</p>

  <p>REST-palvelut ovat hyvin yleisiä ja niiden luomiseen on tehty huomattava määrä apuohjelmia. Yksinkertaisen REST-palvelun voi luoda esimerkiksi suoraan olemassaolevasta tietokannasta -- kannattaa tutustua NetBeansin <em>Web Services</em> -osioon.</p>

  <p>Seuraavissa esimerkeissä käytetään allaolevaa luokkaa <code>Olut</code>.</p>

<pre class="sh_java">
public class Olut {

    private int id;
    private String name;

    public Olut() {
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj) {
        if(super.equals(obj)) {
            return true;
        }
        
        if(!(obj instanceof Olut)) {
            return false;
        }
        
        Olut o = (Olut) obj;
        return o.getId() == this.getId();
    }
    
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 43 * hash + this.id;
        return hash;
    }
}
</pre>

  <h4>Esimerkki: Yksinkertainen REST-rajapinta Springiä käyttäen</h4>

  <p>Alla on esimerkki REST-tyylisen rajapinnan avulla luodusta olutpalvelusta. Olutpalvelussa käyttäjä voi lisätä, muokata ja poistaa oluita.</p>

<pre class="sh_java">
@Controller
public class OlutController {

    @Autowired
    private OlutPalvelu olutPalvelu;

    @RequestMapping(method = RequestMethod.GET, value = "olut")
    public String listaaOluet(Model model) {
        model.addAttribute("oluet", olutPalvelu.listaaOluet());
        return "listaus";
    }

    @RequestMapping(method = RequestMethod.GET, value = "olut/{olutId}")
    public String naytaOlut(Model model, @PathVariable Integer olutId) {
        model.addAttribute("olut", olutPalvelu.annaOlut(olutId));
        return "olutnakyma";
    }

    @RequestMapping(method = RequestMethod.POST, value = "olut")
    public String lisaaOlut(@ModelAttribute Olut olut) {
        olut = olutPalvelu.lisaaOlut(olut);
        return "redirect:/olut/" + olut.getId(); // luotu olut
    }

    @RequestMapping(method = RequestMethod.DELETE, value = "olut/{olutId}")
    public String poistaOlut(@PathVariable Integer olutId) {
        olutPalvelu.poistaOlut(olutId);
        return "redirect:/olut";
    }

    @RequestMapping(method = RequestMethod.PUT, value = "olut/{olutId}")
    public String muokkaaTaiLisaaOlut(@ModelAttribute Olut olut, @PathVariable Integer olutId) {
        olut = olutPalvelu.muokkaaTaiLisaaOlut(olutId, olut);
        return "redirect:/olut/" + olut.getId(); // luotu tai muokattu olut
    }
}
</pre>


  <p>Kuten huomaat, REST-toteutuksemme käyttää aiemmin tutuksi tulleita kommunikointimenetelmiä. Osoitteet identifioivat resurssin, pyyntötavat halutun resurssin. Ylläolevan esimerkin ohjaustyyleistä kannattaa ottaa mallia myös omiin sovelluksiin. Kontrolleriluokan metodit -- kuten kontrollerit kokonaisuudessaan -- tulee pitää mahdollisimman pieninä. Varsinainen sovelluslogiikka tulee hoitaa muualla. </p>

  <p>Yllä käytetyn olutpalvelun rajapinta on seuraava.</p>

<pre class="sh_java">
public interface OlutPalvelu {
    Olut lisaaOlut(Olut olut);
    void poistaOlut(int tunnus);
    Olut muokkaaTaiLisaaOlut(int tunnus, Olut olut);
    Olut annaOlut(int tunnus);
    List&lt;Olut&gt; listaaOluet();
}
</pre>


<div class="tehtavat">
  <h3>Olutvarasto</h3>

  <p>Toteuta ylläolevan esimerkin näyttämä sovellus. HTTP-rajapinnan eli kuunneltavien osoitteiden ja pyyntötapojen tulee olla samat. Luo rajapinnalle <code>OlutPalvelu</code> oma toteutus, jossa oluet tallennetaan muistiin. Jokaiselle oluelle tulee luoda uniikki tunniste. Kun olet valmis, lisää sovellus users-palvelimelle ja tarkistuta se osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester3/">http://t-avihavai.users.cs.helsinki.fi/tester3/</a> olevassa palvelussa.</p>

  <p>Palvelusi tulee siis mm. kuunnella DELETE-tyyppisiä pyyntöjä osoitteisiin. Esim. DELETE-pyyntö osoitteeseen ".../olut/3" poistaa oluen tunnuksella 3.</p>

  <p>Jos palvelusi toimii osoitteessa http://t-avihavai.users.cs.helsinki.fi/Olutvarasto, ja esimerkiksi oluen lisääminen tulisi tehdä POST-pyynnöllä osoitteeseen http://t-avihavai.users.cs.helsinki.fi/Olutvarasto/olut, lähetä osoite http://t-avihavai.users.cs.helsinki.fi/Olutvarasto/ palautuksessa.</p>

  <p><strong>Huom!</strong> Käytä toteutuksessasi valmista <code>Olut</code>-luokkaa. Sinun ei tarvitse toteuttaa käyttöliittymää PUT ja DELETE -komentojen testaamiseen (puhtailla HTML-lomakkeilla tämä on käytännössä mahdotonta.) </p>

  <p>Ekalla viikolla tutuksi tulleesta komennosta <code>curl</code> on tässäkin hyötyä -- voit testata DELETE ja PUT -komentoja <code>curl</code>in avulla.</p>
</div>

<h3>Tiedonsiirtoformaatit</h3>

  <p>Palveluiden ei kannata palauttaa kokonaista HTML-sivua koska niitä usein käytetään pienempien osakokonaisuuksien käsittelemiseen. Osakokonaisuuksia varten tarvitsemme yleisesti hyväksyttyjä ja avoimia tiedonsiirtomuotoja. Yleisimmät tiedonsiirtomuodot tällä hetkellä ovat JSON ja XML, joista ensimmäisen suosio kasvaa jatkuvasti.</p>

<h4>JSON</h4>

  <p><a href="http://www.json.org/" target="_blank">JSON</a> (JavaScript Object Notation) on javascriptin käyttämä tiedonsiirtoformaatti. JSON mahdollistaa avain-arvo -parien ja listojen esittämisen. Avain-arvo -pari esitetään seuraavasti (alla esitetty ylläolevan luokan ilmentymä).</p>

<pre>
{"name":"Hacker-Pschorr Hefe Weisse","id":10}
</pre>

  <p>Listarakenteessa avain-arvo -parit esitetään pilkulla erotettuna hakasulkeiden (<code>[]</code>) sisällä.</p>

<pre>
[{"name":"Hacker-Pschorr Hefe Weisse","id":10},
 {"name":"Buttface Amber Ale","id":11},
 {"name":"Yellow Snow","id":12}]
</pre>

  <p>Arvot voivat olla merkkijonoja, numeroita, toisia avain-arvo -pareja, listoja, totuusarvoja ja tyhjiä null -elementtejä.</p>

  <p>Kuten suurin osa sovelluskehyksistä, Spring tarjoaa palvelun olioiden JSON-muotoon muuttamiseksi. Lisäämällä kontrolleriluokan metodille määrittelyn <em>@ResponseBody</em> kerromme vastauksen sisältävän vastausrungon -- tällöin näkymää ei luoda erillisellä näkymäkomponentilla (esim JSP-renderöijällä), vaan sovelluskehys päättelee muodon. Spring renderöi oliot oletuksena JSON-muodossa. Aiemmin näkemämme REST-esimerkki JSON-muotoisilla vastauksilla näyttäisi seuraavalta.</p>


<pre class="sh_java">
@Controller
public class OlutController {

    @Autowired
    private OlutPalvelu olutPalvelu;

    @RequestMapping(method = RequestMethod.GET, value = "olut")
    @ResponseBody
    public List&lt;Olut&gt; listaaOluet(Model model) {
        return olutPalvelu.listaaOluet();
    }

    @RequestMapping(method = RequestMethod.GET, value = "olut/{olutId}")
    @ResponseBody
    public Olut naytaOlut(Model model, @PathVariable Integer olutId) {
        return olutPalvelu.annaOlut(olutId);
    }

    @RequestMapping(method = RequestMethod.POST, value = "olut")
    public String lisaaOlut(@ModelAttribute Olut olut) {
        olut = olutPalvelu.lisaaOlut(olut);
        return "redirect:/olut/" + olut.getId(); // luotu olut
    }

    @RequestMapping(method = RequestMethod.DELETE, value = "olut/{olutId}")
    public String poistaOlut(@PathVariable Integer olutId) {
        olutPalvelu.poistaOlut(olutId);
        return "redirect:/olut";
    }

    @RequestMapping(method = RequestMethod.PUT, value = "olut/{olutId}")
    public String muokkaaTaiLisaaOlut(@ModelAttribute Olut olut, @PathVariable Integer olutId) {
        olut = olutPalvelu.muokkaaTaiLisaaOlut(olutId, olut);
        return "redirect:/olut/" + olut.getId(); // luotu tai muokattu olut
    }
}
</pre>

  <p>Muutimme vain näkymän palauttavien metodien toiminnallisuutta. Näkymään (JSP-sivulle) ohjauksen sijaan palautamme olion -- sovelluskehys hoitaa olion käännöksen JSON-dokumentiksi.</p>

  <p>Myös toiseen suuntaan kääntäminen onnistuu. Voimme vastaanottaa JSON-dokumentteja kontrollerimetodeissa määrittelemällä hyväksyttävän tiedostoformaatin (@RequestMapping-annotaation parametri consumes), sekä rakentaa pyynnön rungosta olio. Esimerkiksi aiemmin määritelty PUT-komento voidaan muokata seuraavanlaiseksi.</p>

<pre class="sh_java">
    @RequestMapping(method = RequestMethod.PUT, value = "olut/{olutId}", consumes="application/json")
    public String muokkaaTaiLisaaOlut(@RequestBody Olut olut, @PathVariable Integer olutId) {
        olut = olutPalvelu.muokkaaTaiLisaaOlut(olutId, olut);
        return "redirect:/olut/" + olut.getId(); // luotu tai muokattu olut
    }
</pre>

  <p>Ylläolevan muokkaaTaiLisaa-metodin toiminnallisuutta voi testata curl-komennon avulla seuraavasti (kenoviiva mahdollistaa komennon kirjoittamisen useammalle riville).</p>

<pre>
curl -X PUT -H "Content-Type: application/json; charset=utf-8" \
-d "{\"name\":\"Blithering Idiot\", \"id\":13}" \
http://palvelin-ja-sovellus/rest/olut/13
</pre>


<div class="tehtavat">
  <h3>JSON Olutvarasto</h3>

  <p>Laajenna edellistä tehtävää tai toteuta Olutvarasto siten, että 
<ul>
<li>GET-pyyntö osoitteeseen <code>olut/{olutId}.json</code> palauttaa tietyllä id:llä merkityn oluen JSON-muodossa</li>
<li>GET-pyyntö osoitteeseen <code>olut/{olutId}</code> palauttaa JSP-näkymän jossa näytetään yksittäisen oluen tiedon</li>
<li>GET-pyyntö osoitteeseen <code>olut.json</code> palauttaa JSON-muotoisen listan kaikista olemassaolevista oluista</li>
<li>GET-pyyntö osoitteeseen <code>olut</code> palauttaa JSP-näkymän jossa kaikki oluet ovat listattuna</li>
<li>JSON-dataa sisältävä PUT-pyyntö osoitteeseen <code>olut/{olutId}.json</code> muokkaa tunnuksella {olutId} olevan oluen tietoja</li>
<li>POST-pyyntö osoitteeseen <code>olut</code> lisää uuden oluen normaalin POST-datan perusteella</li>
<li>POST-pyyntö osoitteeseen <code>olut.json</code> lisää uuden oluen POST-pyynnön sisältämän JSON-datan perusteella</li>
</ul>
</p>

  <p>Muu toiminnallisuus kuten edellä olevassa tehtävässä -- PUT ja POST-komentojen tulee myös toimia. Tehtävä olettaa että POST-pyynnöillä lähetettäville oluille luodaan uudet tunnukset jos vastaavaa olutta ei ole jo olemassa. Kannattaa käyttää vertailuun myös name-kenttää pelkän id:n lisäksi.</p>
  
  <p>Kun olet valmis, lisää sovellus users-palvelimelle ja tarkistuta se osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester3/">http://t-avihavai.users.cs.helsinki.fi/tester3/</a> olevassa palvelussa..</p>

  <p><strong>Huom!</strong> Käytä toteutuksessasi valmista <code>Olut</code>-luokkaa.</p>

  <p>Lisää myös Jackson JSON-riippuvuus Maven-konfiguraatioosi (tämä on joissain palvelimissa valmiiksi mukana).</p>
<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-jaxrs&lt;/artifactId&gt;
            &lt;version&gt;1.9.3&lt;/version&gt;
        &lt;/dependency&gt;
</pre>
</div>


  <h4>XML</h4>

  <p>XML on rakenteinen dataformaatti, jota kontrolloidaan elementtien avulla. XML-dokumentilla on vain yksi juurielementti.</p>

<pre class="sh_xml">
&lt;olut&gt;
  &lt;id&gt;10&lt;/id&gt;
  &lt;nimi&gt;Hacker-Pschorr Hefe Weisse&lt;/nimi&gt;
&lt;/olut&gt;
</pre>

  <p>Elementtejä voidaan sisällyttää toisiin elementteihin.</p>


<pre class="sh_xml">
&lt;oluet&gt;
  &lt;olut&gt;
    &lt;id&gt;10&lt;/id&gt;
    &lt;nimi&gt;Hacker-Pschorr Hefe Weisse&lt;/nimi&gt;
  &lt;/olut&gt;
  &lt;olut&gt;
    &lt;id&gt;11&lt;/id&gt;
    &lt;nimi&gt;Buttface Amber Ale&lt;/nimi&gt;
  &lt;/olut&gt;
  &lt;olut&gt;
    &lt;id&gt;12&lt;/id&gt;
    &lt;nimi&gt;Yellow Snow&lt;/nimi&gt;
  &lt;/olut&gt;
&lt;/oluet&gt;
</pre>

  <p>Kuten JSON-muotoon käännettäessä, myös XML-muotoon kääntäminen tapahtuu automaattisesti. Olioiden XML-muotoon kääntämiseksi tarvitaan JAXB (<em>Java XML Binding</em>) annotaatiot käännettävälle luokalle. Olut-luokan XML-muotoon kääntämiseksi tarvitsemme annotaatiot <em>@XmlRootElement</em>, joka kertoo dokumentin juurielementin, ja <em>@XmlElement</em>, joka kertoo elementin.</p>

<pre class="sh_java">
@XmlRootElement
public class Olut {
    private int id;
    private String name;

    public Olut() {
    }

    public int getId() {
        return id;
    }

    @XmlElement
    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    @XmlElement
    public void setName(String name) {
        this.name = name;
    }
}
</pre> 

  <p>Tämän lisäksi tarvitsemme erillisen luokan monikkoa varten -- emme voi tulostaa olutlistaa Javan List-rajapinnan avulla. Määritellään erillinen juurielementti <code>OlutLista</code>:</p>

<pre class="sh_java">
@XmlRootElement(name = "oluet")
public class OlutLista {

    private List&lt;Olut&gt; olut;

    public OlutLista() {
    }

    public void setOlut(List&lt;Olut&gt; olut) {
        this.olut = olut;
    }

    public List&lt;Olut&gt; getOlut() {
        return olut;
    }
}
</pre> 

  <p>GET-pyyntöjä vastaanottaviin kontrolliluokkiin ei tarvitse tehdä muutoksia. Jos haluamme ottaa vastaan XML-muotoista dataa, voimme määritellä <code>@RequestMapping</code>-annotaation consumes parametrille arvon <code>application/xml</code>.</p>


<pre class="sh_java">
    @RequestMapping(method = RequestMethod.PUT, value = "olut/{olutId}", consumes="application/xml")
    public String muokkaaTaiLisaaOlut(@RequestBody Olut olut, @PathVariable Integer olutId) {
        olut = olutPalvelu.muokkaaTaiLisaaOlut(olutId, olut);
        return "redirect:/olut/" + olut.getId(); // luotu tai muokattu olut
    }
</pre>

  <p>Toiminnallisuutta voi testata taas curl-komennon avulla. Esimerkiksi seuraava lähettäisi <em>He'brew: The Chosen Beer</em> nimisen oluen palveluun.</p>

<pre>
curl -X PUT -H "Content-Type: application/xml; charset=utf-8" \
-d "&lt;olut&gt;&lt;name&gt;He'brew: The Chosen Beer&lt;/name&gt;&lt;id&gt;18&lt;/id&gt;&lt;/olut&gt;" \
http://palvelin-ja-sovellus/olut/18
</pre>

  <p><em>Käytämme tällä kurssilla JSON-muotoista dataa.</em></p>


  <h2>Merkistöongelmista</h2>

  <p>Käyttöjärjestelmät ja selaimet haluavat usein ajaa kaikkia käyttämään niiden määrittelemää merkistökoodausta. Haluamme oikeasti käyttää UTF-8 -merkistöä tai vastaavaa. Javan HTTP-implementaatio tarjoaa filtteritoiminnallisuuden, jonka avulla jokainen pyyntö pystytään käsittelemään ennen kuin se päätyy sovellukselle. Vastaavasti filttereillä pystytään vaikuttamaan myös vastauksen sisältöön. Spring-sovelluskehys tarjoaa filtterin, joka muuttaa kaikki pyynnöt UTF-8 merkkisiksi. Filtterin saa päälle lisäämällä sen konfiguraation web.xml-tiedoston alkuun.</p>

<pre class="sh_xml">
    &lt;!-- Filtteri: Kaikki pyynnöt utf-8:ksi --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encoding-filter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.springframework.web.filter.CharacterEncodingFilter
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding-filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
</pre> 

  <p>Jatkossa -- kunnes toisin sanotaan -- toteuttamiemme Spring-projektien web.xml-tiedosto on siis seuraavanlainen (display-name -kenttää saa toki vaihtaa). </p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee           
                http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;
                    
    &lt;display-name&gt;spring-sovellus&lt;/display-name&gt;
    
    &lt;!-- Filtteri: Kaikki pyynnöt utf-8:ksi --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encoding-filter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.springframework.web.filter.CharacterEncodingFilter
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
            &lt;param-value&gt;true&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encoding-filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    
    &lt;!-- Front controller --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;spring-front-controller&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/spring-context.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;spring-front-controller&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    
    &lt;session-config&gt;
        &lt;session-timeout&gt;
            30
        &lt;/session-timeout&gt;
    &lt;/session-config&gt;
    
    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;
&lt;/web-app&gt;
</pre>


  <h2>Tietovarastot</h2>

  <p>Tähänastiset sovelluksemme ovat hukanneet käyttämänsä tiedot sovelluksen sammussa. Tämä johtuu siitä että emme ole varastoineet tietoa. Web-sovelluskehityksessä yleisin tapa tiedon varastointiin on relaatiotietokannan käyttäminen olemassaolevan rajapinnan kautta. Kuten sovelluslogiikkaa kehittäessä, haluamme kapseloida myös tietovarastokerroksen.</p>

  <p>Lähes kaikki tietovarastot tarjoavat ns. CRUD-toiminnallisuuden (<em>create, read, update, delete</em>), jonka lisäksi käyttäjä voi luoda sovelluskohtaisia apuvälineitä.</p>

  <h3>DAO Pattern</h3>

  <p>DAO (<em>Data Access Object</em>) pattern on suunnittelumalli, jossa varastointimekanismi kapseloidaan sovelluslogiikalle näkymättömäksi. Tietovarastokerrosta käytetään DAO-rajapinnan yli (<em>@Repository</em> annotaatio Spring-sovelluskehyksessä) kuten normaaleja palveluita. Lopullinen tiedon tallennuspaikka riippuu toteutuksesta -- rajapinnan käyttäjä ei siitä tarvitse välittää. Toteutetaan aiemmin esitellylle olutvarastolle oma tietovarastorajapinta ja siihen liittyvä toteutus. </p>

<pre class="sh_java">
public interface OlutDao {
    void persist(Olut olut);
    void remove(Olut olut);
    Olut findById(int id);
}
</pre>

  <p>Olemme kiinnostuneita aluksi kolmesta toiminnallisuudesta. Lisääminen (persist), poistaminen (remove) ja avaimen perusteella etsiminen (findById) -- perinteisen CRUD-nimeämisen sijaan web-sovelluksissa käytetään yleensä yllä esitettyä nimeämistyyliä.</p>

  <p>Luodaan ensimmäinen toteutus, jota voimme käyttää oluiden tallentamiseen. Toteutuksemme kapseloi yksinkertaisen listarakenteen.</p>

<pre class="sh_java">
@Repository
public class ListaOlutDao implements OlutDao {

    private Map&lt;Integer, Olut&gt; olutMap = new TreeMap&lt;Integer, Olut&gt;();

    @Override
    public void persist(Olut olut) {
        olutMap.put(olut.getId(), olut);
    }

    @Override
    public void remove(Olut olut) {
        olutMap.remove(olut.getId());
    }

    @Override
    public Olut findById(int id) {
        return olutMap.get(id);
    }
}
</pre>


  <p>Ylläolevan toteutuksen voi lisätä Spring-sovelluskehyksen palveluluokkiin <em>@Autowired</em>-annotaation avulla.</p>

<pre class="sh_java">
@Service
public class OlutPalvelu {

    @Autowired
    private OlutDao olutDao;

    ...
</pre>

  <p>Uutta -- samaa rajapintaa käyttävää toteutusta -- kehittäessämme meidän tulee määritellä palvelulle yksilöivä nimi automaattista hakemista varten. Esimerkiksi tiedostoja käyttävä luokka <code>TiedostoOlutDao</code>, jonka toteutukset on piilotettu, voidaan yksilöidä <code>@Repository</code>-annotaatioon annettavalla arvolla.</p>

<pre class="sh_java">
@Repository(value="tiedosto")
public class TiedostoOlutdao implements OlutDao {
    ...

    @Override
    public void persist(Olut olut) {
        ...
    }

    @Override
    public void remove(Olut olut) {
        ...
    }

    @Override
    public Olut findById(int id) {
        ...
    }   
}
</pre>

  <p>Kun saman rajapinnan toteuttaa useampi palvelu, tulee jokaisella palvelulla olla tunnus. Lisätään myös listalle oma tunnus.</p>

<pre class="sh_java">
@Repository(value="lista")
public class ListaOlutDao implements OlutDao {
    ...
</pre>

  <p>Nyt voimme käyttää <code>@Autowired</code>-annotaation lisäksi <code>@Qualifier</code>-annotaatiota, jolla kerrotaan mikä toteutus halutaan käyttöön. Alla käytössä <code>ListaOlutDao</code>.</p>

<pre class="sh_java">
@Service
public class OlutPalvelu {

    @Autowired
    @Qualifier("lista")
    private OlutDao olutDao;

    ...
</pre>

<p>Dao-rajapintojen käyttöä helpotetaan yleensä perinnän avulla. Alla on esitetty geneeristä rajapintaa käyttävä Huoneen hallinta.</p> 

<pre class="sh_java">
public interface DAO&lt;T&gt; {
    public void create(T instance);
    public T read(int id);
    public void delete(T instance);
    public T update(T instance);
    public List&lt;T&gt; list();
}
</pre>

<pre class="sh_java">

public abstract class JPADao&lt;T&gt; implements DAO&lt;T&gt; {

    @PersistenceContext
    EntityManager entityManager;

    private Class clazz;
    
    public JPADao(Class clazz) {
        this.clazz = clazz;
    }   
    
    @Override
    public void create(T instance) {
        entityManager.merge(instance);
    }

    @Override
    public T read(int id) {
        return (T)entityManager.find(clazz, id);
    }

    @Override
    public void delete(T instance) {
        entityManager.remove(instance);
    }

    @Override
    public T update(T instance) {
        return entityManager.merge(instance);
    }
    
    @Override
    public List&lt;T&gt; list() {
        // JPA:ssa on myös ohjelmallinen API kyselyjen raketamiseen
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery query = criteriaBuilder.createQuery(clazz);
        return entityManager.createQuery(query).getResultList();
    }
}
</pre>

<pre class="sh_java">
@Repository
public class JPAHuoneDao extends JPADao&lt;Huone&gt; implements HuoneDao  {

    public JPAHuoneDao() {
        super(Huone.class);
    }
}
</pre>

<h3>Relaatiotietokannat ja ORM</h3>

  <p>Relaatiotietokantojen käsittelyyn on kehitetty joukko sovelluksia joista nimekkäin lienee Hibernate. Oracle/Sun standardoi olioiden tallentamisen relaatiotietokantoihin <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank">JPA</a> (<em>Java Persistence API</em>) -standardilla. JPA:n toteuttavat kirjastot (esim. <a href="http://www.hibernate.org/" target="_blank">Hibernate</a>, <a href="http://www.eclipse.org/eclipselink/" target="_blank">EclipseLink</a>) abstrahoivat relaatiotietokannan, ja mahdollistavat kyselyjen tekemisen suoraan ohjelmakoodista.</p>

  <p>ORM-työkalut (<em>Object Relational Mapping</em>) tarjoavat toiminnallisuutta tietokantataulujen luomiseen suoraan luokkamäärittelyjen perusteella. Työkalut hallinnoivat luokkien välisiä viittauksia ja ylläpitävät mm. tietokannan eheyttä. Käyttäjän vastuulle jää sovellukselle tarpeellisten kyselyiden toteuttaminen niiltä osin kun niitä ei tarjota valmiiksi.</p>

  <h4>Entity</h4>

  <p>Tietokantaan tallennettavat luokat tulee annotoida <code>@Entity</code>-annotaatiolla. Annotaation <code>@Entity</code> lisäksi luokalle tulee määritellä avainkenttä <code>@Id</code>-annotaation avulla. Alla esimerkki luokasta <code>Esine</code>.</p>

<pre class="sh_java">
import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Esine implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    private int id;
    private String nimi;
    private Double paino;

    public Esine() {
    }

    public int getId() {
        return id;
    }

    public String getNimi() {
        return nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }

    public Double getPaino() {
        return paino;
    }

    public void setPaino(Double paino) {
        this.paino = paino;
    }
}
</pre>

  <p>JPA voi luoda tietokantataulut automaattisesti annettujen määrittelyjen perusteella. Toisaalta, on myös mahdollista määritellä luokat tietyn tietokantaskeeman mukaisiksi. Annotaatioiden <code>@Entity</code> ja <code>@Column</code> avulla voimme antaa luokan attribuuteille -- tietokantataulun sarakkeille -- tarkempia määreitä.</p>

<pre class="sh_java">
...

@Entity(name="ESINE")
public class Esine implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    @Column(name="ID")
    private int id;
    @Column(name="NIMI", nullable=false)
    private String nimi;
    @Column(name="PAINO")
    private Double paino;
   
    ...
</pre>

  <p>Entiteettien käyttö tapahtuu <code>EntityManager</code>-rajapinnan avulla.</p>

  <p><strong>Entiteetteihin viittaaminen</strong></p>

  <p>Toisiin entiteetteihin viittaaminen tapahtuu kuten normaalistikin Javalla ohjelmoidessa. Osallistumisrajoitteet -- yksi moneen (<em>one to many</em>), moni yhteen (<em>many to one</em>), moni moneen (<em>many to many</em>) lisätään annotaatioiden avulla. Luodaan esimerkiksi luokka <code>Henkilo</code>, joka voi omistaa joukon esineitä. Kukin esine on vain yhden henkilön omistama -- suhde siis yksi moneen -- annotaatio <code>@OneToMany</code>.</p>

<pre class="sh_java">
@Entity
public class Henkilo implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    private int id;
    private String nimi;
    @OneToMany
    private List&lt;Esine&gt; esineet;

    ...
</pre>

  <p>Yllä olevaa esimerkkiä käytettäessä luokalle Esine luodaan tietokantatauluun automaattisesti sarake, johon tallennetaan omistavan henkilön id.</p>

  <p>Moni-moneen yhteys tapahtuu tietokantatauluja suunniteltaessa liitostaulun avulla. JPA:ssa moni-moneen yhteydet määritellään annotaatiolla <code>@ManyToMany</code>. Tällöin yhteys tulee merkitä kummallekin puolelle. Jos henkilö voi omistaa useita esineitä, ja esineellä voi olla useita omistajia, toteutus on seuraavanlainen.</p>

<pre class="sh_java">
@Entity
public class Henkilo implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    private int id;
    private String nimi;
    @ManyToMany
    private List&lt;Esine&gt; esineet;
    ...
</pre>

<pre class="sh_java">
@Entity
public class Esine implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    private int id;
    private String nimi;
    private Double paino;
    @ManyToMany(mappedBy = "esineet")
    private List&lt;Henkilo&gt; henkilot;
</pre>

  <p>Yllä oleva määritelmä luo liitostaulun Esine- ja Henkilötaulun välille. Esine-luokassa olevassa @ManyToMany-annotaatiossa oleva parametri <code>mappedBy = "esineet"</code> kertoo että Esine-luokan <code>henkilot</code>-kenttä kytketään luokan Henkilo listaan <code>esineet</code>.</p>

  <h4>EntityManager</h4>

  <p>EntityManager hallinnoi entiteettejä ja niiden tallennusta tietokantaan. Sovelluskehys -- tai sovelluskehittäjä -- luo EntityManagerin tarpeen vaatiessa. EntityManager tarjoaa joukon palveluita, oleellisimmat meidän kannalta ovat lisääminen (komennot <code>persist</code> ja <code>merge</code>), poistaminen (komento <code>remove</code>) ja hakeminen (komento <code>find</code>). EntityManager injektoidaan sovellukselle <code>@PersistenceContext</code>-annotaation avulla. Olettaen että aiemmin nähty Olut-luokka on annotoitu @Entity-annotaatiolla, voisimme toteuttaa OlutDao-rajapinnan seuraavasti.</p>

<pre class="sh_java">
@Repository("db")
public class DbOlutDao implements OlutDao {
    
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public void persist(Olut olut) {
        entityManager.persist(olut);
    }

    @Override
    public void remove(Olut olut) {
        entityManager.remove(olut);
    }

    @Override
    public Olut findById(int id) {
        return entityManager.find(Olut.class, id);
    }    
}
</pre>

  <p>Yllä oletamme että transaktioiden hallinta tapahtuu toisaalla -- tästä lisää myöhemmin Springin yhteydessä.</p>

  <p>EntityManager-olioiden konfigurointi tapahtuu persistence.xml-tiedoston avulla. Persistence.xml listaa hallinnoitavat entiteetit, sekä määrittelee käytetylle JPA-rajapinnan toteutukselle tarpeellisia parametreja. </p>

  <h4>persistence.xml</h4>
  
  <p>JPA-konfiguraatio määritellään tiedostossa <code>persistence.xml</code>, joka listaa hallinnoitavat entiteetit sekä määrittelee käytetylle JPA-rajapinnan toteutukselle tarpeellisia parametreja. Alla esimerkkikonfiguraatio, jossa käytössä on EclipseLink.</p>
  
<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.0" 
	     xmlns="http://java.sun.com/xml/ns/persistence" 
	     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	     xsi:schemaLocation="http://java.sun.com/xml/ns/persistence 
				 http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;
  &lt;persistence-unit name="persistenceUnitEclipseLink" transaction-type="RESOURCE_LOCAL"&gt;
    &lt;-- käytetty JPA-toteutus //--&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;

    &lt;-- käytetylle JPA-toteutukselle annettavat parametrit //--&gt;
    &lt;properties&gt;
      &lt;property name="showSql" value="true"/&gt;
      &lt;property name="eclipselink.ddl-generation" value="drop-and-create-tables"/&gt;
      &lt;property name="eclipselink.ddl-generation.output-mode" value="database"/&gt;
      &lt;property name="eclipselink.weaving" value="false"/&gt;
      &lt;property name="eclipselink.logging.level" value="FINE"/&gt;
    &lt;/properties&gt;

    &lt;-- hallinnoitavat entiteettiluokat //--&gt;
    &lt;class&gt;wad.varasto.domain.Esine&lt;/class&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>

  <h4>JPQL</h4>

  <p><a href="http://en.wikipedia.org/wiki/Java_Persistence_Query_Language" target="_blank">JPQL</a> (<em>Java Persistence Query Language</em> on kyselykieli, jonka avulla @Entity-annotaatioilla merkittyjen luokkien instansseja voidaan hakea tietokannasta. Kyselyt ovat SQL-kyselyiden kaltaisia. JPQL ei tue kaikkia SQL-kielen ominaisuuksia -- EntityManager-ilmentymän avulla on mahdollista kirjoittaa myös puhtaita SQL-kyselyitä. Yksinkertainen kaikki Esine-oliot listaava kysely on seuraavanlainen.</p>

<pre>
SELECT e FROM Esine e
</pre>

  <p>EntityManager-luokan ilmentymän avulla voimme hakea listan esineitä vastaavasti.</p>

<pre class="sh_java">
String kysely = "SELECT e FROM Esine e";
Query q = entityManager.createQuery(kysely);
List&lt;Esine&gt; esineet = q.getResultList();
</pre>

  <p>Ehtojen lisääminen tapahtuu parametrien avulla</p>

<pre class="sh_java">
String kysely = "SELECT e FROM Esine e WHERE e.nimi = :nimi";
Query q = entityManager.createQuery(kysely);
q.setParameter("nimi", "vaasi");
List&lt;Esine&gt; esineet = q.getResultList();
</pre>


<h3>Transaktioiden hallinta</h3>

  <p>Lähes kaikki relaatiotietokannat toteuttavat <a href="http://en.wikipedia.org/wiki/ACID" target="_blank">ACID</a>-sääntöjä noudattavan transaktiomallin. Kukin palvelutason toiminto -- esimerkiksi poistaminen -- suoritetaan omassa transaktiossaan. Web-sovelluksia kehitettäessä vastuu transaktioidenhallinnasta voidaan antaa palvelimelle (globaali transaktionhallinta), tai hallinnoida transaktioita itse tai sovelluskehyksen avulla (lokaali transaktionhallinta). Globaali transaktionhallinta toteutetaan yleensä <a href="http://en.wikipedia.org/wiki/Java_Transaction_API" target="_blank">JTA</a> (<em>Java Transaction API</em>)-rajapinnan avulla. Käytämme kurssilla lokaalia transaktionhallintaa, sillä mm. Tomcat ei tue JTA-rajapintaa suoraan.</p>

  <p>Springissä transaktioiden määrittely tapahtuu <code>@Transactional</code>-annotaation avulla, jonka avulla metodi voidaan määritellä transaktion sisällä suoritettavaksi. Annotaatiolle voidaan määritellä parametrien avulla ylimääräistä toiminnallisuutta -- esimerkiksi kyselyn tyyppi. Esimerkiksi vain lukemista toteuttavat metodit kannattaa annotoida <code>@Transactional(readOnly=true)</code>, jolloin sovelluskehys pystyy optimoimaan kyselyjen suoritusta. Transaktiot määritellään yleensä palvelutasolla, esimerkiksi Esineen poistaminen.</p>

<pre class="sh_java">
    @Override
    @Transactional
    public void poista(int esineId) {
        Esine esine = varastoDao.read(esineId);
        if (esine != null) {
            varastoDao.remove(esine);
        }
    }
</pre>

  <h3>Spring ja ORM</h3>

  <p>Seuraavaksi nidotaan edeltävä kappale yhteen. Alla listatut konfiguraatiot voi ladata myös GitHubista osoitteesta <a href="https://github.com/avihavai/wad-2012/tree/master/dbvarasto" target="_blank">https://github.com/avihavai/wad-2012/tree/master/dbvarasto</a>. Projektin saa ZIP-tiedostona klikkaamalla sivun vasemmassa ylälaidassa olevaa ZIP-linkkiä.</p>

  <h4>Konfiguraatio</h4>

  <p><strong>spring-context.xml</strong></p>

  <p>Alla <code>spring-context.xml</code> konfiguraatio. Määrittelemme käyttöömme muistiin ladattavan tietokannan (HSQLDB). EntityManager-luokat saadaan EntityManagerFactory-oliolta, jonka toteuttajana on EclipseLink. Tiedosto <code>persistence.xml</code> löytyy classpathista. Lisäksi, haluamme että voimme hallinnoida transaktioita annotaatioiden avulla.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:jdbc="http://www.springframework.org/schema/jdbc"
       xsi:schemaLocation="
        http://www.springframework.org/schema/mvc 
          http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
        http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context 
          http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/tx 
          http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
        http://www.springframework.org/schema/jdbc 
           http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd"&gt;

    &lt;!-- DispatcherServletin (front-controllerin) konfiguraatio, jolla määritellään pyynnön kulku. --&gt;
 
    &lt;!-- Sovelluksemme lähdekooditiedostot sijaitsevat pakkauksessa wad tai sen alipakkauksissa--&gt;
    &lt;context:component-scan base-package="wad" /&gt;

    &lt;!-- Käytetään Spring MVC:tä annotaatioiden avulla --&gt;
    &lt;mvc:annotation-driven /&gt; 
       
    &lt;!-- Mahdollistetaan konfigurointi annotaatioilla --&gt;
    &lt;context:annotation-config /&gt;
    
    &lt;!-- Käytetään muistiin ladattavaa tietokantaa --&gt;
    &lt;jdbc:embedded-database id="dataSource" type="HSQL"/&gt;

    &lt;!-- Käytetään EclipseLinkkiä JPA-toteutuksena, määritellään myös persistence.xml-tiedoston sijainti --&gt;
    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;!-- älä muuta persistence.xml -tiedoston sijaintia  --&gt;
        &lt;property name="persistenceXmlLocation" value="classpath:persistence.xml" /&gt;
        &lt;property name="persistenceUnitName" value="persistenceUnitEclipseLink" /&gt; 
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;property name="jpaVendorAdapter"&gt;
            &lt;bean class="org.springframework.orm.jpa.vendor.EclipseLinkJpaVendorAdapter" /&gt;
        &lt;/property&gt;
        &lt;property name="loadTimeWeaver"&gt; 
            &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver" /&gt; 
        &lt;/property&gt;
    &lt;/bean&gt;
    
    &lt;!-- Hallinnoidaan transaktioita automaattisesti --&gt;
    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
        &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;
    
    &lt;!-- Käytetään geneerisiä poikkeuksia --&gt;
    &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;
    &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;
    
    &lt;!-- Ohjataan näkymät JSP-sivuille --&gt;
    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="prefix" value="/WEB-INF/view/" /&gt;
        &lt;property name="suffix" value=".jsp" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</pre>

  <p><strong>pom.xml</strong></p>

  <p>Lisätään aiempaan Project Object Model-konfiguraatioomme riippuvuuksia tietokantayhteyden hallintaan. Näiden lisäksi helpotimme versiointia lisäämällä <code>properties</code>-elementin, sekä lisäsimme sijainteja riippuvuuksien noutamiseen.</p> 

<pre class="sh_xml">
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
            http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;wad&lt;/groupId&gt;
    &lt;artifactId&gt;dbvarasto&lt;/artifactId&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;name&gt;dbvarasto&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;
    
    &lt;properties&gt;
        &lt;spring-version&gt;3.1.0.RELEASE&lt;/spring-version&gt;
        &lt;eclipselink-version&gt;2.3.2&lt;/eclipselink-version&gt;
        &lt;eclipselink-jpa-version&gt;2.0.0&lt;/eclipselink-jpa-version&gt;
        &lt;hsqldb-version&gt;1.8.0.10&lt;/hsqldb-version&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;!-- spring --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring-version}&lt;/version&gt;
        &lt;/dependency&gt;
        
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring-version}&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;!-- käytetään simple logging facadea commons logging-kirjaston sijaan --&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
                    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;!-- servlet ja jsp api --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- jstl --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;jstl&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
        
        &lt;!-- cglib @configuration-konffeille --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cglib&lt;/groupId&gt;
            &lt;artifactId&gt;cglib&lt;/artifactId&gt;
            &lt;version&gt;2.2.2&lt;/version&gt;
        &lt;/dependency&gt; 
        
        &lt;!-- db --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;
            &lt;version&gt;${spring-version}&lt;/version&gt;
        &lt;/dependency&gt;
        
        &lt;dependency&gt;
            &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
            &lt;artifactId&gt;eclipselink&lt;/artifactId&gt;
            &lt;version&gt;${eclipselink-version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt; 
            &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
            &lt;artifactId&gt;javax.persistence&lt;/artifactId&gt;
            &lt;version&gt;${eclipselink-jpa-version}&lt;/version&gt;
        &lt;/dependency&gt;
               
            
        &lt;dependency&gt;
            &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
            &lt;version&gt;${hsqldb-version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;${spring-version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt;
            &lt;version&gt;${spring-version}&lt;/version&gt;
        &lt;/dependency&gt;
            
        &lt;!-- loggauskirjastot --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.6.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
            &lt;version&gt;1.6.1&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;1.6.1&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.16&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.3.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.6&lt;/source&gt;
                    &lt;target&gt;1.6&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    
    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;java.net repo&lt;/id&gt;
            &lt;url&gt;http://download.java.net/maven/2/&lt;/url&gt;
            &lt;layout&gt;default&lt;/layout&gt;
        &lt;/repository&gt;
        
        &lt;repository&gt;
            &lt;id&gt;jboss repo&lt;/id&gt;
            &lt;url&gt;http://repository.jboss.com/maven2&lt;/url&gt;
        &lt;/repository&gt;
        
        &lt;repository&gt;
            &lt;id&gt;eclipselink repo&lt;/id&gt;
            &lt;url&gt;http://download.eclipse.org/rt/eclipselink/maven.repo&lt;/url&gt;            
        &lt;/repository&gt;
    &lt;/repositories&gt;
&lt;/project&gt;
</pre>

  <p><strong>persistence.xml</strong></p>

  <p>Tiedosto <code>persistence.xml</code> sisältää tarkemmat määrittelyt tallennettaviin tiedostoihin liittyen. Alla olevassa konfiguraatiossa hallinnoimme vain luokkaa <code>wad.varasto.domain.Esine</code>.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.0" xmlns="http://java.sun.com/xml/ns/persistence" 
                              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                              xsi:schemaLocation="http://java.sun.com/xml/ns/persistence                 
                                  http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;
  &lt;persistence-unit name="persistenceUnitEclipseLink" transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;wad.varasto.domain.Esine&lt;/class&gt;
    &lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes&gt;
    &lt;properties&gt;
      &lt;property name="showSql" value="true"/&gt;
      &lt;property name="eclipselink.ddl-generation" value="drop-and-create-tables"/&gt;
      &lt;property name="eclipselink.ddl-generation.output-mode" value="database"/&gt;
      &lt;property name="eclipselink.weaving" value="false"/&gt;
      &lt;property name="eclipselink.logging.level" value="FINEST"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>

  <p>Tiedoston persistence.xml voi lisätä kansioon Other Sources, jonka saa näkyviin lisäämällä tiedostoja projektin fyysiseen kansioon <code>src/main/resources</code>.</p>

<img src="opas/other-resources/persistence-xml.png" />
</div>

<div class="tehtavat">
  <p><em>Joudut todennäköisesti hakemaan lisätietoa esim. verkosta, irkistä ja kavereilta näiden tehtävien tekemiseen. Tämä on tarkoituskin. Linkeistä <a href="http://docs.oracle.com/javaee/5/tutorial/doc/bnbpz.html" target="_blank">http://docs.oracle.com/javaee/5/tutorial/doc/bnbpz.html</a>, <a href="http://www.vogella.de/articles/JavaPersistenceAPI/article.html" target="_blank">http://www.vogella.de/articles/JavaPersistenceAPI/article.html</a> ja <a href="http://www.devx.com/Java/Article/33650/0" target="_blank">http://www.devx.com/Java/Article/33650/0</a> on mahdollisesti hyötyä. Älä kuitenkaan käytä niiden konfiguraatiovinkkejä..</em></p> 

  <p>Tehtävissä ei oteta kantaa käyttöliittymän ulkomuotoon -- toteuta käyttöliittymästä itsellesi mielekäs.</p>

  <h3>Huonehallinta</h3>

  <p>Muokkaa GitHubissa osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/dbvarasto">https://github.com/avihavai/wad-2012/tree/master/dbvarasto</a> olevasta projektista huonehallintasovellus, jossa on toiminnallisuus huoneiden lisäämiseen ja poistamiseen. Huoneilla on tietoina <em>tunnus</em>, <em>kerros</em> ja <em>kapasiteetti</em>. Hallinnoinnin tulee tapahtua JSP-sivun avulla.</p>

  <p>Muista muokata <code>persistence.xml</code>-tiedostoa siten, että se sisältää luomasi entiteetin.</p>

  <p>Tehtävä näytetään koetilaisuudessa (jos tehty).</p>

  <h3>Henkilöstörekisteri</h3>
  
  <p>Tee tämä tehtävä edellisen tehtävän jatkoksi. Lisää toimintoihin henkilöstörekisterin ylläpito, jossa on toiminnallisuus henkilöiden lisäämiseen ja poistamiseen. Henkilöillä on tietoina <em>nimi</em>, <em>osoite</em> ja <em>puhelinnumero</em>. Hallinnoinnin tulee tapahtua JSP-sivun avulla.</p>

  <p>Muista muokata <code>persistence.xml</code>-tiedostoa siten, että se sisältää luomasi entiteetin.</p>

  <p>Tehtävä näytetään koetilaisuudessa (jos tehty).</p>

  <h3>Henkilöt huoneisiin</h3>

  <p>Yhdistä ylläolevat sovellukset uudeksi sovellukseksi siten, että henkilöitä voi lisätä huoneisiin. Jokaisella henkilöllä on vain yksi huone, mutta huoneessa voi olla useampi henkilö. Huoneen kapasiteetti määrää maksimimäärän henkilöitä mitä huoneeseen voi laittaa. Huom! Annotaatiosta <code>@OneToMany</code> on tässä hyötyä. Hallinnoinnin tulee tapahtua JSP-sivun avulla.</p>

  <p>Tehtävä näytetään koetilaisuudessa (jos tehty).</p>

  <h3>Elokuvat ja Genret</h3>

  <p>Toteuta sovellus johon tallennetaan tietoa elokuvista ja niihin liittyvistä genreistä. Määrittele Elokuvalle oma taulu, elokuvasta tulee tallentaa ainakin nimi, pituus ja valmistusvuosi. Määrittele myös oma taulu Genrelle. Genrestä tulee tallentaa vain tyyppi. Elokuvan ja Genren välillä kannattaa olla ManyToMany-mäppäys.</p>

  <p>Sovelluksella tulee olla toiminnallisuus elokuvien ja genrejen lisäämiseen, sekä elokuvien listaus genren perusteella.</p>

  <p>Tehtävä näytetään koetilaisuudessa (jos tehty).</p>

</div>

<h2>Pilvipalvelut</h2>

  <p>Pilvipalvelut ovat verkossa toimivia palveluita. Pilvipalveluissa maksetaan vain käytetyistä resursseista -- sovelluksesta (SaaS, <em>Software as a Service</em>), alustasta (PaaS, <em>Platform as a Service</em>) tai laskentakapasiteetista (IaaS, <em>Infrastructure as a Service</em>). Pilvipalveluille ominaista on skaalautuvuus, palveluita käytetään vain kun on tarve. Jos käyttäjiä on paljon, käytössä olevien resurssien määrää voi dynaamisesti lisätä -- jos käyttäjiä on vähän, resurssien määrää voidaan laskea.</p>

  <p>Sovellusalustaa palveluna (PaaS, <em>Platform as a Service</em>) tarjoavat yritykset mahdollistavat järjestelmän nopeamman kehittämisen -- sovelluskehittäjän ei tarvitse välittää alustasta sillä se on jo valmiina. Kustannusten arviointi on helpompaa sillä pilvipalveluiden laskutus tapahtuu käytön mukaan -- sovelluskehittäjä voi lisätä oman ylläpitokurstannuksen. Sovellusalustat piilottavat taustalla olevan infrastruktuurin, jolloin sovelluskehittäjän ei tarvitse välittää taustalla toimivasta palvelusta. Osa PaaS-tarjoajista toimii IaaS-tarjoajien tarjoamien palveluiden päällä: Esimerkiksi kohta tutuksi tuleva Heroku pyörii Amazonin päällä.</p>


<div class="tehtavat">
  <h3>To the Cloud!</h3>

  <p>Luo käyttäjätunnus Heroku-palveluun osoitteessa <a href="https://api.heroku.com/signup" target="_blank">https://api.heroku.com/signup</a> ja seuraa osoitteessa <a href="http://devcenter.heroku.com/articles/java" target="_blank">http://devcenter.heroku.com/articles/java</a> olevia ohjeita. Käytä herokun tarjoamaa valmista sovelluspohjaa.</p>

  <p>Muokkaa sovellusta siten, että viestin "Hello from Java!" sijaan sovellus tulostaa viestin "Hello from Helsinki!".</p>
  
  <p>Kun olet valmis tarkistuta sovellus osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester3/">http://t-avihavai.users.cs.helsinki.fi/tester3/</a> olevassa palvelussa.</p>


  <h3>Käytetyt tunnit, viikko 3</h3>

  <p>Kirjaa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tunnit3" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tunnit3</a> olevaan palveluun kolmannen viikon materiaalin ja tehtävien parissa käyttämäsi aika.</p>
</div>
<h2 id="syotteen_validointi">Validointi</h2>

<p>Olemme tähän mennessä jättäneet web-sovelluksille syötetyn datan validoinnin huomioimatta. Käytännössä kuka tahansa pystyi (ja pystyy!) lisäämään esimerkiksi chat-sovelluksiimme koodia, jota ajetaan käyttäjän koneella. Koodi voi olla yksinkertaista ja harmitonta, esimerkiksi seuraavan lähdekoodipätkän lisääminen chattiin vain <em>kertoo</em> osan mahdollisuuksista.</p>

<pre class="sh_xml">
&lt;SCRIPT SRC=http://www.cs.helsinki.fi/u/avihavai/trololo.js&gt;&lt;/SCRIPT&gt;
</pre>

<p>Lomakkeiden ja lähetettävän datan validointi on web-sovelluksille hyvin oleellista. Emme halua että käyttäjä pääsee lähettämään sovelluksellemme toisten koneilla suoritettavaa koodia. Ensimmäinen askel -- jonka olemme jo ottaneet -- on tallennettavan datan järkevä esitys. Käytämme datan tallentamiseen domain-objekteja, joihin olemme määritelleet kenttien tyypit. Tämä helpottaa työtämme jo hieman: esimerkiksi numerokenttiin ei saa asetettua merkkijonoja. Tämä ei kuitenkaan vielä riitä.</p>

<p>Javassa on oma API verkkosovellusten käyttämän yksinkertaisen datan validoinnille: <a href="http://jcp.org/en/jsr/detail?id=303">Bean Validation API</a>, <a href="http://docs.oracle.com/javaee/6/api/javax/validation/constraints/package-summary.html">Javadoc</a>. Bean validation API on, kuten muutkin JSR-apit, vain rajapinta, jolla on useampi toteuttaja. Valitsemme käyttöömme <a href="http://www.hibernate.org/subprojects/validator.html" target="_blank">Hibernaten Validator</a>-toteutuksen, johon liittyvät riippuvuudet saamme mavenin avulla kätevästi.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
            &lt;version&gt;4.1.0.Final&lt;/version&gt;
            &lt;classifier/&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
                    &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;
                    &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.validation&lt;/groupId&gt;
            &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
            &lt;version&gt;1.0.0.GA&lt;/version&gt;
            &lt;classifier/&gt;
        &lt;/dependency&gt;
</pre>

<p>Yllä poistamme <code>javax.xml.bind.jaxb-api</code> ja <code>com.sun.xml.bind.jaxb-impl</code> kirjastot lisäämästämme Hibernate-riippuvuudesta. Ne on jo ladattu aiemmin käyttämiemme Spring-projektien mukana.</p>

<h3>Muuttujien validointi</h3>

<p>Muuttujien validointia varten tulee määritellä rajoitteet (<em>constraints</em>) tarkistettaville muuttujille. Validointirajapinnan tarjoamat rajoitteet löytyvät <code><a href="http://docs.oracle.com/javaee/6/api/javax/validation/constraints/package-summary.html">javax.validation.constraints</a></code>-pakkauksen dokumentaatiosta.</p>

<p>Luodaan luokka Henkilo. Henkilöllä on henkilötunnus ja nimi. Sovitaan että henkilötunnus ei saa koskaan olla <em>null</em>, ja sen tulee olla tasan 11 merkkiä pitkä. Etunimi saa koostua vain yksittäisestä sanasta (<em>säännölliset lausekkeet ja lama, jea!</em>), ja sen maksimipituus on 10.</p>

<p>Henkilötunnusta varten pakkauksesta <code>javax.validation.constraints</code> löytyy annotaatiot <code>@NotNull</code> ja <code>@Size</code>. Annotaatioihin voidaan määritellä myös virheviestit message-attribuutin avulla.</p>

<pre class="sh_java">
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Henkilo {
  @NotNull(message="Henkilötunnus ei saa olla tyhjä")
  @Size(min=11, max=11, message="Henkilötunnuksessa tulee olla tasan 11 merkkiä")
  private String hetu;

  // getterit ja setterit
}
</pre> 

<p>Etunimeä varten on olemassa annotaatio <code>@Pattern</code>, jolle voimme määritellä säännöllisiä lausekkeita. Javan <code><a href="http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank">Pattern</a></code>-luokan dokumentaatiota lukemalla huomaamme että säännöllinen lauseke <code>\\w+</code> sopii meille hyvin.</p>   

<pre class="sh_java">
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;

public class Henkilo {
  @NotNull(message="Henkilötunnus ei saa olla tyhjä")
  @Size(min=11, max=11, message="Henkilötunnuksessa tulee olla tasan 11 merkkiä")
  private String hetu;

  @Pattern(regexp="\\w+", 
          message="Etunimen tulee koostua tasan yhdestä sanasta, ja se ei saa sisältää erikoismerkkejä.")
  @Size(min = 1, max = 10, message="Etunimen tulee olla vähintään yhden merkin pituinen, korkeintaan 10 merkkiä.")
  private String etunimi;

  // getterit ja setterit
}
</pre> 

<p>Validointi konfiguroidaan annotaatioilla, kuten iso osa muistakin sovelluksiemme osista.</p>

<h3>Kontrollerit, jotka vihaavat validoimattomia kenttiä</h3>

<p>Validoinnin lisääminen kontrollerille on helppoa. Lisäämällä annotaation <code>@Valid</code> (<code>javax.validation.Valid;</code>) kontrollerille lähetettävän luokan alkuun, voimme määritellä luokan olevan validoitava.</p>

<pre class="sh_java">
    @RequestMapping(value = "/henkilo", method = RequestMethod.POST)
    public String postHenkilo(@Valid @ModelAttribute Henkilo henkilo) {
        // .. toteutus
   }
</pre>

<p>Validointi on aktivoitu. Validointivirheet eivät kuitenkaan ole kovin kaunista luettavaa. Tällä hetkellä esimerkiksi virheellisen etunimen kohdalla saamme statuskoodin <code>500</code>, sekä hieman kaoottisen ilmoituksen.</p>

<pre>
org.springframework.web.util.NestedServletException: Request processing failed; 
  nested exception is org.springframework.validation.BindException: 
  org.springframework.validation.BeanPropertyBindingResult: 1 errors
Field error in object 'henkilo' on field 'etunimi': rejected value [<]; 
  codes [Pattern.henkilo.etunimi,Pattern.etunimi,Pattern.java.lang.String,Pattern]; 
  arguments [org.springframework.context.support.DefaultMessageSourceResolvable: 
  codes [henkilo.etunimi,etunimi]; arguments []; 
    default message [etunimi],[Ljavax.validation.constraints.Pattern$Flag;@6d8611d5,\w+]; 
    default message [Etunimen tulee koostua tasan yhdestä sanasta, ja se ei saa sisältää erikoismerkkejä.]
</pre>

<p>Helpotetaan elämäämme hieman kytkemällä tulokset lomakkeisiin.</p>

<h3>Springin lomakkeet ja BindingResult</h3>

<p>Validoidessamme lomakkeita Springin avulla, käytämme <code>BindingResult</code>-luokkaa, johon virheet lisätään sekä Springin lomakkeita, joilla virheet voi näyttää helposti.</p>

<h4>BindingResult</h4>

<p>Luokka <code>BindingResult</code> tallentaa pyyntöjen olioihin mäppäämisessä tapahtuvat virheet itseensä. Kutakin pyyntöä kohden luodaan uusi <code>BindingResult</code>. Voimme pyytää Springiä lisäämään BindingResult-olion kontrolleriimme aivan kuten muitakin olioita. Seuraavassa esimerkki kontrollerista, jossa mäppäyksen tulos lisätään <code>BindingResult</code>-olioon.</p> 

<pre class="sh_java">
    @RequestMapping(value = "/henkilo", method = RequestMethod.POST)
    public String postHenkilo(@Valid @ModelAttribute Henkilo henkilo, BindingResult result) {
        // .. toteutus
   }
</pre>

<p>Ylläolevassa esimerkissä kaikki virheet mitä validoinnissa huomataan tallennetaan suoraan <code>BindingResult</code>-olioon. Oliolla on metodi <code>hasErrors</code>, jonka perusteella voimme päättää jatketaanko pyynnön prosessointia vai ei. Yleinen muoto lomakedataa tallentaville kontrollereille on seuraavanlainen:</p>

<pre class="sh_java">
    @RequestMapping(value = "/henkilo", method = RequestMethod.POST)
    public String postHenkilo(@Valid @ModelAttribute("henkilo") Henkilo henkilo, BindingResult result) {
        if(result.hasErrors()) {
            return "henkilo";
        }

        // .. toteutus
   }
</pre>

<p>Yllä oletetaan että lomake lähetettiin sivulta "henkilo". Eli jos näemme virheen validoinnissa, palaamme takaisin sivulle. Annotaation <code>@ModelAttribute</code> outo parametri <code>command</code> selvenee meille kohta. Tutkitaan seuraavaksi hieman Springin lomakkeita. BindingResult-olio asetetaan aina heti ModelAttributen jälkeen -- se kertoo juuri sitä edeltävän olion luomisen onnistumisesta.</p>

<h4>Lomakkeet</h3>

<p>Spring tarjoaa käyttöömme taglibin lomakkeiden luomiseen ja hallinnointiin. Springin lomaketaglibin saa käyttöön komennolla:</p>

<pre class="sh_xml">
&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%&gt;
</pre>

<p>Tämä tarkoittaa että voimme käyttää springin lomakkeita <code>form:</code>-etuliitteellä. Lomakkeet määritellään kuten normaalit HTML-lomakkeet, mutta muutamalla lisällä. Lomakkeen attribuutti <code>commandName</code> kertoo mihin lomakkeen kentät tulee pyrkiä liittämään. Sitä käytetään yhdessä kontrolleriluokan <code>ModelAttribute</code>-annotaation kanssa. Lomakkeen kentät määritellään polkujen <code>path</code> avulla, jotka kertovat ModelAttribute-annotaatiolla merkityn olion kentät. Ehkä oleellisin on kuitenkin tägi <code>&lt;form:errors path="..." /&gt;</code>, jonka avulla saamme kenttiin liittyvät virheet esille.</p>

<pre class="sh_xml">
&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%&gt;
&lt;%@page contentType="text/html" pageEncoding="UTF-8"%&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;
        &lt;title&gt;Uusi henkilö&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Uusi&lt;/h1&gt;
        &lt;form:form commandName="henkilo" action="${pageContext.request.contextPath}/henkilo" method="POST"&gt;
            &lt;form:input path="hetu" /&gt;&lt;form:errors path="hetu" /&gt;&lt;br/&gt;
            &lt;form:input path="etunimi" /&gt;&lt;form:errors path="etunimi" /&gt;&lt;br/&gt;
            &lt;input type="submit"&gt;
        &lt;/form:form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Yllä on määritelty lomake, joka lähettää lomakkeen tiedot osoitteessa <code>&lt;sovellus&gt;/henkilo</code> olevalle kontrollerille. Kontrollerilla tulee olla määritelty <code>ModelAttribute("henkilo")</code>-annotaatio, jolla määritellään lomakkeen vastaanottaminen. Annotaation <code>@ModelAttribute("henkilo")</code> jälkeen tulee luokka, johon pyynnön data lähetetään. Lomakkeessa </p>

<p>Koska pyrimme validoimaan lähetettyä dataa, liitämme vielä <code>@Valid</code>-annotaation ennen annotaatiota <code>@ModelAttribute("henkilo")</code>.</p>

<p>Ylläolevaa lomaketta kuunteleva kontrolleri olisi esimerkiksi seuraavanlainen -- olettaen että lomake olisi sivulla <code>henkilo.jsp</code></p>

<pre class="sh_java">
    @RequestMapping(value = "/henkilo", method = RequestMethod.POST)
    public String postHenkilo(@Valid @ModelAttribute("henkilo") Henkilo henkilo, BindingResult result) {
        if(result.hasErrors()) {
            return "henkilo";
        }

        // .. tallennus
   }
</pre>

<p>Jos lomakkeella lähetetyissä kentissä on virheitä, virheet tallentuvat <code>BindingResult</code>-olioon. Tarkistamme kontrollerimetodissa ensin virheiden olemassaolon -- jos virheitä on, palataan takaisin lomakkeeseen. Huomaa että virheet ovat pyyntökohtaisia, ja esimerkiksi kutsu "redirect:/henkilo" kadottaisi virheet. Lomakkeen error-kenttiin täytetään <code>BindingResult</code>-olion sisältämät virheviestit -- virhetapauksissa myös juuri luotava olio palautetaan takaisin lomakkeelle, jolloin kenttiin täytetään vanhat arvot.</p>

<p><strong>Huom!</strong> Springin lomakkeita käytettäessä lomakesivut haluavat käyttöönsä olion, johon data pyritään kytkemään jo sivua ladattaessa. Esimerkiksi ylläolevaan henkilolomakkeeseen ohjaava GET-pyyntöjä kuunteleva kontrolleri olisi seuraavanlainen:</p>

<pre class="sh_java">
    @RequestMapping(value = "/henkilo", method = RequestMethod.GET)
    public String getHenkilo(Model model) {
        model.addAttribute("henkilo", new Henkilo());
        return "henkilo";
    }
</pre>

<p>Lomakkeista löytyy lisää tietoa Springin näkymäteknologioihin liittyvän dokumentaation osassa: <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/view.html" target="_blank">http://static.springsource.org/spring/docs/current/spring-framework-reference/html/view.html</a>. Jotta annotaatioilla avulla tapahtuva validointi toimisi, tulee <code>spring-context.xml</code>-konfiguraatiossamme olla rivi <code>&lt;mvc:annotation-driven /&gt;</code>.</p>

<div class="tehtavat">
<h3>Chatin validointi</h3>

<p>Luo chat-sovellus (tai käytä pohjana aiemmin toteuttamaasi sovellusta), jossa käyttäjät voivat kirjoittaa vain normaaleista sanoista koostuvia viestejä. Poista siis mahdollisuus XSS (<em>Cross Site Scripting</em>)-hyökkäysten tekoon. Kun epäilet olevasi valmis, hyökkää sivuasi vastaan sivun <a href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</a> esimerkeillä.</p>

<p>Huom! Varmista myös että käyttäjätunnukseen ei voi lisätä epäilyttäviä viestejä.</p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>
</div>

</div>

<h3>Yleistä validoinnista ja lomakkeista</h3>

<p>Vaikka ylläolevassa esimerkissämme käyttämäämme <code>Henkilo</code>-luokkaa ei oltu merkitty <code>@Entity</code>-annotaatiolla -- eli se ei ollut tallennettavissa tietokantaan -- mikään ei estä meitä lisäämästä sille <code>@Entity</code>-annotaatiota. Toisaalta, lomakkeet voivat usein sisältää tietoa, joka liittyy useaan eri talletettavaan olioon. Silloin tällöin onkin fiksua luoda erillinen lomakkeen validointiin tarkoitettu <em>lomakeobjekti</em>, jonka pohjalta luodaan tietokantaan tallennettavat oliot -- jos validointi on kunnossa. Erilliseen lomakeobjektiin voi täyttää myös esimerkiksi kannasta haettavia listoja ym. ennalta.</p>

<div class="tehtavat">
<h3>Myytävät asunnot</h3>

<p>Luo asunnon myynti-ilmoitusta varten tarkoitettu lomake, jossa kysytään myyjän tiedoista nimi, puhelinnumero ja sähköpostiosoite. Asunnosta kysytään asunnon koko neliömetreinä, osoitetta (postinumero, kaupunki, katuosoite), asunnon rakennusvuosi sekä asunnon kuntoa (hyvä, keskiverto, huono, remontoitava).</p> 

<p>Toteuta lomakkeen validointi yhden lomakeobjektin avulla, mutta käytä taustalla kahta erillistä luokkaa <code>Henkilo</code> ja <code>Asunto</code>. Varmista ettei kukaan pääse rikkomaan sivuasi. Tallenna lopuksi henkilö ja asunto tietokantaan. Tee lomakeobjektin muunnos Henkilo- ja Asunto-objekteiksi palvelukerroksessa. Voit käyttää viime viikolla tarjottua tietokantapohjaa sovellusta varten.</p>

<p>Luo myös yksinkertainen sivu, joka listaa kaikki myytävät asunnot.</p>

<p>Sinun ei tarvitse varautua tilanteeseen jossa henkilöllä olisi samaan aikaan monta asuntoa myynnissä.</p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>
</div>

<p><em>Web-sivusi on tasan niin turvallinen kuin sen heikoiten validoitu datan vastaanottaja.</em></p>


<h2 id="lisaa_tietokannoista">Lisää tietokannoista</h2>

<h3>Oman tietokannan käyttö</h3>

<p>Olemme käyttäneet automaattisesti muistiin ladattavaa tietokantaa sovelluksemme kehitykseen. Mikään ei tietenkään estä jonkun toisaalla toimivan tietokannan käyttöä. Jotta saisimme haluamamme tietokannan käyttöön, meidän tulee ladata tietokannalle sopiva ajuri yhteyden luomista varten sekä konfiguroida dataSource, eli kohde tiedon hakuun.</p>

<p>Muistiin ladattavan tietokannan dataSource-konfiguraatio on ollut muotoa:</p>

<pre class="sh_xml">
&lt;jdbc:embedded-database id="dataSource" type="HSQL"/&gt;
</pre>

<p>Jonka lisäksi olemme tarvinneet HSQLDB-ajurin. Näiden konfiguraatio löytyy ylempää materiaalista.</p>


<h4>MySQL</h4>

	<p>MySQL:n saa käyttöön lisäämällä ajuririippuvuuden pom.xml-tiedostoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.18&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

	<p>Ja muuttamalla datasource-konfiguraation seuraavanlaiseksi:</p>
  
<pre class="sh_xml">
     &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
        &lt;property name="url" value="jdbc:mysql://localhost:3306/awesome"/&gt;
        &lt;property name="username" value="root"/&gt;
        &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
</pre>

	<p>Yllä oletetaan että MySQL toimii paikallisen koneen portissa <code>3306</code> ja tietokannan nimi on <code>awesome</code>. Tietokannan käyttäjätunnus on <code>root</code> ja salasanaa ei ole annettu. Jos olet konfiguroinut <em>dialekteja</em>, muista myös muuttaa ne -- emme tällä kurssilla ole tutustuneet edelliseen.</p>

<h4>PostgreSQL</h4>

<p>Kuten MySQL:n, myös PostgreSQL:n konfigurointi on helpohkoa. PostgreSQL-ajurin saa ladattua lisäämällä seuraavan riippuvuuden pom.xml-tiedostoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;postgresql&lt;/groupId&gt;
            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
            &lt;version&gt;8.4-702.jdbc3&lt;/version&gt;
            &lt;classifier/&gt;
        &lt;/dependency&gt;
</pre>

	<p>Tämän lisäksi myös dataSource tulee konfiguroida.</p>

<pre class="sh_xml">
     &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="driverClassName" value="org.postgresql.Driver"/&gt;
        &lt;property name="url" value="jdbc:postgresql://localhost:5432/awesome"/&gt;
        &lt;property name="username" value="root"/&gt;
        &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
</pre>

<p><em>Jatkamme toistaiseksi paikallisten tietokantojen käyttämistä...</em></p>

<h3>Kahdensuuntaiset relaatiot ja propagointi</h3>

<p>Viime viikolle tarkoitetuissa tehtävissä olemme törmänneet useampaan otteeseen tilanteeseen, jossa haluaisimme tallentaa olion joka viittaa olioon, josta viitataan takaisin. Esimerkiksi henkilön lisäämisessä huoneeseen henkilö tietää huoneesta ja huone henkilöstä. Tämä on tuottanut päänvaivaa monelle.</p>

<p>Normaali ratkaisu on ollut seuraava. Alussa oletamme että meillä on käytössämme DAO-tyyppinen luokka <code>huoneRepository</code>, josta voimme kysyä huoneita sekä tallettaa huoneita. Lisäksi käytössämme on <code>henkiloRepository</code>, jonka avulla voimme tallentaa henkilöitä. Jatkossa puhumma DAO-luokista ja Repository-luokista hieman sekaisin -- tarkoitamme kuitenkin samaa asiaa.</p>

<pre class="sh_java">
    @Override
    @Transactional
    public void lisaaHenkilo(Henkilo henkilo, Long huoneId) {
        Huone huone = huoneRepository.findOne(huoneId); // etsitään oikea huone
        henkilo.setHuone(huone);
        henkilo = henkiloRepository.save(henkilo); // tallennetaan henkilö merge-komennolla
                                                   // näin saamme viitteen luotuun henkilöön

        // MUTTA! Tässä vaiheessa henkilöä ei ole vielä lisätty huoneeseen sillä
        // kukaan ei ole kertonut huoneelle että henkilö on siellä. 

        // lisätään henkilö vielä huoneeseen.
        huone.getHenkilot().add(henkilo);
        huoneRepository.save(huone);
    }
</pre>

<p>Kaksisuuntaisten talletusten ylläpito käsin ei ole kovin mukavaa. Jos luotava henkilö on täysin uusi, seuraava <code>Huone</code>-luokan uusi <code>lisaaHenkilo</code>-metodin luominenkaan ei auta, sillä käytössämme oleva viite henkilö-olioon ei ole sama viite kuin se, joka luodaan kun henkilö luodaan tietokantaan.</p>

<pre class="sh_java">
// Huone-luokka
    public void lisaaHenkilo(Henkilo henkilo) {
        if(!henkilot.contains(henkilo)) {
            henkilot.add(henkilo);
        }

        henkilo.setHuone(this);
    } 
</pre>

<p>Tässä tulee avuksi tallennusten propagointi. Annotaatiolle <code>@OneToMany</code> (sekä muille <code>x-to-x</code>) voi määritellä parametrin <code>cascade</code>, jolla määrittelemme mitkä toiminnot pitää propagoida eteenpäin viitatuille olioille. Voimme esimerkiksi tallentaa Huone-luokan siten, että siihen lisätty -- eli vielä tallentamaton -- henkilö tallennetaan. Tämä tapahtuu seuraavasti. Lisätään Cascade-määre luokalle Huone.</p>

<pre class="sh_java">
@Entity
public class Huone implements Serializable {
    // id ja muut kentät
    @OneToMany(mappedBy = "huone", cascade={CascadeType.MERGE, CascadeType.PERSIST})
    private List&lt;Henkilo&gt; henkilot;
   
    // getterit ja setterit
</pre>

<p>Ylläolevassa esimerkissä oletetaan että luokalla <code>Henkilo</code> on attribuutti <code>private Huone huone</code>, sekä siihen liittyvät getterit ja setterit. Nyt aina kun tallennamme Huone-olion, tallennamme siihen liittyvät tallentamattomat henkilöt. Muokataan metodia, jolla lisätään huone.</p>

<pre class="sh_java">
    @Override
    @Transactional
    public void lisaaHenkilo(Henkilo henkilo, Long huoneId) {
        Huone huone = huoneRepository.findOne(huoneId); // etsitään oikea huone
        huone.getHenkilot().add(henkilo);
        henkilo.setHuone(huone);
        huoneRepository.save(huone); // nyt myös juuri luotava henkilö tallentuu!
    }
</pre>

<p>Vaikka ylläoleva ratkaisu on jo mukavan näköinen on siinä vielä parannettavaa. Joudumme vieläkin asettamaan viittauksen henkilöstä huoneeseen! Lisätään taas edellisessä ratkaisussa yritetty <code>lisaaHenkilo</code>-metodi luokalle <code>Huone</code>.</p>

<pre class="sh_java">
// Huone-luokka
    public void lisaaHenkilo(Henkilo henkilo) {
        if(!henkilot.contains(henkilo)) {
            henkilot.add(henkilo);
        }

        henkilo.setHuone(this);
    } 
</pre>

<p>Nyt metodimme <code>lisaaHenkilo</code> on sopivan siisti.</p>

<pre class="sh_java">
// luokka 
    @Override
    @Transactional
    public void lisaaHenkilo(Henkilo henkilo, Long huoneId) {
        Huone huone = huoneRepository.findOne(huoneId); // etsitään oikea huone
        huone.lisaaHenkilo(henkilo);
        huoneRepository.save(huone); // nyt myös juuri luotava henkilö tallentuu!
    }
</pre>

<p>Annotaatioille @OneToOne, @OneToMany, @ManyToOne ja @ManyToMany voi siis lisätä attribuuttina cascade-arvon, joka kertoo propagoidaanko tehtyjä muutoksia myös viitatuille olioille. Lisää tietoa löytyy muunmuassa Oraclen JavaEE-dokumentaatiosta <a href="http://docs.oracle.com/javaee/5/tutorial/doc/bnbqa.html" target="_blank">täältä</a>.</p>

<div class="tehtavat">
<h3>Henkilöt huoneisiin, osa 2</h3>

<p>Jos et ole vielä tehnyt tehtävää 33: Henkilöt huoneisiin, tee se nyt.</p>

<p>Kun olet tehnyt tehtävän 33, siisti henkilöiden ja huoneiden tallennus ylläolevaa esimerkkiä seuraten.</p>

<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>
</div>


<h3>Spring Data</h3>

<p>Olemme huomanneet että iso osa tietokantatoiminnoista on valmiiden operaatioiden toistamista. Käytännössä lähes jokainen JPA:n kanssa paininut paljon tietokantakyselyitä luova sovelluskehittäjä on jossain vaiheessa luonut itselleen hieman seuraavankaltaisen pohjan, jonka perimällä saa käyttöön oleellisimmat toiminnot.</p>

<pre class="sh_java">
// yleiskäyttönen
public abstract class JPADao&lt;T&gt; implements DAO&lt;T&gt; {

    @PersistenceContext
    EntityManager entityManager;

    private Class clazz;
    
    public JPADao(Class clazz) {
        this.clazz = clazz;
    }   
    
    @Override
    public void create(T instance) {
        entityManager.merge(instance);
    }

    @Override
    public T read(int id) {
        return (T)entityManager.find(clazz, id);
    }

    @Override
    public void delete(T instance) {
        entityManager.remove(instance);
    }

    @Override
    public T update(T instance) {
        return entityManager.merge(instance);
    }
    
    @Override
    public List&lt;T&gt; list() {
        // CriteriaBuilder on ohjelmallinen API kyselyjen tekemiseen
        CriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();
        CriteriaQuery query = criteriaBuilder.createQuery(clazz);
        return entityManager.createQuery(query).getResultList();
    }
}
</pre>

<p>Useat ohjelmistokehittäjät tarjoavat myös tekeleitään muiden käyttöön (esim. <a href="http://code.google.com/p/daofusion/" target="_blank">daofusion</a> ja <a href="http://code.google.com/p/generic-dao/" target="_blank">generic-dao</a>). Näissäkin joudut aina perimään jonkun luokan.</p>

<p>Spring Data (<a href="http://www.springsource.org/spring-data/" target="_blank">http://www.springsource.org/spring-data/</a>) on Spring-sovelluskehykseen liittyvä projekti, joka helpottaa nykyaikaisten tietovarastojen käyttöä. Sen puitteissa on toteutettu myös yllä näytettyjä välineitä JPA:n käyttöön.  Spring Data JPAn etuna muihin "geneeriset daot"-toteutuksiin on integroituminen Spring-sovelluskehykseen, ja sitä kautta pääsy inversion of control ja dependency injection -mekanismeihin. Springin modulaarisesta rakenteesta johtuen joudumme lisäämään Spring Data JPA-komponentin projektimme riippuvuuksiin halutessamme sen käyttöön.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;
            &lt;version&gt;1.0.2.RELEASE&lt;/version&gt;
        &lt;/dependency&gt; 
</pre>


<p>Tämän lisäksi Spring Data haluaa tietää missä repository-luokkamme sijaitsevat. Spring-kontekstiin voi määritellä seuraavan rivin:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       // ... 
       xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xsi:schemaLocation="
       // ...
        http://www.springframework.org/schema/data/jpa
           http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

    &lt;!-- Sovelluksen repository-luokat (DAO-luokat) sijaitsevat pakkauksen wad alla --&gt;
    &lt;jpa:repositories base-package="....repository" /&gt;
    
    // jne
</pre>


<p>Esimerkki: Luodaan luokat <code>Team</code>, joka kuvaa joukkuetta, ja <code>Player</code>, joka kuvaa pelaajaa. Yhdessä joukkueessa on monta pelaajaa, mutta kukin pelaaja kuuluu vain yhteen joukkueeseen.</p>

<pre class="sh_java">
// importit

@Entity
public class Team implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    @OneToMany(mappedBy = "team", cascade={CascadeType.MERGE, CascadeType.PERSIST})
    private List&lt;Player&gt; players;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
    public void addPlayer(Player player) {
        if(!players.contains(player)) {
            players.add(player);
        }
        
        player.setTeam(this);
    }

    public List&lt;Player&gt; getPlayers() {
        return players;
    }

    public void setPlayers(List&lt;Player&gt; players) {
        this.players = players;
    }
}
</pre>


<pre class="sh_java">
// importit

@Entity
public class Player implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @NotNull(message = "Name must be defined.")
    @Size(min = 1, max = 40, message = "Name length must be between 1 and 40.")
    @Pattern(regexp = "\\w+", message = "Name must contain only words.")
    private String name;
    @ManyToOne(cascade = {CascadeType.ALL})
    private Team team;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setTeam(Team team) {
        this.team = team;
    }

    public Team getTeam() {
        return team;
    }
}
</pre>

<p>Luodaan seuraavaksi tietovarastotason toteutukset, oletetaan että tarvitsemme yleiset luo, lue, listaa ja poista-toiminnallisuudet. Luodaan ensin rajapinnat molemmille.</p>

<pre class="sh_java">
public interface TeamRepository extends JpaRepository&lt;Team, Long&gt; {
}
</pre>

<pre class="sh_java">
public interface PlayerRepository extends JpaRepository&lt;Player, Long&gt; {
}
</pre>

<p>Yllä käytämme pohjana Spring Data JPAn tarjoamaa rajapintaa, joka listaa perinteiset metodit. Luodaan seuraavaksi rajapintojen vaatimat toteutukset.</p>

<pre>
</pre>

<p>Done. Huh, kovaa työtä.</p>

<p>Seuraavaksi vielä palvelut, joilla tietovarastoja käytetään. Ensin rajapinnat.</p>

<pre class="sh_java">
public interface TeamService {
    void create(Team team);
    List&lt;Team&gt; list();
}
</pre>

<pre class="sh_java">
public interface PlayerService {
    public void saveOrUpdate(Player player, Long teamId);
    public List&lt;Player&gt; list();
}
</pre>

<p>Ja sitten rajapintojen toteutukset.</p>

<pre class="sh_java">
@Service
public class TeamServiceImpl implements TeamService {

    @Autowired
    TeamRepository teamRepository;

    @Override
    @Transactional
    public void create(Team team) {
        teamRepository.save(team);
    }

    @Override
    @Transactional(readOnly = true)
    public List&lt;Team&gt; list() {
        return teamRepository.findAll();
    }
}
</pre>


<pre class="sh_java">
@Service
public class PlayerServiceImpl implements PlayerService {

    @Autowired
    private PlayerRepository playerRepository;

    @Autowired
    private TeamRepository teamRepository;

    @Override
    @Transactional(readOnly = true)
    public List&lt;Player&gt; list() {
        return playerRepository.findAll();
    }

    @Override
    @Transactional
    public void saveOrUpdate(Player player, Long teamId) {
        Team t = teamRepository.findOne(teamId);
        t.addPlayer(player);
        teamRepository.save(t);
    }
}
</pre>

<p>Tämän jälkeen kontrollerit, näkymä ja lepuutus. Valmista.</p>

<p><strong>Hei! Eihän tuolla toteutettu noita repositoryjä!</strong> Ei niin. Avainsanoina tälle magialle perintä, inversion of control, dependency injection ja sovelluskehykset.</p>

<p>Spring Data JPA ei tarjoa kaikkia kyselyitä valmiiksi. Jos tarvitset tietynlaisen kyselyn, sinun tulee yleensäottaen myös määritellä se. Laajennetaan aiemmin määriteltyä rajapintaa <code>PlayerRepository</code> siten, että sillä on metodi <code>List&lt;Player&gt; findByName(String name)</code> -- eli hae pelaajat joilla on tietty nimi.</p>

<pre class="sh_java">
public interface PlayerRepository extends JpaRepository&lt;Player, Long&gt; {
    List&lt;Player&gt; findByName(String name);
}
</pre>

<p>Ylläoleva esimerkki on esimerkki kyselystä, johon Spring Data ei tarvitse toteutusta. Se arvaa että kysely olisi muotoa <code>SELECT p FROM Player p WHERE p.name = :name</code>, eli luo kyselyn meille valmiiksi. Lisää Spring Data JPA:n kyselyjen arvaamisesta löytyy sen <a href="http://static.springsource.org/spring-data/data-jpa/docs/1.0.2.RELEASE/reference/html/#jpa.query-methods" target="_blank">dokumentaatiosta</a>. Tehdään toinen esimerkki jossa joudumme oikeasti luomaan myös kyselyn itse.</p>


<pre class="sh_java">
public interface PlayerRepository extends JpaRepository&lt;Player, Long&gt; {
    List&lt;Player&gt; findMatti();
}
</pre>

<p>Ja vielä konkreettinen toteutus. Huomaa että toteutus on kuten muutkin repository-luokkamme.</p>

<pre class="sh_java">
@Repository
public class PlayerRepositoryImpl implements PlayerRepository {
    @PersistenceContext
    private EntityManager entityManager;

    public List&lt;Player&gt; findMatti() {
        ... toteutus
    }
}
</pre>

<div class="tehtavat">

<h3>Elokuvat ja Genret, osa 2</h3>

<p>Jos et ole toteuttanut viikon 3 tehtävää 34, Elokuvat ja Genret, toteuta se nyt.</p>

<p>Muokkaa Elokuvat ja Genret toteutustasi siten, että käytät Repository-tasolla Spring Data JPA:ta. Lisää sovellukseesi myös syötteen validointi.</p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>

<h3>Players 'n Teams 'n Budgets</h3>

<p>Muokkaa osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/spring-data-jpa-eclipselink-validation" target="_blank">https://github.com/avihavai/wad-2012/tree/master/spring-data-jpa-eclipselink-validation</a> olevaa projektia siten, että joukkueen nimi validoidaan. Muuta myös pelaajien validointia siten, että pelaajan nimi voi koostua useammasta sanasta.</p>

<p>Tutustu projektin rakenteeseen tarkemmin ja lisää uusi entiteettiluokka <code>AnnualBudget</code>, jolla määritellään joukkueen vuosittainen budjetti. Budjettiin ei tarvitse määritellä avainkenttien lisäksi muuta kuin vuosi ja summa. Luo budjetin lisäykselle oma lomake. </p>

<p>Tämäkin palautetaan vasta koetilanteessa -- ole valmis selittämään mitä jouduit muokkaamaan ja miksi? Mitä et joutunut muokkaamaan?</p>

<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>

</div>


<h2 id="nykyweb">Nykyaikaiset web-palvelut</h2>

<p>Huomattava osa nykyaikaisista web-palveluista tarjoavat lataavat käyttäjälle palvelimelta vain staattisen käyttöliittymän. Käyttöliittymään kuuluu joukko javascript-komponentteja, jotka tuovat ja vievät dataa tarvittaessa käyttäjälle -- esimerkiksi JSON-muodossa. Seuraava tehtäväsarja selventää sovellusten kahtiajakoa.</p>

<div class="tehtavat">

<h3>Tökkel</h3>

<p>Tökkel on ajan- ja projektinhallintaan kehitetty web-sovellus.</p>

<p>Tässä tehtävässä kehitetään osa <em>Tökkel</em>-sovelluksen palvelinpuolen toiminnallisuudesta. Demo valmiista sovelluksesta osoitteesta <a href="http://tokkel.herokuapp.com/app/index.html" target="_blank">http://tokkel.herokuapp.com/app/index.html</a>.</p>

<p>Selainpuolesta kiinnostuneille: Tökkelin käyttöliittymä on rakennettu <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap (v2)</a>-käyttöliittymäkirjaston avulla. Käyttöliittymäkirjaston lisäksi sovelluksen selainpuolella käytetään <a href="http://documentcloud.github.com/backbone/" target="_blank">Backbone.js</a> -nimistä kirjastoa REST-kyselyiden tekemiseen. Backbone.js pohjautuu <a href="http://documentcloud.github.com/underscore/" target="_blank">Underscore.js</a>-kirjastoon, joka tarjoaa joukon apufunktioita. Näiden lisäksi käytössä on <a href="http://jquery.com/" target="_blank">JQuery</a>-javascriptkirjasto.</p>

<p>Käytännössä nykyaikaisissa web-sovelluksissa käytetään sovelluskehyksiä sekä selainpuolella että palvelinpuolella. Vaikka painotamme palvelinpuolen toiminnallisuutta <em>tällä kurssilla</em>, on selainpuolen monipuolinen -- varsinkin javascriptin -- tuntemus tärkeää web-sovelluskehittäjälle.</p>

<p>Tökkelin kimppuun..</p>

<h4>Tökkeliin tutustuminen</h4>

<p>Lataa <em>Tökkel</em>-projekti osoitteesta <a href="https://github.com/avihavai/wad-2012/tree/master/tokkel-hw" target="_blank">https://github.com/avihavai/wad-2012/tree/master/tokkel-hw</a>. Kun käynnistät sovelluksen, Tökkelin toiminnallisuus on osoitteessa <code>http://palvelin/sovellus<strong>/app/index.html</strong></code>. Tökkelille on jo toteutettu tehtävien listaaminen ja lisääminen. Tutustu Tökkelin rakenteeseen ja testaile tehtävien lisäämistä.</p>

<h4>Kontrolleri projekteille</h4>

<p>Projektien hallintaan liittyvän kontrollerin tulee tarjota viisi eri toiminnallisuutta:</p>

<div>
  <ul>
    <li>GET-pyyntö osoitteeseen <code>projects</code> palauttaa JSON-muotoisen listan <code>Project</code>-olioita.</li>
    <li>JSON-muotoinen POST-pyyntö osoitteeseen <code>projects</code> luo uuden projektin, ja tallentaa sen tietokantaan. Kysely palauttaa myös JSON-muotoisen dokumentin -- kontrollerimetodin @RequestMapping-annotaatiossa tulee olla sekä <code>consumes="application/json"</code> että <code>produces="application/json"</code> -attribuutit.</li>

    <li>GET-pyyntö osoitteeseen <code>projects/{projectId}</code> palauttaa projektin pyydetyllä tunnuksella JSON-muodossa.</li>
    <li>PUT-muotoinen pyyntö osoitteeseen <code>projects/{projectId}</code> päivittää tai luo tietyllä tunnuksella merkityn projektin. Tökkel-käyttöliittymä lähettää pyynnön JSON-muotoisena, ja olettaa että pyyntöön vastataan JSON-muotoisena datana. Metodin tulee siis sekä vastaanottaa JSON-muotoinen projekti, että palauttaa JSON-muotoinen projekti.</li>
    <li>DELETE-pyyntö osoitteeseen <code>projects/{projectId}</code> poistaa projektin tietyllä tunnuksella. Metodin ei tarvitse palauttaa mitään arvoa.</li>
  </ul>
</div>

<p>Kun toteutat kontrolleritason metodeja, kannattaa aluksi tulostella debug-viestejä palvelimen logiin. Näin saat tarkistettua milloin pyyntö käyttöliittymältä onnistuu ja milloin ei. Kun saat kaikki kyselyt vastaan -- ja saat palautettua esim. debug-olioita, voit siirtyä eteenpäin.</p>

<h4>Palvelu ja tietokantatoiminnallisuus projekteille</h4>

<p>Kun kontrollerisi toimii, toteuta projekteja varten palvelu- ja tietokantatoiminnallisuus. Ota mallia tehtävien hallinnassa tehdystä toiminnallisuudesta.</p>

<p>Huomaa että sinun tulee myös muokata TaskService-rajapinnan toteutusta. Kun tehtävää lisätään, liitä se projektiin.</p>

<h4>He-ro-kuuu!</h4>

<p>Kun sovelluksesi toimii, lähetä se Herokuun. Projektipohjassa on jo valmiiksi toiminnallisuus, jonka avulla projekti toimii Herokussa. Sinun tarvitsee vain luoda projekti herokun päähän (avainsanoja: cedar, stack) ja lähettää se heidän palveluun (avainsanoja: git, push, heroku, ..).</p>

<p>Kun olet valmis, palauta sovelluksen juuriosoite (esim. http://blazing-sword-19491.herokuapp.com) osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevaan palveluun.</p>
</div>

<h2 id="testaaminen">Web-sovellusten testaaminen</h2>

<p>Web-sovellusten testaamiseen kuuluu yksikkötestaus, integraatiotestaus ja kuormitustestaus. Yksikkötestauksessa testataan sovellukseen kuuluvia yksittäisiä komponentteja ja varmistetaan että niiden tarjoamat rajapinnat toimivat kuten pitäisi, integraatiotestauksessa testataan että komponentit toimivat yhdessä kuten niiden pitäisi, ja kuormitustestauksessa testataan miten tehokkaasti sovellukset kestävät kuormitusta.</p>

<h3>Yksikkötestaus</h3>

<p>Yksikkötestausta tehdään tyypillisesti JUnit-kirjaston avulla. Spring tarjoaa JUnit-kirjastolle integraation, jonka avulla saamme Autowired-annotaatiot toimimaan. Lisätään riippuvuudet projektimme pom.xml-tiedostoon.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
          &lt;version&gt;3.1.0.RELEASE&lt;/version&gt;
          &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;  
            &lt;artifactId&gt;junit&lt;/artifactId&gt;  
            &lt;version&gt;4.8.1&lt;/version&gt;  
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</pre>

<p>Yllä oleva määre <code>scope</code> kertoo milloin riippuvuutta tarvitaan. Käytämme sitä vain testien ajamiseen. Testataan ensin DAO-rajapintaamme PlayerRepository varmistaaksemme että JUnit toimii. Voit käyttää tehtävässä <em>Players 'n Teams 'n Budgets</em> olevaa tehtäväpohjaa.</p>

<pre class="sh_java">
public interface PlayerRepository extends JpaRepository&lt;Player, Long&gt; {
}
</pre>

<p>Spring Data tarjoaa tämänhetkisen PlayerRepository-luokan toiminnallisuudet, joten olisi hyvin outoa jos testit eivät toimisi. Luodaan uusi testi valitsemalla NetBeansista New -> Other -> JUnit -> JUnit Test. Annetaan testiluokalle nimeksi <code>PlayerRepositoryTest</code> ja lisätään se pakkaukseen <code>wad.spring.repository</code>, olettaen että lähdekoodimmekin sijaitsevat samassa pakkauksessa. Huomaa että lähdekoodit ja testikoodit päätyvät erillisiin kansioihin -- juurin näin sen pitääkin olla. Kun testiluokka on luotu, on projektin rakenne kutakuinkin seuraavanlainen.</p>

<pre>
.
|-- nb-configuration.xml
|-- pom.xml
`-- src
    |-- main
    |   |-- java
    |   |   `-- wad
    |   |       `-- spring
    |   |           |-- config
    |   |           |   `-- Config.java
    |   |           |-- controller
    |   |           |   |-- HomeController.java
    |   |           |   |-- PlayerController.java
    |   |           |   `-- TeamController.java
    |   |           |-- domain
    |   |           |   |-- Player.java
    |   |           |   `-- Team.java
    |   |           |-- repository
    |   |           |   |-- PlayerRepository.java
    |   |           |   `-- TeamRepository.java
    |   |           `-- service
    |   |               |-- PlayerServiceImpl.java
    |   |               |-- PlayerService.java
    |   |               |-- TeamServiceImpl.java
    |   |               `-- TeamService.java
    |   |-- resources
    |   |   `-- META-INF
    |   |       `-- persistence.xml
    |   `-- webapp
    |       |-- index.jsp
    |       |-- META-INF
    |       |   `-- context.xml
    |       `-- WEB-INF
    |           |-- glassfish-web.xml
    |           |-- spring-context.xml
    |           |-- spring-database.xml
    |           |-- view
    |           |   |-- list.jsp
    |           |   `-- player.jsp
    |           `-- web.xml
    `-- test
        `-- java
            `-- wad
                `-- spring
                    `-- repository
                        `-- PlayerRepositoryTest.java

</pre>

<p>Paljon tavaraa pienessä projektissa... Kopioi vielä konfiguraatiotiedostot <code>spring-context.xml</code> ja <code>spring-database.xml</code> kansioon <code>src/main/resources/</code>, ja lisää kumpaankin sana -test loppuun. Käytämme näitä konfiguraatioita testien ajamiseen. Projektin runko on nyt seuraavanlainen:</p>

<pre>
.
|-- nb-configuration.xml
|-- pom.xml
`-- src
    |-- main
    |   |-- java
    |   |   `-- wad
    |   |       `-- spring
    |   |           |... jne
    |   |-- resources
    |   |   |-- META-INF
    |   |   |   `-- persistence.xml
    |   |   |-- spring-context-test.xml
    |   |   `-- spring-database-test.xml
    |   `-- webapp
    |       |... jne
    |... jne
    |
    `-- test
        `-- java
            `-- wad
                `-- spring
                    `-- repository
                        `-- PlayerRepositoryTest.java
</pre>

<p>Springiä käyttävät JUnit-yksikkötestit tarvitsevat kaksi annotaatiota alkuun. Annotaatio <code>@RunWith(SpringJUnit4ClassRunner.class)</code> kertoo että käytämme Springiä yksikkötestien ajamiseen, annotaatio <code>@ContextConfiguration(locations = {"classpath:spring-context-test.xml", "classpath:spring-database-test.xml"})</code> kertoo että käytämme classpathissa sijaitsevia tiedostoja <code>spring-context-test.xml</code> ja <code>spring-database-test.xml</code> testien ajamiseen. Testiluokan alku näyttää siis seuraavalta:</p>

<pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:spring-context-test.xml",
    "classpath:spring-database-test.xml"})
public class PlayerRepositoryTest {
   ...
</pre>

<p>Otetaan käyttöön DAO <code>PlayerRepository</code> <code>@Autowired</code>-annotaation avulla ja luodaan ensimmäinen testi. Testi testaa että tietokannassa olevien objektien määrä kasvaa yhdellä kun objekti lisätään tietokantaan.</p>

<pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:spring-context-test.xml",
    "classpath:spring-database-test.xml"})
public class PlayerRepositoryTest {

    @Autowired
    PlayerRepository playerRepository;

    @Test
    public void createIncrementsElementCountByOne() {
        long countAtStart = playerRepository.count();

        Player p = new Player();
        p.setName("Matti");
        playerRepository.save(p);

        long countAtEnd = playerRepository.count();
        Assert.assertTrue("Player count should be increased by one when adding an element.",
                countAtStart + 1 == countAtEnd);
    }
}
</pre>

<p>Kun testi ajetaan, nähdään vihreä palkki!</p>

<div class="tehtavat">
<h3>Yksikkötestejä</h3>

<p>Kirjoita osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/spring-data-jpa-eclipselink-validation" target="_blank">https://github.com/avihavai/wad-2012/tree/master/spring-data-jpa-eclipselink-validation</a> olevalle projektille kolme yksikkötestiä. Ensimmäinen testaa että tallennettujen joukkueiden määrä kasvaa yhdellä kun joukkue tallennetaan tietokantaan. Toinen testaa että kun pelaaja nimeltä "Pekka" tallennetaan tietokantaan, tietokannassa on tämän jälkeen olemassa pelaaja nimeltä Pekka. Kolmas testaa että propagointi toimii: pelaajien määrä kasvaa kahdella kun jo olemassaolevaan joukkueeseen lisätään kaksi pelaajaa ja se tallennetaan tietokantaan.</p>

<pre class="sh_java">
        Team team = new Team();
        team.setName("LeTeam");
        team = teamRepository.save(team);
        
        Player player = new Player();
        player.setName("Matti");
        team.addPlayer(player);

        player = new Player();
        player.setName("Pekka");
        team.addPlayer(player);
        teamRepository.save(team);
</pre>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>

<h3>Joukkueen poistaminen</h3>

<p>Laajenna edellisen tehtävän kolmatta testiä siten, että kutsut lopussa joukkueen poistamista. Määrittele testi siten että pelaajien määrän tulee olla testin lopussa sama kuin testin alussa.</p>

<pre class="sh_java">
        ...
        player.setName("Pekka");
        team.addPlayer(player);
        team = teamRepository.save(team);
        
        teamRepository.delete(team);
        ...
</pre>

<p>Huomaat että testi ei mene läpi. Tee tarvittavat muutokset ohjelmakoodissa jotta testi menee läpi.</p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>

</div>

<p>Rajapintojen käyttämisen hyvä puoli on se, että voimme korvata käytettyjä luokkia lennossa. Esimerkiksi, testimme testaa TeamService-rajapinnan toteuttamaa luokkaa, johon injektoidaan rajapinnan TeamRepository-toteuttama luokka. Määrittelemällä ohjelmallisesti oman konfiguraation, voimme vaihtaa TeamService-luokan käyttämän DAO:n joksikin muuksi. Alla esimerkkinä luokka TeamServiceTest.</p>


<pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"classpath:spring-context-test.xml",
    "classpath:spring-database-test.xml"})
public class TeamServiceTest {

    @Autowired
    TeamService teamService;

    @Configuration
    static class Config {

        // inject this into teamService
        @Bean
        public TeamRepository teamRepository() {
            return new TeamRepositoryTestImpl();
        }
    }

    @Test
    public void testNewTeamHasBeenCreated() {
        Team t = new Team();
        t.setName("Tiimi");
        teamService.create(t);

        List&lt;Team&gt; teams = teamService.list();
        Assert.assertTrue("", teams.size() == 1);
    }
}
</pre>

<p>Testissä käytetään normaalin TeamRepository-rajapinnan toteuttaman luokan sijaan meidän omaa TeamRepositoryTestImpl-luokkaa. Testeissä käytettävät luokat tulee säilyttää testilähdekoodien kanssa samassa paikassa, eli emme halua niitä projektin käyttöön.</p>

<p><strong>Huom!</strong> Ylläoleva esimerkki ei ole toiminut kaikilla, voit tehdä tehtävään toteutuksen myös esimerkiksi siten, että injektoimme TeamService-olion, jolle asetamme käsin tarpeellisen TeamRepositoryTest-olion. Tämä toimii seuraavasti:</p>
<pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class TeamServiceTest {

    @Autowired
    private TeamService teamService;

    @Configuration
    static class Config {

        // this bean will be injected into the TeamService class
        @Bean
        public TeamService teamService() {
            TeamService teamService = new TeamServiceImpl(new TeamRepositoryTestImpl());
            return teamService;
        }
    }
    // ...
}
</pre>

<p>Ylläolevan lisäksi luokka <code>TeamServiceImpl</code> vaatii erillisen konstruktorin, jolle asetetaan TeamRepository. Huomaa että Autowired-annotaatio on siirretty konstruktorin alkuun. Spring-lisää nyt TeamRepository-luokan ilmentymän automaattisesti tälle konstruktorille.</p>

<pre class="sh_java">
@Service
public class TeamServiceImpl implements TeamService {

    private TeamRepository teamRepository;

    public TeamServiceImpl() {
    }

    @Autowired
    public TeamServiceImpl(TeamRepository teamRepository) {
        this.teamRepository = teamRepository;
    }
    // ...
</pre>

<div class="tehtavat">
  <h3>Testiluokan injektointi</h3>

  <p>Tee ylläoleva esimerkki ja määrittele sitä varten erillinen TeamRepository-rajapinnan toteuttava toteutus. Huomaat että toteutus vaatii melko paljon metodeja -- toteuta vain oleellisimmat. Luo seuraavat testit: 1) Testaa että tiimin lisäämisen jälkeen käytössä on samanniminen tiimi.  2) Testaa että tiimin lisäämisen jälkeen tiimilistan koko kasvaa aina yhdellä. 3) Testaa että jokaisella tiimillä on eri id.</p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester4</a> olevassa palvelussa.</p>

</div>

<div class="tehtavat">
  <h3>Käytetyt tunnit, viikko 4</h3>

  <p>Kirjaa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tunnit4" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tunnit4</a> olevaan palveluun neljännen viikon materiaalin ja tehtävien parissa käyttämäsi aika.</p>

</div>


<p>Edellisessä esimerkissä käytimme erikseen määriteltyä sisäluokkaa. Sisäluokan määrittely ei ole pakollista, ja testit voi toteuttaa toki myös määrittelemällä erillisen konfiguraatioluokan.</p>

<pre class="sh_java">
@Configuration
public class TeamServiceConfig {

    @Bean
    public TeamService teamService() {
        TeamService teamService = new TeamServiceImpl(new TeamRepositoryTestImpl());
        return teamService;
    }
}
</pre>

<p>Jotta ajettava testi löytää konfiguraatioluokan, kerromme testille luokan sijainnin <code>@ContextConfiguration</code>-annotaatiolla.</p>

<pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = TeamServiceConfig.class)
public class TeamServiceTest {

    @Autowired
    private TeamService teamService;

    // ...
</pre>


<h3>Profiilit</h3>

<p>Haluamme erilliset konfiguraatiot testaamiseen ja tuotantoon. Testikonfiguraatioiden kopioiminen tuotantokonfiguraatioista loi hieman copy-paste -koodia, sekä ylimääräisen sijainnin konfiguraatioiden hallinnointiin, mikä taas tarkoittaa lisäpaikkaa jossa asiat voivat mennä rikki. Ei hyvä.</p>

<p>Yksi ratkaisu tähän pulmaan on erillisten profiilien käyttö. Profiilien käyttö mahdollistaa eri konfiguraatioiden käytön erilaisissa ympäristöissä. Paikallisille kehitysympäristöille halutaan usein käyttöön oma profiili, jossa on käytössä muistiin ladattava tietokanta. Integraatiopalvelimella halutaan yleensä käyttää erillistä palvelinta, samoin kuin tuotantopalvelimella.</p>

<p>Käytännössä profiilien hallinta kannattaa toteuttaa esimerkiksi niin, että tuotantopalvelimille ja integraatiopalvelimille määritellään ympäristömuuttuja, joka kertoo käytettävän profiilin. Springiä käytettäessä ympäristömuuttuja on <code>SPRING_PROFILES_ACTIVE</code> tai <code>spring.profiles.active</code>.</p>

<h4>Esimerkki</h4>

<p>Haluamme erilliset konfiguraatiot tuotantokäyttöön ja kehityskäyttöön. Tuotantokäytössä käytämme MySQL-tietokantaa, kehityskäytössä muistiin ladattavaa tietokantaa. Sovitaan että tuotantokäytössä käytämme profiilia <code>production</code>, muulloin käytössä profiili <code>dev</code>.</p>

<p>Asetetaan profiili tuotantokoneelle, tässä tehty ympäristömuuttujana</p>

<pre>
export SPRING_PROFILES_ACTIVE=production
</pre>

<p>Konfigurointi profiilien avulla siten, että voimme sisällyttää beans-solmuja beans-solmun sisään on tullut Springiin vasta versiossa 3.1, joten käytetään xml-skeemojen versioita 3.1.</p>

<pre class="sh_xml">
       ...
       xsi:schemaLocation="
        http://www.springframework.org/schema/mvc 
          http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd
        http://www.springframework.org/schema/beans 
          http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
        http://www.springframework.org/schema/context 
          http://www.springframework.org/schema/context/spring-context-3.1.xsd
        http://www.springframework.org/schema/tx 
          http://www.springframework.org/schema/tx/spring-tx-3.1.xsd
        http://www.springframework.org/schema/jdbc 
           http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd
        http://www.springframework.org/schema/data/jpa
           http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;
      ...
</pre>

<p>Määritellään käytetyt datalähteet (<code>dataSource</code>) erikseen profiileille. Tuotantoprofiili käyttää MySQL-tietokantaa, kehitysprofiili muistiin ladattavaa tietokantaa. Profiileihin liittyvät konfiguraatiot tulee määritellä XML-tiedoston loppuun. </p>

<pre class="sh_xml">

    ... muu konfiguraatio
  
    &lt;beans profile="production"&gt;        
        &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
            &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
            &lt;property name="url" value="jdbc:mysql://localhost:3306/awesome"/&gt;
            &lt;property name="username" value="root"/&gt;
            &lt;property name="password" value=""/&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
    
    &lt;beans profile="dev,default"&gt;
        &lt;jdbc:embedded-database id="dataSource" type="HSQL"/&gt; 
    &lt;/beans&gt;
&lt;/beans&gt;
</pre>

<p>Nyt käytössämme on kaksi erillistä konfiguraatiota käytettävälle tietokannalle. Tuotantokäytössä käytetään MySQL:ää, muulloin käytössä on muistiin ladattava HSQL-tietokanta. Profiilin <code>dev</code> pariksi on määritelty <code>default</code>, joka on oletusprofiili.</p>

<p><strong>Huom!</strong> Jos käytössäsi on persistence.xml -tiedosto -- kuten meillä tässä vaiheessa on -- kannattaa siihen luoda kaksi erillistä konfiguraatiota. Toinen kehitysympäristöä ja toinen tuotantoympäristöä varten -- toisessa tietokantataulujen automaattinen generointi, toisessa ei.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.0" xmlns="http://java.sun.com/xml/ns/persistence" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence                               
             http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;
    &lt;persistence-unit name="persistenceUnitDev" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;properties&gt;
            &lt;property name="showSql" value="true"/&gt;
            &lt;property name="eclipselink.ddl-generation" value="drop-and-create-tables"/&gt;
            &lt;property name="eclipselink.ddl-generation.output-mode" value="database"/&gt;
            &lt;property name="eclipselink.weaving" value="false"/&gt;
            &lt;property name="eclipselink.logging.level" value="FINEST"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
    
    &lt;persistence-unit name="persistenceUnitProduction" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;properties&gt;
            &lt;property name="showSql" value="true"/&gt;
            &lt;property name="eclipselink.ddl-generation.output-mode" value="database"/&gt;
            &lt;property name="eclipselink.weaving" value="false"/&gt;
            &lt;property name="eclipselink.logging.level" value="FINEST"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre>

<p>Tällöin konfiguraatiosi muuttuu hieman. Lisäämme profiileihin tiedon Persistence Unit-konfiguraation nimestä, jota haluamme käyttää, sekä viitteen tähän nimeen konfiguraatioon, joka luo EntityManagerFactory-olion.</p>

<pre class="sh_xml">

    ...
    &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="packagesToScan" value="wad.spring.domain"/&gt;
        &lt;property name="persistenceUnitName" value="${persistenceUnitName}" /&gt; 
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;property name="jpaVendorAdapter"&gt;
            &lt;bean class="org.springframework.orm.jpa.vendor.EclipseLinkJpaVendorAdapter" /&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    ...

    &lt;beans profile="production"&gt;
        &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
            &lt;property name="properties" value="persistenceUnitName=persistenceUnitProduction"/&gt;
        &lt;/bean&gt;
        
        &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
            &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
            &lt;property name="url" value="jdbc:mysql://localhost:3306/awesome"/&gt;
            &lt;property name="username" value="root"/&gt;
            &lt;property name="password" value=""/&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
    
    &lt;beans profile="dev,default"&gt;
        &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
            &lt;property name="properties" value="persistenceUnitName=persistenceUnitDev"/&gt;
        &lt;/bean&gt;
        &lt;jdbc:embedded-database id="dataSource" type="HSQL"/&gt; 
    &lt;/beans&gt;
&lt;/beans&gt;
</pre>

<p>Nyt käytössä on kaksi erillistä kantayhteyttä, sekä erilliset persistence.xml-konfiguraatiot.</p>

<p><strong>Huom!</strong> Jos haluat käyttää profiileja Herokussa, voit asettaa Procfileen ylimääräisen parametrin. Esimerkiksi tokkelissa Procfile oli seuraavanlainen.</p>

<pre>
java $JAVA_OPTS -jar target/dependency/jetty-runner.jar --port $PORT target/*.war
</pre>

<p>Jos haluamme käyttöön tietyn profiilin, voimme asettaa sen seuraavasti. Alla olevassa esimerkissä profiiliksi on valittu <code>production</code>.</p> 

<pre>
java -Dspring.profiles.active=production $JAVA_OPTS -jar target/dependency/jetty-runner.jar --port $PORT target/*.war
</pre>

<p>Profiilimäärittelyjä voi käyttää myös testeissä. Esimerkiksi seuraavassa määritellään testi joka ajetaan profiililla on <code>production</code>. Konfiguraatiotiedostojen sijainti on määritelty projektiin liittyvänä polkuna.</p>

<pre class="sh_java">
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"file:src/main/webapp/WEB-INF/spring-context.xml",
    "file:src/main/webapp/WEB-INF/spring-database.xml"})
@ActiveProfiles("production")
public class PlayerRepositoryTest {
   ...
</pre>

<h3>Integraatiotestaus</h3>

<p>Teimme oikeastaan jo edellä integraatiotestejä yksikkötestauksen lomassa. Integraatiotestauksen ideana on tarkistaa toimivatko eri komponentit yhdessä. Komponentit -- kuten tietokanta ja tietokantaa käyttävä logiikka -- voidaan testata komponentti kerrallaan vaihtamalla toteutusta <em>Mock</em>-toteutukseksi kuten teimme TeamService-luokan tietokantatason kanssa.</p>

<p>Tutkitaan tässä kontrolleritason toimintojen testaamista. Tätä varten tarvitsemme -- yleensä -- päällä olevan sovelluksen.</p>

<h4>Selenium</h4>

<p>Selenium on yksi monista web-testauskehyksistä. Seleniumin Webdriver -osa antaa sovelluskehittäjälle mahdollisuuden käydä läpi sovelluksen käyttöliittymää ohjelmallisesti, ja varmistaa että sivuilla on toivotut asiat. Se simuloi myös Javascript-komponenttien toiminnallisuutta, minkä avulla käyttöliittymän testaus helpottuu huomattavasti. Selenium on erittäin hyödyllinen esimerkiksi käyttötapausten läpikäynnissä. Selenium löytyy Mavenin avulla.</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
            &lt;version&gt;2.13.0&lt;/version&gt; 
            &lt;scope&gt;test&lt;/scope&gt; 
        &lt;/dependency&gt;
</pre>

<p>Ajatellaan käyttötapausta jossa käyttäjä haluaa syöttää tunnuksen lomakekenttään ja päätyä toisenlaiselle sivulle. Haluamme tässä löytää lomakekentän nimeltä "tunnus". Kun kenttään asetetaan arvo "Arvo" ja kenttään liittyvä lomake lähetetään, tulee sivulla olla lomakekenttä nimeltä "viesti".</p>

<pre class="sh_java">
        // luodaan olio sivujen läpikäyntiin
        WebDriver driver = new HtmlUnitDriver();

        // haetaan haluttu osoite (aiemmin määritelty muuttuja)
        driver.get(osoite);

        // haetaan kenttä nimeltä tunnus
        WebElement element = driver.findElement(By.name("tunnus"));

        // asetetaan kenttään arvo
        element.sendKeys("Arvo");

        // lähetetään lomake
        element.submit();
	
        // haetaan kenttä nimeltä "viesti"
	element = driver.findElement(By.name("viesti"));
	
        if (element == null) {
            System.out.println("Ei löydy!");
        } else {
            System.out.println("Löytyi!");
        }
</pre>

<p>Yllä käytämme HtmlUnitDriver-oliota html-sivun läpikäyntiin. Haemme ensin määritellyn osoitteen, eli surffaamme haluttuun osoitteeseen. Haemme osoitteesta saadusta lähdekoodista kentän name-attribuutilla "tunnus", ja lisätään kenttään arvo "Arvo". Tämän jälkeen lomake lähetetään. Kun lomake on lähetetty, haetaan kenttää jolla attribuutin name arvona on "viesti". Jos kenttää ei löydy tulostetaan viesti "Ei löydy!", muuten tulostetaan viesti "Löytyi!".</p>

<p>Testejä voi määritellä yksikkötesteiksi kuten muitakin testejä. Alla sama esimerkki yksikkötestinä, joka testaa integraatiopalvelimella olevaa palvelua. Huomaa että konkreettisissa tapauksissa osoite ladattaisiin erikseen konfiguraatiosta.</p>

<pre class="sh_java">

public class SampleIntegrationTest {

    static String osoite = "http://t-avihavai.users.cs.helsinki.fi/lets/Chat";
    private WebDriver webDriver;

    @Before
    public void setup() {
        webDriver = new HtmlUnitDriver();
    }

    @Test
    public void test() {
        // haetaan haluttu osoite (aiemmin määritelty muuttuja)
        webDriver.get(osoite);

        // haetaan kenttä nimeltä tunnus
        WebElement element = webDriver.findElement(By.name("tunnus"));
        Assert.assertNotNull(element);

        // asetetaan kenttään arvo
        element.sendKeys("Arvo");

        // lähetetään lomake
        element.submit();

        // haetaan kenttä nimeltä "viesti"
        element = webDriver.findElement(By.name("viesti"));
        Assert.assertNotNull(element);
    }
}
</pre>

<p>Seleniumia käytetään yleensä yhdessä JBehave-kirjaston kanssa, joka antaa mahdollisuuden testitapausten luomiseen erillisen tekstiformaatin avulla. Lisää JBehave-kirjastosta osoitteessa <a href="http://jbehave.org/reference/stable/">http://jbehave.org/reference/stable/</a>.</p>

<div class="tehtavat">
<h3>Selenium</h3>

<p>Toteuta joukko Selenium-testejä, jossa testaat osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/lets/Chat">http://t-avihavai.users.cs.helsinki.fi/lets/Chat</a> toimivaa Chat-palvelua. Palvelussa on kirjautumissivulla kenttä "tunnus", jonka pitäisi hyväksyä 4-8 merkkiä pitkät tunnukset. Chat-sivulla käyttäjä kirjoittaa viestejä "viesti"-nimiseen kenttään. Viestit ovat rajoittamattoman pitkiä, sovelluksen tulee estää ääkkösten ja nuolien käyttäminen viesteihin.</p>

<p>Luo testit siten, että voit yksilöidä testien perusteella asiat jotka eivät toimi -- ei siis vain yhtä testiä. Kerää ylös asiat jotka eivät toimineet.</p> 


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester5</a> olevassa palvelussa.</p>

</div>

<h4>Spring Test MVC</h4>

<p>Selenium sopii erinomaisesti integraatiotestaukseen, mutta vaatii päällä olevan palvelimen. Palvelin toimii mustana laatikkona, jolloin palvelimen sisäistä toimintaa ei pysty verifioimaan muuten kuin tulosteiden avulla. Lisäksi palvelimen käynnistäminen on usein hidas prosessi, joka ei ole aina toivottua.</p>

<p>Toinen -- Seleniumia tukeva -- lähestymistapa, joka ei vaadi käynnissä olevaa palvelinta, on Springin Test MVC -komponentti. Sen löytää mavenista seuraavilla riippuvuuksilla.</p> 

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-test-mvc&lt;/artifactId&gt;
            &lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</pre>

<p>Tarvitset sitä varten myös <code>pom.xml</code>-tiedostoon erillisen repository-merkinnän. Spring Test MVC on suhteellisen uusi komponentti, joten sitä ei ole vielä normaaleissa tietovarastoissa.</p>

<pre class="sh_xml">
        &lt;repository&gt;
            &lt;id&gt;spring-snapshot&lt;/id&gt;
            &lt;name&gt;Spring Maven SNAPSHOT Repository&lt;/name&gt;
            &lt;url&gt;http://maven.springframework.org/snapshot&lt;/url&gt;
        &lt;/repository&gt;
</pre>

<p>Spring Test MVC mahdollistaa kyselyjen simuloinnin palvelimen näkökulmasta. Sen avulla voi mm. testata että pyynnön vastaukseen liittyvässä modelissa on halutut tiedot, ja että vastaus ohjataan oikeaan paikkaan. Testikehystä käytetään MockMvc-olion avulla, joka toimii Spring-sovelluskehyksenä testille ilman erillistä tarvetta palvelimelle.</p>

<p>Testaus MockMvc:n avulla kyselyn kautta. Ensin teemme kyselyn (esimerkiksi GET-pyynnön haluttuun osoitteeseen), jonka jälkeen kysymme vastaukselta (tai kehykseltä) toivottuja ominaisuuksia. Alla ensimmäinen esimerkki, jossa teemme ensin pyynnön osoitteeseen "/player", ja oletamme että vastauskoodina on 200 eli ok.</p>

<pre class="sh_java">
    @Test
    public void responseOkWhenGetRequestToPlayer() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get("/player")).
                andExpect(MockMvcResultMatchers.status().isOk());
    }
</pre>

<p>Testin toivotut ominaisuudet ketjutetaan. Ylläolevaa testiä voitaisiin jatkaa siten, että haluamme että pyynnön vastaus ohjataan tietylle jsp-sivulle.</p>

<pre class="sh_java">
    @Test
    public void jspResponseOkWhenGetRequestToPlayer() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get("/player")).
                andExpect(MockMvcResultMatchers.status().isOk()).
                andExpect(MockMvcResultMatchers.forwardedUrl("/WEB-INF/view/player.jsp"));
    }
</pre>
 
<p>Vastaavasti voimme testata myös model-objektissa olevia tietoja. Haluamme esimerkiksi että modeliin on lisätty kaksi attribuuttia, ja että attribuuttien nimet ovat "player" ja "teams".</p>

<pre class="sh_java">
    @Test
    public void requestToPlayer() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get("/player")).
                andExpect(MockMvcResultMatchers.status().isOk()).
                andExpect(MockMvcResultMatchers.forwardedUrl("/WEB-INF/view/player.jsp")).
                andExpect(MockMvcResultMatchers.model().size(2)).
                andExpect(MockMvcResultMatchers.model().attributeExists("player")).
                andExpect(MockMvcResultMatchers.model().attributeExists("teams"));
    }
</pre>

<p>Testiluokka kokonaisuudessaan, huomaa että konfiguraatio tapahtuu sekä Setup-vaiheessa että kontekstin avulla. Tähän on lupailtu parannuksia myöhemmissä versioissa.</p>

<pre class="sh_java">

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.web.server.MockMvc;
import org.springframework.test.web.server.request.MockMvcRequestBuilders;
import org.springframework.test.web.server.result.MockMvcResultMatchers;
import org.springframework.test.web.server.setup.MockMvcBuilders;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {"file:src/main/webapp/WEB-INF/spring-context.xml", 
    "file:src/main/webapp/WEB-INF/spring-database.xml"})
public class PlayerIntegrationTest {
    
    MockMvc mockMvc;
    
    @Before
    public void setup() {
        String[] contextLoc = {"file:src/main/webapp/WEB-INF/spring-context.xml",
            "file:src/main/webapp/WEB-INF/spring-database.xml"};
        String warDir = "src/main/webapp";
        mockMvc = MockMvcBuilders.xmlConfigSetup(contextLoc).
                configureWebAppRootDir(warDir, false).build();
    }
    
    @Test
    public void requestToPlayer() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get("/player")).
                andExpect(MockMvcResultMatchers.status().isOk()).
                andExpect(MockMvcResultMatchers.forwardedUrl("/WEB-INF/view/player.jsp")).
                andExpect(MockMvcResultMatchers.model().size(2)).
                andExpect(MockMvcResultMatchers.model().attributeExists("player")).
                andExpect(MockMvcResultMatchers.model().attributeExists("teams"));
    }    
}
</pre>

<div class="tehtavat">
<h3>Spring Test MVC</h3>

<p>Lataa osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/spring-data-jpa-eclipselink-validation" target="_blank">https://github.com/avihavai/wad-2012/tree/master/spring-data-jpa-eclipselink-validation</a> oleva projekti ja luo sille kaksi Spring Test MVC-testitapausta. Toinen tarkastaa että GET-pyyntö osoitteeseen "/team" ohjaa pyynnön osoitteeseen "/home" (tässä avainsanasta <code>redirectedUrl</code> on hyötyä).  Toinen tarkastaa että GET-pyyntö osoitteeseen "/home" lisää vastaukseen liittyvään modeliin attribuutit "players" ja "teams" ja ohjaa vastauksen sivulle "/WEB-INF/view/list.jsp".</p>

<p>Lisää Spring Test MVC:stä löytyy mm. osoitteessa <a href="http://rstoyanchev.github.com/spring-31-and-mvc-test/" target="_blank">http://rstoyanchev.github.com/spring-31-and-mvc-test/</a> olevista kalvoista.</p>

<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester5</a> olevassa palvelussa.</p>

</div>


<h3>Kuormitustestaus</h3>

<p>Kuormitustestauksella testataan sovelluksen sovelluksen toimintaa suuremmilla käyttäjämassoilla. Käyttäjäkokemuksen kannalta oleellisia ovat nopeat vastausajat. Karkeasti ajatellen voidaan ajatella että vastausajat liittyvät käyttäjätyytyväisyys -- nopeusnäkökulmasta -- seuraavasti: 0.1 s = huikea palvelu, 1 s = ok!, 10 s = etsinpä toisen tarjoajan.</p>

<p>Kuormitustestauksella pyritään välttämään tilanteita, joissa palvelu ei suuren käyttäjämääränsä tai käyttäjien toiminnan takia toimikaan.</p>

<h4>Esimerkki</h4>

<p>VR:n lippupalvelu: <a href="http://www.tietoviikko.fi/cio/vr+myontaa+itongelmat+olisi+pitanyt+tunnistaa+etukateen/a697637" target="_blank">http://www.tietoviikko.fi/cio/vr+myontaa+itongelmat+olisi+pitanyt+tunnistaa+etukateen/a697637</a>.</p>

<p><em>Tiedon ja Accenturen VR:lle toimittaman uuden lippukaupan ja -järjestelmän ongelmiin oli lopulta Suonikon mukaan kaksi pääsyytä.</em></p>

<p><em>Verkkokaupan käyttäjämäärät oli arvioitu liian pieniksi lanseerauksen yhteydessä. Asiaa korjattiin sekä laite- että sovelluspalvelintasolla heti julkistuksen jälkeen ja samalla lisättiin mahdollisuus rajoittaa käyttäjämäärää.</em></p>

<p><em>”Julkisuudessa on keskitytty pohtimaan käyttöönottohetken kuormitusta. Se ei kuitenkaan enää ollut syy pitkittyneeseen automaattien poissaoloon”, Suonikko selittää.</em></p>

<p><em>Toinen ongelma oli nimittäin sovelluspalvelimien varusohjelmiston virhe. Oraclen Weblogic-tuotteen versiossa 10 oli tunnettu muistinkäsittelyyn liittyvä bugi, joka tietyssä kovassa kuormitustilassa aiheutti ongelmia ja järjestelmään syntyi epävakautta. Tämä johti lippujärjestelmän sulkemiseen.</em></p>

<p>1). Käyttäjiä oli enemmän kuin oletettu, 2) Sovelluksen käyttämässä komponentissa oli bugi, joka ilmeni kovassa kuormitustilassa. Oliko sovellusta testattu kovassa kuormitustilassa?</p> 

<p>Kuormitustestaukseen usein käytettäviä työkaluja ovat <a href="http://grinder.sourceforge.net/">The Grinder</a> ja <a href="http://jmeter.apache.org/">Apache JMeter</a>.</p>


<h2>Skaalautuvuus</h2>

<p>Käyttäjien määrän kasvaessa sovelluksen tulee skaalautua mukana. Skaalautumiseen on käytännössä kaksi vaihtoehtoa, resurssien kasvattaminen (vertikaalinen skaalautuminen), sekä palvelinmäärän kasvattaminen (horisontaalinen skaalautuminen). Resurssien kasvattamiseen sisältyy lisämuistin hankinta, algoritmien optimointi ym, kun taas palvelinmäärän kasvattamisessa tulee eteen pyyntöjen jakaminen oikeille palvelimille.</p>

<p>Käytännössä skaalautumisesta puhuttaessa puhutaan horisontaalisesta skaalautumisesta, jossa käyttöön hankitaan lisää palvelimia.</p> 

<h3>Horisontaalinen skaalautuminen</h3>

<p>Palvelinmäärän kasvaessa oleellinen asia on pyyntöjen tasainen jakaminen palvelimille. Käytännössä pyyntöjen jakaminen tapahtuu erillisellä palvelimella (tai palvelimilla) -- kuormantasaajan toimesta (<em>load balancer</em>), joka ohjaa pyyntöjä eteenpäin.</p>

<div class="tehtavat">
<h3>Skaalautumiseen liittyvää pohdintaa</h3>

<p>Miten toteuttaisit kuormantasauksen jos käytetty sovellus ei tarvitse tilaa? Entä jos sovellukseen liittyy tila jota ylläpidetään esimerkiksi keksin avulla?</p>

<p>Vastaa osoitteessa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester5</a> olevaan palveluuun.</p>

</div>

<p>Jos sovellukseen ei liity tilaa, voi kuormantasaaja esimerkiksi ohjata pyyntöjä round-robin -tekniikalla. Tosiaalta, kuormantasaaja voi myös seurata palvelinten tilaa, ja ohjata pyyntöjä aina palvelimelle, jolla on vähiten kuormaa. Jos taas sovellukseen liittyy tila, tulee pyynnöt ohjata aina samalle palvelimelle. Tämän voi toteuttaa esimerkiksi siten, että kuormantasaaja lisää pyyntöön keksin jonka avulla käyttäjä identifioidaan ja ohjataan oikealle palvelimelle.</p> 


<h3>Asynkroniset palvelukutsut</h3>

<p>Tähän mennessä toteuttamissamme palveluissa pyynnön suorittaminen on tapahtunut seuraavasti:</p>


<p>
  <ol>
    <li>Pyyntö lähetetään palvelimelle</li>
    <li>Palvelin vastaanottaa pyynnön ja ohjaa pyynnön oikealle kontrollerille</li>
    <li>Kontrolleri vastaanottaa pyynnön ja ohjaa pyynnön oikealle palvelulle</li>
    <li>Palvelu vastaanottaa pyynnön, suorittaa pyyntöön liittyvät operaatiot mahdollisesti muiden palveluiden kanssa, ja palauttaa vastauksen kontrollerille</li>
    <li>Kontrolleri ohjaa pyynnön sopivalle näkymälle, joka palautetaan käyttäjälle.</li>
  </ol>
</p>

<p>Käytännössä -- riippuen sovelluksesta -- meidän ei tarvitse aina odottaa tietokantaoperaatioiden valmistumista. Jos operaatio -- esimerkiksi raskaampi laskenta, tiedon lähetys erilliseen palveluun tai tietynlaisen raportin generointi -- on hidas, kannattaa operaatio suorittaa asynkronisesti.</p>


<p>Asynkroniset metodikutsut tapahtuvat seuraavasti:</p>

<p>
  <ol>
    <li>Pyyntö lähetetään palvelimelle</li>
    <li>Palvelin vastaanottaa pyynnön ja ohjaa pyynnön oikealle kontrollerille</li>
    <li>Kontrolleri vastaanottaa pyynnön ja ohjaa pyynnön oikealle palvelulle</li>
    <li>Palvelu asettaa pyynnön suoritusjonoon ja palvelukutsusta palataan heti (palvelun tyyppi on void)</li>
    <li>Kontrolleri ohjaa pyynnön sopivalle näkymälle, joka palautetaan käyttäjälle.</li>
  </ol>
</p>

<div class="tehtavat">
  <h3>Asynkroniset metodikutsut</h3>

  <p>Kannattaa käyttää sovelluksessa pohjana osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/v5-runko" target="_blank">https://github.com/avihavai/wad-2012/tree/master/v5-runko</a> olevaa runkoa.</p>

  <p>Toteutetaan sovellus, joka näyttää käyttäjälle osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/slow/Service">http://t-avihavai.users.cs.helsinki.fi/slow/Service</a> olevan maailmat räjäyttävän palvelun tuottamaa tietoa. Oletetaan että sovelluksemme saa paljon pyyntöjä, jolloin asiakkaalle ei tarvitse näyttää aina viimeisintä tietoa. Voimme siis toteuttaa pyynnön asynkronisesti.</p>

  <p>Javan valmista kalustoa käyttämällä voi tehdä pyynnön annettuun osoitteeseen esimerkiksi seuraavasti:</p>
<pre class="sh_java">
    public static void main(String[] args) throws Exception {
        URLConnection conn = new URL("http://t-avihavai.users.cs.helsinki.fi/slow/Service").openConnection();
        Scanner sc = new Scanner(conn.getInputStream());
        while(sc.hasNextLine()) {
            System.out.println(sc.nextLine());
        }
    }
</pre>

<h4>Palvelun rajapinta</h4>

<p>Oman sovelluksemme palvelun -- joka kapseloi osoitteessa http://t-avihavai.users.cs.helsinki.fi/slow/Service toimivan palvelun -- tulee tarjota kaksi erillistä toimintoa. Yksi on pyynnön tekemiseen, toinen on tiedon pyytämiseen. Rajapinta on siis seuraavanlainen</p>

<pre class="sh_java">
public interface MaailmaPalvelu {
  void pyyda();
  String lue();
}
</pre>

<p>Jatka allaolevaa toteutusta siten, että luet pyynnön vastauksen viimeisintieto-muuttujaan. 

<pre class="sh_java">
public class MaailmaPalveluImpl implements MaailmaPalvelu {
    private String viimeisinTieto;

    @Override
    public void pyyda() {
        // tee pyyntö osoitteeseen http://t-avihavai.users.cs.helsinki.fi/slow/Service ja tallenna saatu vastaus
        // muuttujaan viimeisinTieto
    }

    @Override
    public String lue() {
        return viimeisinTieto;
    }
}
</pre> 

<h4>Kontrolleri ja sivu</h4>

<p>Luo palvelulle kontrolleri ja näkymä. Näkymässä ei tarvitse olla muuta kuin palautunut tieto. Testaa palveluasi -- testatessa huomaat että pyyntö ei ole asynkroninen ja joudut odottamaan tiedon hakemista.</p>


<h4>Asynkroniset metodikutsut</h4>

<p>Lisää MaailmaPalveluImpl-toteutukseen <code>pyyda</code>-metodikutsun yläpuolelle annotaatio <code>@Async</code>, ja yritä uudelleen.</p>

<p>Huomaa että viestin saapumiseen kestää hetki, eli aivan aluksi palvelussasi muuttujan <code>viimeisinTieto</code> arvo on aluksi <code>null</code>.</p>

<p>Onneksi olkoon! Olet toteuttanut (ehkä) elämäsi ensimmäisen asynkronisen palvelun.</p>

<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester5</a> olevassa palvelussa.</p>

</div> 

<p>Kuten huomasit, asynkronisten metodikutsujen tekeminen Springin avulla on melko helppoa. Kuten normaalisti, tähänkin liittyi konfiguraatiota. Springin konfiguraatiotiedostoon oli lisätty seuraavat rivit:</p>

<pre class="sh_xml">

 xmlns:task="http://www.springframework.org/schema/task"
 xsi:schemaLocation="
        ...
        http://www.springframework.org/schema/task
          http://www.springframework.org/schema/task/spring-task-3.1.xsd
        ..."
</pre>

<p>Yllä määrittelimme nimiavaruuden <code>task</code> varten. Tämän jälkeen tarvitsemme vain rivin, joka sanoo että tehtävien hallinta hoidetaan annotaatioiden avulla.</p>

<pre class="sh_xml">
    &lt;task:annotation-driven /&gt;
</pre>

<p>Voimme vastaavasti toteuttaa palveluita, jotka tekevät toiminnallisuuksia tietyin aikavälein. Voisimme esimerkiksi haluta RSS-lukijan, joka hakee uusimmat uutiset kerran minuutissa. Annotaatio <code>@Scheduled</code> mahdollistaa tietyin aikavälein tapahtuvat pyynnöt. Sille voidaan määritellä ajastuksia esimerkiksi <a href="http://fi.wikipedia.org/wiki/Cron">cron</a>-formaatissa. Seuraava komponentti -- huomaa annotaatio @Component -- Spring lataa komponentin käyttöön sovelluksen alustuksessa, tulostaa jokaisen minuutin ensimmäisellä sekunnilla tämänhetkisen ajan.</p>

<pre class="sh_java">
@Component
public class AllOkService {

    @Scheduled(cron = "1 * * * * *")
    public void minuteHasPassed() {
        System.out.println(new Date());
    }
}
</pre>

<p>Lisää Springin Async- ja Scheduled-annotaatiosta mm. osoittteessa <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html" target="_blank">http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html</a>.</p>

<h3>Viestijonot</h3>

<p>Palveluorientoituneissa arkkitehtuureissa oleellista on palveluiden välillä kulkevien pyyntöjen ja vastausten säilyminen. Yksi lähestymistapa viestien säilymisen varmentamiseen on viestijonot (<em>messaging</em>, <em>message queues</em>), joiden tehtävänä on toimia viestien väliaikaisena säilytyspisteenä. Käytännössä viestijonot ovat erillisiä palveluita, joihin viestien tuottajat (<em>producer</em>) voivat lisätä viestejä, joita viestejä käyttävät palvelut kuluttavat (<em>consumer</em>).</p>

<p>Riippuen palvelusta, viestejä kuluttavat palvelut voivat lähettää vastauksen takaisin viestijonoon, josta viesti joko haetaan myöhemmin tai lähetetään viestin tarvitsevalle palvelulle. Viestijonot, jotka lähettävät viestin takaisin, toteuttavat yleensä varmistustoiminnallisuuden -- jos vastaanottaja ei ole päällä, lähetetään viesti uudelleen myöhemmin.</p>

<p>Viestijonot mahdollistavat myös pub/sub -toiminnallisuuden (publish, subscribe), jossa sovellukset voivat kirjautua viestijonoon ja saada viestejä sitä mukaan kun niitä saapuu. Tämä on hyödyllistä esimerkiksi RSS-syötteissä, pelituloksissa ja vastaavissa sovelluksissa, missä päivitykset eivät ole säännöllisiä vaan tapahtuvat silloin tällöin.</p>

<p>Viestijonostandardeja on useita, Javalla on oma -- suhteellisen pitkään käytössä ollut -- <a href="http://en.wikipedia.org/wiki/Java_Message_Service" target="_blank">JMS</a>, jonka toteuttaa mm. <a href="http://activemq.apache.org/" target="_blank">ActiveMQ</a>. Uudemmissa sovelluksissa <a href="http://www.amqp.org/" target="_blank">AMQP</a>-protokolla on kasvattanut suosiotaan -- AMQP:n toteuttaa muunmaussa <a href="http://www.rabbitmq.com/" target="_blank">RabbitMQ</a>.</p>

<p>Viestijonot -- kuten palveluorientoituneet arkkitehtuurit yleensäottaen -- mahdollistavat eri sovellusten helpon integroitumisen. Viestejä tuottava sovellus voi olla toteutettu esimerkiksi RoR:illa, kun taas viestejä vastaanottava sovellus voidaan toteuttaa esimerkiksi Javalla.</p>


<div class="tehtavat">

<h3>ActiveMQ</h3>

<p>Lataa ActiveMQ osoitteesta <a href="http://activemq.apache.org/activemq-543-release.html" target="_blank">http://activemq.apache.org/activemq-543-release.html</a>. Yleinen *nix-versio käy hyvin.</p>

<p>Kun olet ladannut pakkauksen, pura se sinulle sopivaan kansioon. Käynnistä ActiveMQ seuraavaksi komennolla:</p>

<pre>
apache-activemq-5.4.3 $ ./bin/activemq start
</pre>

<h4>Springin konfigurointi</h4>

<p>Spring tarvitsee ActiveMQ:ta varten erillisen konffin. Lataa projektipohja osoitteesta <a href="https://github.com/avihavai/wad-2012/tree/master/v5-activemq" target="_blank">https://github.com/avihavai/wad-2012/tree/master/v5-activemq</a>. Projektipohjaan on konfiguroitu JMS-template, jota Spring käyttää. Projektipohja myös olettaa että ActiveMQ on käynnissä portissa 61616, joka on ActiveMQ:n oletusportti. </p>

<p>ActiveMQ:n varsinainen konfiguraatio on tiedostossa <code>spring-activemq.xml</code>, joka sijaitsee WEB-INF -kansiossa. Tämän lisäksi <code>pom.xml</code>-tiedostoon on lisätty tarpeelliset riippuvuudet.</p>

<h4>JmsSender</h4>

<p>Projektissa on määritelty rajapinta JmsSender, joka mahdollistaa viestien lähettämisen. Toteuta rajapinta siten, että lähetät viestin jonoon nimeltä "the_queue".</p>

<p>Voit lähettää viestin <code>JmsTemplate</code>-luokan avulla (saat sen <code>@Autowired</code>-annotaatiolla käyttöösi). JmsTemplatella on metodi <code>send</code>, jolle määritellään sekä jonon nimi, että lähetettävä viesti. Voit määritellä lähetettävän viestin MessageCreator -rajapinnan avulla seuraavasti:</p>

<pre class="sh_java">
  MessageCreator messageCreator = new MessageCreator() {
  
      @Override
      public javax.jms.Message createMessage(javax.jms.Session sn) throws JMSException {
          return sn.createTextMessage(message);
      }
  };
</pre>

<p>Huomaa että viestillä (message) tulee olla määrittely <code>final</code>, jotta voit asettaa sen toisen luokan sisään.</p>

<h4>JmsReader</h4>

<p>Projektissa on määritelty myös rajapinta JmsReader, joka mahdollistaa viestien lukemisen. Toteuta rajapinta siten, että luet viestit jonosta nimeltä "the_queue".</p>

<p>Voit lukea viestin <code>JmsTemplate</code>-luokan avulla -- kuten edellisessä osassa, saat sen käyttöösi <code>@Autowired</code>-annotaatiolla. JmsTemplatella on metodi <code>receive</code>, jolle määritellään jono josta viesti luetaan. Huomaa että viesti on muotoa <code>javax.jms.Message</code> vaikka lähetetty viesti oli muotoa <code>TextMessage</code>. Voit muuttaa tyypin castaamalla.</p>

<h4>Testaaminen</h4>

<p>Varmista että sovelluksesi toimii. Kutsu sovelluksen kotiosoitteeseen, <code>.../home</code>, lähettää ensin viestin viestijonoon, jonka jälkeen se pyytää viestiä viestijonolta (kts. <code>HomeController</code>). Varmista että saat viestin jonolta. Jos et, palaa taaksepäin.</p>

<p>Kun olet valmis, sulje ActiveMQ komennolla.</p>
<pre>
apache-activemq-5.4.3 $ ./bin/activemq stop
</pre>

<p>Ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester5</a> olevassa palvelussa.</p>

</div>

<p>Viestijonoon lähetettävät viestit voisivat hyvin olla esimerkiksi JSON-muotoisia viestejä. Kuten huomasit, viestijonot ovat yleensä käyttäjän nimeämiä, ja viestijonoja ylläpitävä palvelin voi hallinnoida useampaa jonoa samaan aikaan.</p>

<h2>Lisää tietokannoista</h2>

<h3>JPA ja olioiden tila</h3>

<p>Olemme tähän mennessä käyttäneet JPA:ta erilaisten rajapintojen kautta pohtimatta suuremmin sen taustatoteutusta. JPA-rajapinnan toteuttavat sovellukset eivät ole vain abstraktio relaatiotietokannan päälle, vaan ne hallinnoivat myös tietokantaan tallennettavien olioiden tilaa. Tutkimme aiemmin <code>PlayerService</code>-esimerkkiä, jossa uusi pelaaja tallennetaan joukkueeseen määritellyn cascade-määreen avulla.</p>

<pre class="sh_java">
@Service
public class PlayerServiceImpl implements PlayerService {

    @Autowired
    private PlayerRepository playerRepository;

    @Autowired
    private TeamRepository teamRepository;

    // ... 

    @Override
    @Transactional
    public void saveOrUpdate(Player player, Long teamId) {
        Team t = teamRepository.findOne(teamId);
        t.addPlayer(player);
        teamRepository.save(t);
    }
}
</pre>

<p>Koska tietokannasta ladatuilla olioilla on tila, jota hallinnoidaan sovelluskehyksen puolesta, ylläoleva toiminnallisuus voidaan toteuttaa myös seuraavasti.</p>

<pre class="sh_java">
@Service
public class PlayerServiceImpl implements PlayerService {

    @Autowired
    private PlayerRepository playerRepository;

    @Autowired
    private TeamRepository teamRepository;

    // ... 

    @Override
    @Transactional
    public void saveOrUpdate(Player player, Long teamId) {
        Team t = teamRepository.findOne(teamId);
        t.addPlayer(player);
    }
}
</pre>

<p>Yllä JPA:n toteuttava ORM-sovelluskehys tallentaa pelaajan hallinnoituun joukkueeseen puolestamme. Tämä onnistuu vain, koska joukkueella on määriteltynä Cascade-määre pelaajiin liittyen.</p>

<p>Käytännössä siis JPA pitää yllä viitteitä olioihin transaktioiden ajan. Transaktion aikana hallinnoituihin olioihin tehdyt muutokset tehdään myös tietokantaan. Hallinnoidut oliot ovat olioita jotka on haettu tietokannasta tai joihin on luotu viite. Esimerkiksi seuraavassa meillä on viite hallinnoituun olioon.</p>

<pre class="sh_java">
    @Override
    @Transactional
    public void savePlayer(Player player) {
        player = playerRepository.save(player);
        // nyt player-viite on hallinnoitu
        player.setName("Bonus");
        // transaktion jälkeen tietokannassa oleva
        // player-oliota vastaavan rivin name-arvo on Bonus 
    }
</pre>

<p>Klassinen virhe on olla ottamatta viitettä haltuun.</p>

<pre class="sh_java">
    @Override
    @Transactional
    public void savePlayer(Player player) {
        playerRepository.save(player);
        
        // pelaaja on tallennettu kantaan, mutta player-viite ei ole
        // olio, joka on hallinnoitu. Hallinnoidun olion viite olisi
        // saatu ylläolevalta save-metodilta
        player.setName("Bonus");
        // transaktion jälkeen tietokannassa oleva
        // player-oliota vastaavan rivin name-arvo ei ole muuttunut 
    }
</pre>

<p>Entiteettien hallinnointi on tarpeen esimerkiksi sovelluksissa, joissa tietokantaan talletettavia olioita käsitellään suoraan käyttöliittymästä: esimerkiksi JSF-käyttöliittymäkirjasto perustuu osittain siihen, että näytettävien olioiden tilaa hallinnoidaan pyyntöjen yli.</p>

<div class="tehtavat">

<h3>Reseptipalvelu</h3>

<p>Toteuta sovellus, johon tallennetaan ruokareseptejä. Jokaiseen reseptiin kuuluu yksi tai useampi raaka-aine. Samaa raaka-ainetta voi käyttää useampi resepti.</p>

<p>Sovelluksen tulee mahdollistaa reseptien listaus, raaka-aineiden ja reseptien lisääminen, sekä reseptien poistaminen. Kun resepti poistetaan, varmista etteivät reseptiin liittyvät raaka-aineet viittaa poistettuun eli olemattomaan reseptiin.</p>

<p>Luo reseptejä varten myös näkymät. Validoi mahdolliset lomakkeet jottei käyttäjä pääse tekemään ilkeyksiä.</p>

<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester5</a> olevassa palvelussa.</p>

</div>

<h3>NoSQL</h3>

<p>Olemme käyttäneet kurssilla tiedon varastointiin relaatiotietokantoja. Relaatiotietokannat toimivat käytännössä erinomaisesti suurimpaan osaan web-sovelluskehityksen tarpeista, ne tarjoavat komentotulkin tiedon tarkasteluun, ja niiden sisältö on kaikille käyttäjille sama. Haasteena ympäristöissä joissa kyselyiden määrä on suuri on skaalautuvuus.</p>

<p>NoSQL (alunperin tietokannat, joissa ei perinteistä SQL-tulkkia, nykyään <em>not only SQL</em>) -tietokannat pyrkivät nopeuteen luotettavuuden kustannuksella. NoSQL-tietokannat noudattavat yleensä BASE-periaatetta ACID-periaatteen sijaan. Yleisesti ottaen NoSQL-kannoissa yksinkertaiset kyselyt voivat olla monia kertoja nopeampia kuin perinteisiin SQL-kantoihin verrattaessa -- vastaavasti monimutkaisissa kyselyissä relaatiotietokantojen kyselynoptimoijat ovat edellä.</p>

<div class="tehtavat">

<h3>NoSQL vai YesSQL</h3>

<p>Lue artikkelit <a href="http://www.tietokone.fi/lehti/tietokone_12_2009/sql_on_tiensa_paassa_8077" target="_blank">http://www.tietokone.fi/lehti/tietokone_12_2009/sql_on_tiensa_paassa_8077</a>, <a href="http://blog.dynatrace.com/2011/10/05/nosql-or-rdbms-are-we-asking-the-right-questions/" target="_blank">http://blog.dynatrace.com/2011/10/05/nosql-or-rdbms-are-we-asking-the-right-questions/</a> ja <a href="http://www.thewindowsclub.com/difference-sql-nosql-comparision" target="_blank">http://www.thewindowsclub.com/difference-sql-nosql-comparision</a>.</p>

<p>Milloin itse valitsisit NoSQL-tietokannan, ja milloin relaatiotietokannan?</p>

<p>Vastaa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester5</a> olevaan palveluun.</p>


<h3>Viikon 5 tunnit</h3>

  <p>Kirjaa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tunnit5" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tunnit5</a> olevaan palveluun viidennen viikon materiaalin ja tehtävien parissa käyttämäsi aika.</p>
</div>



<h2>Tietoturva</h2>

<p><img src="http://imgs.xkcd.com/comics/exploits_of_a_mom.png"/></p>

<h3>OWASP top ten</h3>

<p>Vierailuluento, Jani Kirmanen -- <a href="http://www.silverskin.fi" target="_blank">Silverskin Oy</a></p>

<p>OWASP (<em>Open Web Application Security Project</em>) on verkkosovelluksien tietoturvaan keskittynyt kansainvälinen järjestö. Sen tavoitteena on tiedottaa tietoturvariskeistä ja sitä kautta edesauttaa turvallisten web-sovellusten kehitystä. OWASP-yhteisö pitää yllä listaa merkittävimmistä web-tietoturvariskeistä. Vuoden 2010 lista oli seuraava:</p>

<p>
  <ol>
    <li>Injection</li><br/>
    <li>Cross-Site Scripting (XSS)</li><br/>
    <li>Broken Authentication and Session Management</li>
    <li>Insecure Direct Object References</li><br/>
    <li>Cross-Site Request Forgery (CSRF)</li><br/>
    <li>Security Misconfiguration</li><br/>
    <li>Insecure Cryptographic Storage</li><br/>
    <li>Failure to Restrict URL Access</li><br/>
    <li>Insufficient Transport Layer Protection</li><br/>
    <li>Unvalidated Redirects and Forwards</li><br/>
  </ol>
</p>

<p>Tutustu listaan tarkemmin osoitteessa <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project</a>.</p>

<h3>HTTPS</h3>

<p>HTTPS on HTTP-pyyntöjä SSL (nykyisin myös TLS)-rajapinnan yli. HTTPS mahdollistaa sekä käytetyn palvelun verifioinnin sertifikaattien avulla että lähetetyn ja vastaanotetun tiedon salauksen.</p>

<p>HTTPS-pyynnöissä asiakas ja palvelin sopivat käytettävästä salausmekanismista ennen varsinaista kommunikaatiota. Käytännössä selain ottaa ensiksi yhteyden palvelimen HTTPS-pyyntöjä kuuntelevaan porttiin (yleensä 443), lähettäen palvelimelle listan selaimella käytössä olevista salausmekanismeista. Palvelin valitsee näistä parhaiten sille sopivan (käytännössä vahvimman) salausmekanismin, ja lähettää takaisin salaustunnisteen (palvelimen nimi, sertifikaatti, julkinen salausavain). Selain ottaa mahdollisesti yhteyttä sertifikaatin tarjoajaan -- joka on kolmas osapuoli -- ja tarkistaa onko sertifikaatti kunnossa.</p>

<p>Selain lähettää palvelimelle salauksessa käytettävän satunnaisluvun palvelimen lähettämällä salausavaimella salattuna. Palvelin purkaa viestin ja saa haltuunsa selaimen haluaman satunnaisluvun. Viesti voidaan nyt lähettää salattuna satunnaislukua ja julkista salausavainta käyttäen.</p>

<p>Käytännössä kaikki web-palvelimet tarjoavat HTTPS-toiminnallisuuden valmiina, joskin se täytyy ottaa palvelimilla käyttöön. Esimerkiksi Herokussa HTTPS:n saa käyttöön komennolla <code>heroku addons:add piggyback_ssl</code>. Lisätietoa Herokun SSL-tuesta osoitteessa <a href="http://devcenter.heroku.com/articles/ssl" target="_blank">http://devcenter.heroku.com/articles/ssl</a>.</p>

<h3>Autentikointi</h3>

<p>Autentikointi, eli käyttäjän identiteetin varmistaminen, on yksi web-sovellusten oleellisista ominaisuuksista. Käyttäjän identiteetti tarkistetaan yleisimmin käyttäjätunnus-salasana -parin avulla siten, että käyttäjä lähettää ne HTTPS-yhteyden yli palvelimelle. Kiitettävä osa nykyaikaisista sovelluskehyksistä tarjoaa autentikointimekanismin osana tietoturvakomponenttiaan. Tietoturvatoteutukset toimivat yleensä joko sovelluksen päällä filtteröiden sovellukselle tehtäviä pyyntöjä, tai osana sovellusta tarkistellen myös sovelluksen sisäistä toimintaa.</p>

<p>Käyttäjän identiteetin varmistaminen vaatii käyttäjälistan, joka taas yleensä ottaen tarkoittaa käyttäjän rekisteröintiä palveluun. Käyttäjän rekisteröitymisen vaatiminen heti sovellusta käynnistettäessä voi rajoittaa käyttäjien määrää huomattavasti, joten rekisteröitymistä kannattaa pyytää vasta kun siihen on tarve.</p>

<p>Erillinen rekisteröityminen ei ole aina tarpeen. Web-sovelluksille on käytössä useita  kolmannen osapuolen tarjoamia keskitettyjä identiteetinhallintapalveluita. Esimerkiksi <a href="http://openid.net/" target="_blank">OpenID</a>:n avulla sovelluskehittäjä voi antaa käyttäjilleen mahdollisuuden käyttää jo olemassaolevia tunnuksia.</p>

<h3>Käyttöoikeudet</h3>

<p>Autentikoinnin lisäksi tulee varmistaa, että käyttäjät pääsevät käsiksi vain heille oikeutettuihin resursseihin. Käyttäjät määritellään yleensä joko yksilöllisesti tai roolien kautta. Yleisin lähestymistapa käyttöoikeuksien määrittelyyn on käyttöoikeuslistat (ACL, <em>Access Control List</em>), joiden avulla määritellään käyttäjien (tai käyttäjäroolien) pääsy resursseihin. Käytännössä käyttöoikeuslistat määritellään osoitteille tai metodeille, osalla web-sovelluskehyksistä on kehittyneempi tietoturvakomponentti, joka mahdollistaa myös sovelluksen käyttämien tietorakenteiden sisällön rajoittamisen käyttäjä- tai roolikohtaisesti.</p>

<h3>Spring Security</h3>

<p>Spring-sovelluskehyksen tietoturvakomponentti on Spring Security (aiemmin Acegi Security). Spring tarjoaa tietoturvakomponenttinsa kautta autentikoinnin sekä käyttöoikeuksien hallinnan.</p>

<h4>Spring Securityn käyttöönotto</h4>

<p>Web-sovelluksille kohdistuvat pyynnöt JavaEE-maailmassa kulkevat ensiksi palvelimelle. Palvelin pitää kirjaa sovelluksista, ja ohjaa pyynnön oikealle sovellukselle. JavaEE-standardissa on määritelty filtterit, joita voidaan suorittaa ennen pyynnön ohjautumista Servleteille -- näimme aiemmin jo erään filtterin käyttötapauksen lisätessämme automaattisen merkistökoodauksen sovelluksellemme kappaleessa <a href="#11">11 Merkistöongelmista</a>.</p>

<p>Spring security voidaan ottaa käyttöön vain filtterinä, jolloin se tarkistaa että pyynnöt ohjautuvat oikeisiin resursseihin, tai osana Spring-sovelluskehystä, jolloin voimme kontrolloida pyyntöjä metoditasolla. Koska käytämme komponenttipohjaista arkkitehtuuria, tarvitsemme Spring Securityyn liittyvät riippuvuudet projektiimme. Saamme ne haettua Mavenista kuten riippuvuudet yleensäkin:</p>

<pre class="sh_xml">
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
            &lt;version&gt;3.1.0.RELEASE&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;
            &lt;version&gt;3.1.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-acl&lt;/artifactId&gt;
            &lt;version&gt;3.1.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
</pre>

<p>Yllä haemme tietoturvapuoleen liittyvät oleelliset komponentit. Spring Securityn versiolla 3.1.0.RELEASE on riippuvuus komponentin spring-tx versioon 3.0.6.RELEASE. Tämän komponentin uudempi versio tulee muiden käyttämiemme komponenttien mukana, joten olemme poistaneet sen exclusion-merkinnällä. </p>

<p><em>Hyvä tapa tarkistella riippuvuuksia on esimerkiksi NetBeansin integroitu riippuvuusverkko-toiminnallisuus. Komentoriviä ja mavenia käytettäessä taas komento <code>mvn dependency:tree</code> näyttää projektin riippuvuudet.</em></p>

<p>Riippuvuuksien lataamisen lisäksi tarvitsemme filtterimäärittelyn <code>web.xml</code>-tiedostoon. Web.xml on tiedosto, jonka palvelimet lukevat ensin sovellusta ladattaessa.</p>

<pre class="sh_xml">
    &lt;!-- konfiguraatiotiedosto tietoturvalle --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/spring-security.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
        
    &lt;!-- Filtteri: security, kaikki pyynnöt filtterin läpi --&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

</pre> 

<p>Filtterimäärittelyssä kerromme ensin sovelluksen kontekstille konfiguraatiotiedoston sijainnin -- Spring Security hakee konfiguraationsa web-sovelluksen kontekstista. Tämän jälkeen määrittelemme filtterin <code>springSecurityFilterChain</code>, joka toimii käytännössä välittää pyyntöjä eteenpäin sovelluksellemme. Kuuntelemme kaikkia sovellukseen liittyviä osoitteita (<code>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</code>).</p>

<p>Oleellinen osa konfiguraatiosta on luotuna, nyt sovellukseemme tulevat pyynnöt kulkevat tietoturvafiltterin läpi. Tämän lisäksi määrittelemme tietoturvaan liittyvät asetukset. Esimerkissämme rajoitetaan pääsy tiettyihin osoitteisiin (<code>admin/</code> ja <code>student/</code>), ja luodaan käyttöön kirjautumislomake ja logout-osoite. Lisäksi määritellään käyttäjät -- normaalisti nämä tulevat esimerkiksi tietokannasta.</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns="http://www.springframework.org/schema/security"
             xmlns:beans="http://www.springframework.org/schema/beans"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
            http://www.springframework.org/schema/beans/spring-beans-3.1.xsd 
        http://www.springframework.org/schema/security 
            http://www.springframework.org/schema/security/spring-security-3.1.xsd"&gt;

    &lt;!-- osoitteiden rajoitus --&gt;
    &lt;http use-expressions="true"&gt;
        &lt;intercept-url pattern="/admin/**" access="hasRole('lecturer') or hasRole('assistant')" /&gt;
        &lt;intercept-url pattern="/student/**" access="hasRole('student')" /&gt;
        &lt;intercept-url pattern="/**" access="permitAll" /&gt;
        
        &lt;!-- huom! kun teet sovellusta tuotantokäyttöä varten, permitAll-oletus ei ole hyvä idea! /** --&gt;
        
        &lt;!-- näytä kirjautumislomake tarvittaessa --&gt;
        &lt;form-login /&gt;
        &lt;!-- mahdollisuus logouttiin, ohjaus logoutin jälkeen osoitteeseen /home --&gt;
        &lt;logout logout-success-url="/home" /&gt;
    &lt;/http&gt;
    
    &lt;!-- dummy-käyttäjät --&gt;
    &lt;authentication-manager&gt;
        &lt;authentication-provider&gt;
            &lt;user-service&gt;
                &lt;user name="matti" password="bonus" authorities="lecturer, assistant, student" /&gt;
                &lt;user name="mikael" password="mccartney" authorities="assistant, student" /&gt;
                &lt;user name="arto" password="av" authorities="student" /&gt;
            &lt;/user-service&gt;
        &lt;/authentication-provider&gt;
    &lt;/authentication-manager&gt;
&lt;/beans:beans&gt;
</pre>

<p>Oleellista ylläolevassa konfiguraatiossa on Springin EL-kieli, jonka avulla voimme vaatia erilaisia käyttäjärooleja eri tilanteisiin. Esimerkiksi rivi:</p>

<pre class="sh_xml">
        &lt;intercept-url pattern="/admin/**" access="hasRole('lecturer') or hasRole('assistant')" /&gt;
</pre>

<p>Sanoo että kaikiin pyyntöihin jotka osoitetaan osoitteeseen <code>sovellus/admin/</code> tarvitaan joko rooli <code>lecturer</code> tai rooli <code>assistant</code>. Roolit määritellään yllä authentication-provider -elementin user-service -osiossa.</p>

<p>Osoitteet kiinniottavat <code>intercept-url</code>-elementit tarkistetaan yksi kerrallaan ylhäältä alaspäin kun pyyntöä käsitellessä. Pyyntö pysähtyy ensimmäiseen vastaantulevaan kieltoon. Tekstihahmo <code>/**</code> tarkoittaa kaikkia juurikansion _ja_ alihakemistojen kansioita ja tiedostoja, esimerkiksi yllä viimeinen sääntö antaa kaikkiin sovelluksen osoitteisiin oikeudet jos ja vain jos yksikään aiemmista ehdoista ei ole pysäyttänyt pyyntöä.</p>


<p>Nyt kun käynnistämme sovelluksen ja pyrimme osoitteeseen <code>sovellus/admin/</code>, Spring security ohjaa käyttäjän kirjautumissivulle jos hänellä ei ole oikeuksia sivuun.</p>

<div><img src="opas/security/kirjautuminen.png" /></div>

<p>Lähes kaikki tietoturvakehykset tarjoavat valmiin kirjautumissivun, johon pyynnöt ohjataan jos käyttäjä pyrkii resursseihin joihin hänellä ei ole oikeutta. Kun täytämme ylläolevaan lomakkeeseen käyttäjätunnuksen "arto" ja salasanan "av", saamme virheviestin. Toisaalta, jos yritämme tunnuksilla "matti" ja "bonus", pääsemme toivottuun osoitteeseen.</p>

<p>Springin lomake lähettää parametrit <code>j_username</code> ja <code>j_password</code> osoitteeseen <code>/j_spring_security_check</code>, jota Spring security kuuntelee. Logout-toiminnallisuuden tarjoamiseen riittää linkki osoitteeseen <code>/j_spring_security_logout</code>.</p>

<div class="tehtavat">
<h3>Oma login-sivu</h3>
<p>Toteuta osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/v6-runko" target="_blank">https://github.com/avihavai/wad-2012/tree/master/v6-runko</a> olevaan runkoon oma login-sivusi. Pääset alkuun määrittelemällä <code>form-login</code> elementille osoitteen johon kirjautuessa halutaan siirtyä:</p>

<pre class="sh_xml">
    &lt;form-login login-page="/login" /&gt;
</pre>

<p>Vinkki: JSTL-tägikirjaston avulla saat luotua sovellukseen liittyvän osoitteen helposti komennolla &lt;c:url value="/j_spring_security_check"/&gt;. Muista mihin osoitteeseen lomakkeesi tiedot pitää lähettää _ja_ mitkä tiedot ovat, muista myös että salasanaa ei saa _koskaan_ lähettää GET-metodilla.</p>

<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester6" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester6</a> olevassa palvelussa.</p>

</div>


<p><strong>Metodien suojaaminen</strong></p>

<p>Joskus haluamme suojata pyyntöjä metoditasolla. Metoditason pyyntöjen tarkistamista varten joudumme rekisteröimään Spring securityn konfiguraatiotiedostossa, jossa kontrollerit otetaan käyttöön. Viikon 6 esimerkkisovelluksessa tämä tiedosto on <code>spring-context.xml</code>. Tietoturvaa varten määrittelemme xml-nimiavaruuden:</p>

<pre class="sh_xml">
// tämä lisätään nimiavaruuksien määrittelyyn
       xmlns:security="http://www.springframework.org/schema/security"
// nämä rivit xsi:schemaLocation-määrittelyyn
        http://www.springframework.org/schema/security 
           http://www.springframework.org/schema/security/spring-security-3.1.xsd
</pre>

<p>Tiedostojen määrittelyn jälkeen voimme käyttää niiden tarjoamia toimintoja. Elementti <code>global-method-security</code> tarjoaa määrittelyn metodien tarkasteluun. Huomaa että määrittelimme Spring Securityn nimiavaruudeksi <code>security</code>, joten käytämme etuliitettä <code>security</code> myös elementissä.</p>

<pre class="sh_xml">
    &lt;security:global-method-security pre-post-annotations="enabled"/&gt;
</pre>

<p>Ylläoleva komento määrittelee käyttöömme metodien tarkastelun sekä annotaatiot, joilla voimme määritellä esi- ja jälkiehtoja metodien toiminnalle. Ehdot määritellään yleensä rajapintoihin, esimerkiksi seuraava <code>SecureService</code>-rajapinta määrittelee palvelun, jolla on kolme metodia:</p>

<pre class="sh_java">

public interface SecureService {

    @PreAuthorize("hasRole('lecturer')")
    public void executeOnlyIfAuthenticatedAsLecturer();

    @PreAuthorize("isAuthenticated()")
    public void executeOnlyIfAuthenticated();

    public void executeFreely();
}
</pre>

<p>Metodilla <code>executeOnlyIfAuthenticatedAsLecturer</code> on annotaatio <code>@PreAuthorize("hasRole('lecturer')")</code>, joka määrittelee että metodikutsun tekevän pyynnön tehneellä käyttäjän tulee olla kirjautunut roolilla <code>lecturer</code>. Metodikutsu <code>executeOnlyIfAuthenticated</code> vaatii että käyttäjä on kirjautunut, viimeinen metodikutsu ei vaadi käyttöoikeuksia.</p>

<p>Annotaation <code>@PreAuthorize</code> lisäksi mielenkiintoinen on <code>@PostFilter</code>, jonka avulla voimme poistaa arvoja metodin palauttamasta tietorakenteesta. Määritellään palvelu <code>ObjectFactory</code>, joka palauttaa kokoelman olioita. Määritellään lisäksi sääntö, että olioilla tulee olla kentän <code>awesome</code>-arvo false, tai arvo true _ja_ käyttäjällä rooli <code>lecturer</code>. </p>

<pre class="sh_java">
public interface ObjectFactory {
    @PostFilter("(!filterObject.awesome) or (filterObject.awesome and hasRole('lecturer'))")
    public List&lt;SampleObject&gt; getObjects();
}
</pre>

<p>Jos käyttäjällä ei ole roolia <code>lecturer</code>, ei metodin palauttama lista sisällä koskaan palauta olioita joissa kentän <code>awesome</code> arvo on true.</p>

<p><em>PostFilter-annotaatiolla ei tule korvata järkeviä kyselyitä. Filtteröinti tietokannassa on yleisesti ottaen huomattavasti tehokkaampaa kuin filtteröinti palvelimella.</em></p> 

<div class="tehtavat">
  <h3>PostFilter ja JPA</h3>
  <p>Mitä ongelmia <code>@PostFilter</code>-annotaatio voi tuoda JPA-kyselyiden kanssa? Miksi?</p>


<p>Kirjoita vastauksesi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester6" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester6</a> olevaan palveluun.</p>
</div>

<p><strong>Yleisimmät Spring Securityn EL-kielen komennot</strong></p>

<p>
  <ul>
    <li><code>hasRole('rooli')</code>, varmistaa että käyttäjällä on tietty rooli</li><br/>
    <li><code>hasAnyRole('rooli1', 'rooli2')</code> varmistaa että käyttäjällä on joku listatuista rooleista</li><br/>
    <li><code>isAuthenticated()</code>, varmistaa että käyttäjä on kirjautunut palveluun</li><br/>
    <li><code>isAnonymous()</code>, varmistaa että käyttäjä ei ole kirjautunut</li><br/>
  </ul>
</p>

<p>Komentoja voi myös kytkeä yhteen avainsanojen <code>or</code> ja <code>and</code> avulla. Lisää komentoja ja tietoa komennoista löytyy osoitteesta <a href="http://static.springsource.org/spring-security/site/docs/3.1.x/reference/el-access.html" target="_blank">http://static.springsource.org/spring-security/site/docs/3.1.x/reference/el-access.html</a>.</p>


<h4>Käyttäjätunnuksen löytäminen</h4>

<p>Haluamme usein päästä käsiksi tällä hetkellä kirjautuneeseen käyttäjään. Käyttäjään pääsee käsiksi kontrollereista hyödyntämällä Springin tarjoamaa dependency-injection -mekanismia. Spring security tallentaa käyttäjät palvelimelle Javan <a href="http://docs.oracle.com/javase/6/docs/api/java/security/Principal.html" target="_blank">java.security.Principal</a> -olioina. Voimme siis luoda kontrollerimetodin, johon olio injektoidaan:</p>

<pre class="sh_java">
@Controller
public class AuthenticatedController {

   @RequestMapping("/details")
   public void showDetails(Principal principal) {
       if (principal == null) {
           System.out.println("Not logged in!");
       } else {
           System.out.println("Logged in. Username: " + principal.getName());
       }
   }
}
</pre>

<p>Saamme halutessamme käyttäjätunnuksen käsiin myös tietoturvakontekstista pyynnöllä <code>SecurityContextHolder.getContext().getAuthentication()</code>. Pyyntö palauttaa <code>Authentication</code>-olion, josta saamme käyttäjätunnuksen tarvittaessa.</p>
<pre class="sh_java">
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    if (auth == null) {
        System.out.println("Not logged in!");
    } else {
        System.out.println("Logged in. Username: " + auth.getName());
    }
</pre>

<p>Tietoturvakontekstin suora käyttö ei kuitenkaan ole kovin kaunista, sillä se sitoo meidät suoraan tietoturvatoteutukseen. Tyypillisempi lähestymistapa on tietoturvakontekstin kapselointi erilliseen palveluun esimerkiksi seuraavasti.</p>

<pre class="sh_java">
public interface CredentialsService {
    public String getName();
}
</pre>


<pre class="sh_java">
@Service
public class CredentialsServiceImpl implements CredentialsService {
    public String getName() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth == null) {
            return null;
        }

        return auth.getName();
    }
}
</pre>

<h4>Käyttäjät tietokannasta</h4>

<p>Aiemmassa esimerkissä käyttäjät listattiin suoraan konfiguraatiotiedostoon. Voimme myös ladata käyttäjät tietokannasta. Spring Security olettaa seuraavanlaisen tietokantaskeeman (kts <a href="http://static.springsource.org/spring-security/site/docs/3.1.x/reference/appendix-schema.html" target="_blank">http://static.springsource.org/spring-security/site/docs/3.1.x/reference/appendix-schema.html</a>:</p>

<pre>
  create table users(
      username varchar_ignorecase(50) not null primary key,
      password varchar_ignorecase(50) not null,
      enabled boolean not null);

  create table authorities (
      username varchar_ignorecase(50) not null,
      authority varchar_ignorecase(50) not null,
      constraint fk_authorities_users foreign key(username) references users(username));
      create unique index ix_auth_username on authorities (username,authority);
</pre>

<p>Jos määrittelemme JPA-tietokantaoliot Users ja Authorities, jotka luovat täsmälleen ylläolevat taulut, voimme käyttää tietokantaa jdbc:n yli. Tällöin <code>authentication-provider</code>-konfiguraatio muuttuu seuraavanlaiseksi. Alla oletetaan että datalähteen nimi on <code>dataSource</code>.</p>

<pre class="sh_xml">
    &lt;authentication-provider&gt;
        &lt;jdbc-user-service data-source-ref="dataSource"/&gt;
    &lt;/authentication-provider&gt;
</pre>

<p>Toisaalta, voimme määritellä myös oman palvelun käyttäjän tietojen hakemiseen. Spring Security tarjoaa rajapinnan <code>UserDetailsService</code>, joka tulee toteuttaa omaa palvelua toteuttaessa, kts. esim <a href="https://github.com/avihavai/wad-2012/blob/master/v6-runko-db/src/main/java/wad/spring/service/WadUserDetailsService.java" target="_blank">https://github.com/avihavai/wad-2012/blob/master/v6-runko-db/src/main/java/wad/spring/service/WadUserDetailsService.java</a>.</p>

<div class="tehtavat">
<h3>Käyttäjien hallinta</h3>
<p>Toteuta osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/v6-runko-db" target="_blank">https://github.com/avihavai/wad-2012/tree/master/v6-runko-db</a> olevaan runkoon opiskelijoiden hallintatoiminnallisuus.</p>

<p>Hallintatoiminnallisuus tarjoaa lecturer-roolissa oleville henkilöille (tällä hetkellä vain <code>matti</code>) mahdollisuuden opiskelijoiden lisäämiseen. Opiskelijoiden lisääminen näyttää lomakkeen, johon voidaan täyttää nimi, käyttäjätunnus ja salasana -- salasana on oletuksena "vaihda".</p>

<p>Kun opiskelija kirjautuu luennoitsijan luomilla tunnuksilla, hän näkee omat tietonsa (nimi, käyttäjätunnus ja salasana) lomakkeessa, ja voi muuttaa niitä.</p>

<p><strong>Huom!</strong> Varmista että opiskelijalla on pääsy vain hänen omiin tietoihinsa!</p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester6" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester6</a> olevassa palvelussa.</p>
</div>

<h4>JSP-sivujen näkyvyyden rajoittaminen käyttäjäroolien perusteella</h4>

<p>Spring Security tarjoaa myös taglibin JSP-sivuja varten. Taglib-määrittely on seuraavanlainen.</p>

<pre class="sh_xml">
&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;
</pre>

<p>Security taglibin oleellisin komento on <code>authorize</code>, jonka avulla voimme rajoittaa käyttäjien toimintaa esimerkiksi roolien perusteella. Attribuutille <code>access</code> voidaan määritellä käyttöoikeudet Springin EL-kielellä. Esimerkiksi seuraava JSP-sivu lisää Youtube-videon vain roolille <code>lecturer</code></p>.</p>

<pre class="sh_xml">
&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;
&lt;html&gt;
....

&lt;sec:authorize access="hasRole('lecturer')"&gt; 
  &lt;!-- video näkyy vain roolin lecturer omaaville käyttäjille --&gt;
  &lt;iframe width="853" height="480" 
        src="http://www.youtube.com/embed/kfVsfOSbJY0" 
        frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/sec:authorize&gt;
...
</pre>

<p>Voimme myös hyödyntää sovelluksessa määriteltyjä käyttöoikeuslistoja <code>authorize</code>-tagin avulla. Attribuutti <code>url</code> tarjoaa mahdollisuuden rajoittaa näkyvyyden resursseihin vain niille, keillä olisi pääsy tiettyyn osoitteeseen. Alla rajoitamme edellisen videon näyttämisen vain henkilöille, joilla on pääsy osoitteeseen <code>/admin</code>.</p>

<pre class="sh_xml">
&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;
&lt;html&gt;
....

&lt;sec:authorize url="/admin"&gt; 
  &lt;!-- video näkyy vain osoitteeseen /admin pääseville käyttäjille --&gt;
  &lt;iframe width="853" height="480" 
        src="http://www.youtube.com/embed/kfVsfOSbJY0" 
        frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/sec:authorize&gt;
...
</pre>

<div class="tehtavat">
  <h3>Käyttäjien hallinta, osa 2</h3>
  <p>Muokkaa edellisessä sovelluksessa olevaa lomaketta siten, että opiskelija voi muokata vain nimeään ja salasanaansa. Lisää sovellukseen etusivulle (osoitteeseen <code>/home</code>) myös opiskelijoiden nimien listaus. Jos käyttäjällä on rooli <code>lecturer</code>, saa hän nähdä myös opiskelijoiden käyttäjätunnuksen.</p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester6" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester6</a> olevassa palvelussa.</p>

  <h3>Käyttäjien hallinta, osa 3</h3>

  <p>Lisää sovellukseen kurssit. Jokaisella kurssilla on nimi, yksi luennoija, ja joukko opiskelijoita. Luennoijat voivat luoda kursseja, kurssin luova luennoitsija asetetaan oletuksena myös luennoijaksi. Kurssit listataan etusivulla osoitteessa <code>/home</code>, jos käyttäjä on kirjautunut, voi hän myös ilmoittautua kurssille (kurssin vieressä on tällöin linkki <code>ilmoittaudu</code>). Ilmoittaudu-linkki saa näkyä vaikka opiskelija on jo ilmoittautunut kurssille -- varmista kuitenkin että sama henkilö ei voi ilmoittautua samalle kurssille useasti.</p>

  <p>Näytä etusivulla myös kullekin kurssille ilmoittautuneiden määrä!</p>


  <p><em>Tämä tehtävä vastaa kahta tehtävämerkintää</em></p>


<p>Kun olet valmis, ruksaa tehtävä tehdyksi osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester6" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester6</a> olevassa palvelussa.</p>
</div>

<h2>Taas pilvessä!</h2>

<p>Tökkel-palvelumme -- vaikka huikea onkin -- käytti vain muistiin ladattavaa tietokantaa. Pilvipalvelut toimivat siten, että sovellus poistetaan käytöstä silloin kun sille ei ole kysyntää. Tämä tarkoittaa sitä, että tökkelkin -- kuten muutkin vähän käytössä olevat sovellukset -- poistetaan muistista silloin kun niitä ei tarvita. Tämä johtaa siihen, että muistiin ladattavan tietokannan tiedot katoavat.</p>

<p>Tarvitsemme siis konkreettisen tietokannan käyttöömme. Pilvipalveluiden tarjoajat tarjoavat yleensä myös tietokantakonfiguraatioita sovelluskehittäjille. Amazonin kautta voisi käyttää esimerkiksi MySQL:ää, Heroku taas tarjoaa PostgreSQL-tietokannan käyttöön. Oikeastaan, jokaisella herokun käyttäjällä on käytössä 5 megatavun testitietokanta.</p>

<div class="tehtavat">
<h3>StudentDevs</h3>

<p>Käytä tässä sovelluksessa osoitteessa <a href="https://github.com/avihavai/wad-2012/tree/master/v6-pilveen" target="_blank">https://github.com/avihavai/wad-2012/tree/master/v6-pilveen</a> olevaa sovelluspohjaa. Sovellukseen on valmiiksi konfiguroitu herokun PostgreSQL-tuki tuotantoympäristöön, kehitysympäristössä sovellus käyttää muistiin ladattavaa tietokantaa.</p>

<p>StudentDevs -palvelu tarjoaa toiminnallisuuden opiskelijoiden ja ohjelmointitöitä tarjoavien asiakkaiden lähentämiseksi. Asiakkaat voivat lisätä palveluun projekteja, joista opiskelijat voivat tehdä tarjouksen. Tulevaisuudessa palvelu tarjoaa paljon muutakin -- toteutetaan aluksi perustoiminnallisuudet.</p>

<p>Toteuta StudentDevs -palvelun runko. Rungossa tulee olla opiskelijoita ja asiakkaita. Asiakkaat pystyvät luomaan projekteja, joilla on nimi, kuvaus ja tykkäysten määrä. Asiakkaat voivat myös päivittää lisäämiensä projektien tietoja. Opiskelijat voivat listata projektit, jolloin projektista näkyy nimi ja tykkäysten määrä. Opiskelijat voivat <em>tykätä</em> projektista, joka tapahtuu projektin nimen vieressä olevaa <code>+</code>-linkkiä klikkaamalla. Tällöin projektiin liittyvä tykkäysten määrä kasvaa yhdellä. Kukin opiskelija voi tykätä yhdestä projektista vain kerran. Yksittäisen projektin tietoja tulee päästä katsomaan projektilistassa olevien linkkien avulla.</p>

<p>Huom! Sinun ei tarvitse toteuttaa sivuja, joissa opiskelijoita ja asiakkaita luodaan. Kannattanee toteuttaa tätä varten erillinen kontrolleri, joka lisää opiskelijoita ja asiakkaita tietokantaan.</p>

<p>Varmista että kaikki sovelluksesi kentät validoidaan, eli että ilkeä käyttäjä ei pysty tekemään tuhoja. Asiakkaat saavat muokata vain omia projektejaan.</p>

<p>Lisää sovellus lopulta herokuun. Avainaskeleet:</p>

<pre>
1. heroku login
2. git init (sovelluksen juurikansiossa)
3. git add .
4. git commit -m "initial commit"
5. heroku create --stack cedar
6. git push heroku master
</pre>

<p>Jatkossa sovellukseen tehtyjä muutoksia voi lisäillä komennoilla "git add tiedosto", "git commit -am "commitviesti"", "git push heroku".</p>

<p><em>Tämä tehtävä vastaa kolmea tehtävämerkintää</em></p>


<p>Kun olet valmis, lisää palvelun heroku-osoite osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tester6" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tester6</a> olevaan palveluun.</p>
</div>


<h2>Kokeesta</h2>

<p><em>Kurssin koe järjestetään henkilökohtaisena tai pienryhmissä tapahtuvana näyttökokeena, jossa osallistuja osoittaa osaamisensa kuulustelijoille. Näyttökokeessa keskustellaan ei-ennalta sovituista kurssiin liittyvistä teemoista, joiden hallitsemista ja ymmärtämistä edellytetään osallistujalta.</em></p>

<p>Esimerkkikysymyksiä koetilanteessa:</p>

<p>
  <ul>
    <li>Mitä tarkoittaa <code>"HTTP on tilaton protokolla"</code>? Miten ihmeessä sovellukset pitävät kirjaa käyttäjistä?</li><br/>
    <li>Kuvaa kerrosarkkitehtuuria, mitä hyötyä sen käytöstä on? Mitä haittaa?</li><br/>
    <li>Johdat pientä sovelluskehitysfirmaa, jossa on töissä kuusi sovelluskehittäjää kanssasi. Millaisia työkäytänteitä tai tekniikoita toivoisit sovelluskehittäjiltäsi?</li><br/>
    <li>Mitä hyötyä web-sovellusten hajauttamisesta erillisiksi palveluiksi on? Mitä haittaa?</li><br/>
    <li>Kerro kolmesta OWASP top ten haavoittuvuudesta. Miten ilkeä osapuoli voi hyötyä niiden käytöstä? Miten haavoittuvuuksilta suojaudutaan?</li><br/>
    <li>Mikä on REST ja miten se liittyy HTTP-protokollaan?</li><br/>
    <li>Mikä on DAO pattern ja miten se liittyy kerrosarkkitehtuuriin?</li><br/>
    <li>Mitä tai mikä on ORM? Anna esimerkki!</li><br/>
  </ul>
</p>

<p>Valmistaudu esittelemään toteuttamiasi sovelluksia koetilanteessa. Kokeessa katsotaan useampaa sovellusta, yhden saat valita itse, loput päätetään palauttamiesi sovellusten joukosta. Oleellista sovelluksessa on hyvä rakenne, järkevä muuttujien nimentä ja jatkokehityksen helppous.</p>

<p>Arvostelusta: Kurssin arvostelu perustuu pitkälti tehtyjen tehtävien määrään. Jos koetilanteessa tulee ilmi että hallitset aihepiirin hyvin, voidaan harjoitustehtävien määrän määräämää arvosanaa nostaa yhdellä. Jos taas koetilanteessa huomataan että et ole itse tehnyt tehtäviä, arvosanaa voidaan laskea hylättyyn asti.</p>

<p>Koeilmoittautumisesta tulee lisätietoa lähipäivinä.</p>

<h3>Rästitehtäviä</h3>

<p>Jos haluat paikata aiemmilla viikoilla väliin jääneitä rästitehtäviä ylimääräisillä harjoituksilla, ota yhteyttä.</p>

<div class="tehtavat">
<h3>Kurssipalaute</h3>

<p>Käy antamassa kurssipalautetta osoitteessa <a href="https://ilmo.cs.helsinki.fi/kurssit/servlet/Valinta">https://ilmo.cs.helsinki.fi/kurssit/servlet/Valinta</a>. Kirjoita palautteeseen erityisesti <em>mitä odotit kurssilta?</em>, ja <em>miten kurssia voisi mielestäsi parantaa seuraavaa toteutusta ajatellen?</em> -- olettaen että kurssi järjestetään uudelleen.</p>

<p>Vastapalautteessa otetaan huomioon myös tuntikirjauksia tehdessä tehdyt palautteet. Kun kirjoitat palautetta viimeisen viikon tehtävistä, oletamme että annoit myös kurssipalautetta.</p>

<h3>Viimeisen viikon tunnit</h3>

<p>Kirjaa osoitteessa <a href="http://t-avihavai.users.cs.helsinki.fi/tunnit6" target="_blank">http://t-avihavai.users.cs.helsinki.fi/tunnit6</a> olevaan palveluun kuudennen viikon materiaalin ja tehtävien parissa käyttämäsi aika.</p>

</div>

<!--
VK2: Build-työkalut; ant & Maven, Web-sovelluskehykset; Spring (IOC + DI), palveluorientoitunut alku
VK3: Palveluorientoituneet web-sovellukset (rest, json), Testaus, JPA
VK4: Virheensieto, Pilvi
VK5: skaalautuvuus, MQ
VK6: Tietoturva


<h2>ohjelmistotyypit</h2>



		<h2 id="web_sovelluskehykset">Web-sovelluskehykset</h2>

		<p>http://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks</p>
		<p>Request oriented, page oriented, yada.. Django, Play framework, Sinatra, Rails, Struts, GWT, Stripes, Zend, ...</p>

		<h3 id="front_controller">Front Controller</h3>

		<h3 id="yleiset_palvelut">Yleiset palvelut</h3>

		templatet, tietoturva, db-access, url-mäppäys, 

		<h3 id="templatet">Templating</h3>
		
		<p>vanhaa kamaa oikeasti, javascriptillä ja css:llä datan rendaus, pyynnössä vain staattinen kama</p>

		<h4 id="template_inheritance">Template inheritance</h4>
		
		<p>tiles, struts,</p>


		<h3 id="web_sovelluskehyksen_valinta">Sopivan web-sovelluskehyksen valinta</h3>

		<p>muutama sana, älkää valitko fw:tä jolla ei tukea. Katsokaa että on olemassa yhteisö joka on elossa ja että työkalua kehitetään aktiivisesti. Hype on siistiä, mutta ei aina kannata lähteä sen mukaan. </p>

		<p>Oman tekeminen? Oletko varma ettei sitä ole jo tehty..</p>

		<h2 id="ensimmäinen_oikea_ohjelma">Chat</h2>

		<p>templateilla</p>

		<h2 id="kerrostettu_arkkitehtuuri">Kerrostettu arkkitehtuuri</h2>

		<p>Olio-ohjelmoinnin periaatteet: single responsibility principle, program to interfaces not to concrete implementations, vältä perintää..</p>

		<p>useita kerroksia (näkymä, kontrolli, logiikka, kanta)</p>
 
		<h2 id="tiedon_tallentaminen">Persistointi</h2>


		<p>tähän mennessä tiedot kadonneet kun web-servo suljetaan</p>
		
		<p>persistointi, RDBMS/ORM</p>

		<p>Chat jatkuu, nyt kanta johon viestit</p>

		<p>NoSQL</p>
		
http://stackoverflow.com/questions/3522069/when-to-replace-rdbms-orm-with-nosql

		http://nosql-database.org/




		<h2 id="turvalliset_sovellukset">Tietoturva</h2>


		<h2 id="skaalautuvuus">Skaalautuvuus</h2>

		horisontaalinen ja vertikaalinen

		
		<h2 id="palveluorientoituneet_arkkitehtuurit">Palveluorientoituneet arkkitehtuurit</h2>

		loose coupling

		<h2 id="kaytettavyys">Käytettävyys</h2>

		<p>vasteaika: 0.1 (jes!), 1 (~käytettävä), 10 (ei kykene)</p>

		<h3 id="viestijonot">Message Queues</h3>

		<p>Jos tarttee tehdä jotain vähän raskaampaa, ei kannata pistää käyttäjää odottamaan. työ jonoon!</p>

		<h2 id="pilvipalvelut">Pilvipalvelut</h2>




  <h3>HTML5 ja nykyaikainen web</h3>

  <p>Tutustu sivustoon <a href="http://html5boilerplate.com/" target="_blank">http://html5boilerplate.com/</a>.</p>
//-->


</body>
</html>

